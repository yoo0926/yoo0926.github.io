<!doctype html>
<html lang="ko"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="robots" content="noindex"><meta><title>태그: spring - 하루하루 끄적끄적</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="하루하루 끄적끄적"><meta name="msapplication-TileImage" content="/img/favicon.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="하루하루 끄적끄적"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="티끌모아 태산이라 티끌부터 모아본다."><meta property="og:type" content="blog"><meta property="og:title" content="하루하루 끄적끄적"><meta property="og:url" content="https://yoo0926.github.io/"><meta property="og:site_name" content="하루하루 끄적끄적"><meta property="og:description" content="티끌모아 태산이라 티끌부터 모아본다."><meta property="og:locale" content="ko_KR"><meta property="og:image" content="https://yoo0926.github.io/img/og_image.png"><meta property="article:author" content="Jaeyong Yoo"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://yoo0926.github.io"},"headline":"하루하루 끄적끄적","image":["https://yoo0926.github.io/img/og_image.png"],"author":{"@type":"Person","name":"Jaeyong Yoo"},"publisher":{"@type":"Organization","name":"하루하루 끄적끄적","logo":{"@type":"ImageObject","url":"https://yoo0926.github.io/img/logo-header.png"}},"description":"티끌모아 태산이라 티끌부터 모아본다."}</script><link rel="icon" href="/img/favicon.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/dracula.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><script src="https://www.googletagmanager.com/gtag/js?id=G-EKSGRQ3VMZ" async></script><script>window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
    
        gtag('config', 'G-EKSGRQ3VMZ');</script><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/rss2.xml" title="하루하루 끄적끄적" type="application/rss+xml">
</head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo-header.png" alt="하루하루 끄적끄적" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="external nofollow noopener noreferrer" title="Download on GitHub" href="https://github.com/yoo0926/yoo0926.github.io"><i class="fab fa-github"></i></a><a class="navbar-item search" title="검색" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-9-tablet is-9-desktop is-9-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/tags">태그</a></li><li class="is-active"><a href="#" aria-current="page">spring</a></li></ul></nav></div></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time datetime="2023-02-14T06:27:21.000Z" title="2023. 2. 14. 오후 3:27:21">2023-02-14</time>&nbsp;게시 됨</span><span class="level-item"><time datetime="2023-05-29T08:27:50.899Z" title="2023. 5. 29. 오후 5:27:50">2023-05-29</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/spring/">spring</a><span> / </span><a class="link-muted" href="/categories/spring/WebFlux/">WebFlux</a></span><span class="level-item">9분안에 읽기 (약 1284 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/02/14/spring/WebFlux/spring-webflux-2/">Flux와 Stream의 reduce, 그리고 chatGPT</a></h1><div class="content"><p>평소처럼 개발하던 중 reduce를 사용한 코드에서 오류가 발생했다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">java: cannot find symbol</span><br><span class="line">  symbol: variable accumulatedMap</span><br><span class="line"></span><br><span class="line">java: cannot find symbol</span><br><span class="line">  symbol: variable currentMap</span><br></pre></td></tr></table></figure>
<p>오류가 발생한 상황을 샘플코드로 대략적으로 재현해봤다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sample 1</span></span><br><span class="line">List&lt;Integer&gt; list = IntStream.range(<span class="number">0</span>,<span class="number">10</span>).boxed().collect(Collectors.toList());</span><br><span class="line"><span class="type">var</span> <span class="variable">collectMap</span> <span class="operator">=</span> list.stream()</span><br><span class="line">        .map(i -&gt; &#123;</span><br><span class="line">            Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">            map.put(<span class="string">&quot;key&quot;</span> + i, i * <span class="number">10</span>);</span><br><span class="line">            <span class="keyword">return</span> map;</span><br><span class="line">        &#125;)</span><br><span class="line">				.reduce(**Collections.emptyMap()**, (accumulatedMap, currentMap) -&gt; <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;() &#123;</span><br><span class="line">            &#123;</span><br><span class="line">                putAll(accumulatedMap);</span><br><span class="line">                putAll(currentMap);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">System.out.println(<span class="string">&quot;Stream reduce Map size: &quot;</span> + collectMap.size());</span><br><span class="line"><span class="comment">// Stream reduce Map size: 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// sample 2</span></span><br><span class="line">Flux.range(<span class="number">1</span>, <span class="number">10</span>)</span><br><span class="line">        .map(i -&gt; &#123;</span><br><span class="line">            Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">            map.put(<span class="string">&quot;key&quot;</span> + i, i * <span class="number">10</span>);</span><br><span class="line">            <span class="keyword">return</span> map;</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="comment">//.reduce(**Collections.emptyMap()** ,(accumulatedMap, currentMap) -&gt; new HashMap&lt;&gt;() &#123; // compile error!! &gt; `java: cannot find symbol`</span></span><br><span class="line">        .reduce((accumulatedMap, currentMap) -&gt; <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;() &#123;</span><br><span class="line">            &#123;</span><br><span class="line">                putAll(accumulatedMap);</span><br><span class="line">                putAll(currentMap);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        .doOnNext(map -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Flux reduce Map size: &quot;</span> + map.size());</span><br><span class="line">        &#125;)</span><br><span class="line">        .subscribe();</span><br><span class="line"><span class="comment">// Flux reduce Map size: 10</span></span><br></pre></td></tr></table></figure>
<p>Stream과 Flux의 reduce를 호출 시 initial 파라미터로 각각 <code>Collections.emptyMap()</code>를 사용하였으나 Stream은 정상동작하지만 Flux에선 컴파일 오류가 발생하였다.</p>
<p>여러 케이스로 바꿔가면서 테스트를 해보니 Collections.emptyMap()의 반환값이 불변객체라서 안되는거 같다는 추론까진 도달했지만 확신은 없었다.</p>
<p>구글링으로 찾아보려고 했지만 공식문서를 봐도 Flux에선 안되고 Stream에선 되는 이유에 대해서 명확한 답변을 찾기 어려워서 고민하던차에 요즘 핫한 chatGPT에 물어볼까 하는 생각이 들어서 바로 실행해봤다.</p>
<p>아래는 chatGPT 와 대화한 내용</p>
<hr>
<blockquote>
<p>i want <code>public final &lt;A&gt; Mono&lt;A&gt; reduce(A initial, BiFunction&lt;A,? super T,A&gt; accumulator)</code> example code.</p>
</blockquote>
<ul>
<li>
<p>Here’s an example of how you could use the <strong><code>reduce</code></strong> method in Spring WebFlux:</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> reactor.core.publisher.Flux;</span><br><span class="line"><span class="keyword">import</span> reactor.core.publisher.Mono;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.function.BiFunction;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReduceExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Flux&lt;Integer&gt; numbers = Flux.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        BiFunction&lt;Integer, Integer, Integer&gt; accumulator = (a, b) -&gt; a + b;</span><br><span class="line">        Mono&lt;Integer&gt; sum = numbers.reduce(<span class="number">0</span>, accumulator);</span><br><span class="line"></span><br><span class="line">        sum.subscribe(result -&gt; System.out.println(<span class="string">&quot;The sum of the numbers is: &quot;</span> + result));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This example creates a <strong><code>Flux</code></strong> of integers and then uses the <strong><code>reduce</code></strong> method to sum them up. The <strong><code>reduce</code></strong> method takes an initial value, in this case <strong><code>0</code></strong>, and a <strong><code>BiFunction</code></strong> that specifies how the current accumulation (<strong><code>a</code></strong>) is combined with each element from the flux (<strong><code>b</code></strong>) to produce the next accumulation.<br>
The <strong><code>subscribe</code></strong> method is then used to subscribe to the <strong><code>Mono</code></strong> returned by <strong><code>reduce</code></strong> and print out the result.</p>
</li>
</ul>
<blockquote>
<p>initial Type is HashMap</p>
</blockquote>
<ul>
<li>
<p>Here’s an example of how you could use the <strong><code>reduce</code></strong> method with an initial value of a <strong><code>HashMap</code></strong>:</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> reactor.core.publisher.Flux;</span><br><span class="line"><span class="keyword">import</span> reactor.core.publisher.Mono;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.function.BiFunction;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReduceExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Flux&lt;String&gt; words = Flux.just(<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;cherry&quot;</span>, <span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>);</span><br><span class="line"></span><br><span class="line">        BiFunction&lt;HashMap&lt;String, Integer&gt;, String, HashMap&lt;String, Integer&gt;&gt; accumulator = (map, word) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (!map.containsKey(word)) &#123;</span><br><span class="line">                map.put(word, <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                map.put(word, map.get(word) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> map;</span><br><span class="line">        &#125;;</span><br><span class="line">        Mono&lt;HashMap&lt;String, Integer&gt;&gt; wordCounts = words.reduce(<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(), accumulator);</span><br><span class="line"></span><br><span class="line">        wordCounts.subscribe(result -&gt; System.out.println(<span class="string">&quot;The word counts are: &quot;</span> + result));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This example creates a <strong><code>Flux</code></strong> of strings and uses the <strong><code>reduce</code></strong> method to count the occurrences of each word. The <strong><code>reduce</code></strong> method takes an initial value, in this case a new empty <strong><code>HashMap</code></strong>, and a <strong><code>BiFunction</code></strong> that specifies how the current <strong><code>HashMap</code></strong> (<strong><code>map</code></strong>) is combined with each word from the flux (<strong><code>word</code></strong>) to produce the next <strong><code>HashMap</code></strong>.<br>
The <strong><code>subscribe</code></strong> method is then used to subscribe to the <strong><code>Mono</code></strong> returned by <strong><code>reduce</code></strong> and print out the result.</p>
</li>
</ul>
<blockquote>
<p>Why does <code>Mono&lt;HashMap&lt;String, Integer&gt;&gt; wordCounts = words.reduce(Collections.emptyMap(), accumulator);</code> error occur?</p>
</blockquote>
<ul>
<li>
<p>The error occurs because <strong><code>Collections.emptyMap()</code></strong> returns an unmodifiable map, which means you can’t modify it. The <strong><code>reduce</code></strong> method expects the accumulator function to modify the accumulator object, which is not possible with an unmodifiable map.<br>
You can resolve the issue by creating a new empty <strong><code>HashMap</code></strong> as the initial value instead of using <strong><code>Collections.emptyMap()</code></strong>, like this:</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mono&lt;HashMap&lt;String, Integer&gt;&gt; wordCounts = words.reduce(<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(), accumulator);</span><br></pre></td></tr></table></figure>
<p>This will give you a modifiable map that can be updated by the accumulator function as required by the <strong><code>reduce</code></strong> method.</p>
</li>
</ul>
<blockquote>
<p>But why does Java Stream API succeed?</p>
</blockquote>
<ul>
<li>The Java Stream API allows you to use the <strong><code>reduce</code></strong> method with an initial value of <strong><code>Collections.emptyMap()</code></strong> because the <strong><code>reduce</code></strong> operation in the Stream API operates on an internal data structure that is separate from the original data source. This allows the Stream API to handle unmodifiable maps as the initial value without any issues.<br>
However, in reactive programming with Spring WebFlux, the <strong><code>reduce</code></strong> method operates on the data stream directly, so you need to provide an accumulator object that is mutable. That’s why you need to use a new empty <strong><code>HashMap</code></strong> instead of <strong><code>Collections.emptyMap()</code></strong> as the initial value.</li>
</ul>
<hr>
<p>별로 기대하지 않았는데 원하는 내용에 대해서 생각보다 정확한 답변을 들을 수 있었다.</p>
<ol>
<li>먼저 Flux의 reduce 호출 시<code>initial</code>가 HashMap인 케이스로 샘플코드를 요청하고 Collections.emptyMap() 을 초기값으로 사용 시 왜 오류가 나는지 물어봤고<br>
Collections.emptyMap()으로 생성되는 객체는 returns an unmodifiable map 즉, immutable(불변)객체인데 reduce 메서드는 초기값으로 들어온 accumulator 객체를 수정할 것으로 예상했지만 수정이 불가능한 불변객체가 들어와서 오류가 발생하는거라고 한다.</li>
<li>Stream의 reduce에선 왜 성공하는지? 에 대해선<br>
Stream의 reduce는 원래 데이터와는 다른 별도의 내부 데이터 구조에서 동작하기 때문에 Collections.emptyMap()의 초기값으로 reduce를 사용할 수 있지만<br>
리액티브 프로그래밍 기반의 WebFlux에선 데이터 스트림에서 reduce 메서드가 직접 동작하기 때문에 변경가능한 accumulator 객체를  제공해야 하므로 변경이 가능한 빈 HashMap 객체를 생성해야 한다고 답변하였다.</li>
</ol>
<p>앞으로 나의 코딩선생님이 하나 더 늘었다는 생각에 흥분되면서도 한편으론 chatGPT를 사용해서 구글의 코딩인터뷰 Level3도 통과했다는 뉴스처럼 문맥을 파악해서 의도한 바를 정확하게 알려주는 답변을 보고 소름이 돋았다.</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time datetime="2023-01-19T14:21:55.000Z" title="2023. 1. 19. 오후 11:21:55">2023-01-19</time>&nbsp;게시 됨</span><span class="level-item"><time datetime="2023-05-29T08:27:45.574Z" title="2023. 5. 29. 오후 5:27:45">2023-05-29</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/spring/">spring</a><span> / </span><a class="link-muted" href="/categories/spring/WebFlux/">WebFlux</a></span><span class="level-item">3분안에 읽기 (약 440 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/01/19/spring/WebFlux/spring-webflux-1/">publishOn과 subscribeOn</a></h1><div class="content"><p>회사에서 WebFlux로 개발하면서 publishOn과 subscribeOn의 사용법이 매번 헷갈려서 최대한 간단하게 정리를 해봤다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Flux.range(<span class="number">1</span>,<span class="number">3</span>)</span><br><span class="line">    .subscribeOn(Schedulers.newBoundedElastic(<span class="number">1</span>,<span class="number">1</span>,<span class="string">&quot;sub2&quot;</span>))</span><br><span class="line">    .doOnNext(i -&gt; log.info(<span class="string">&quot;main 1: &#123;&#125;, number: &#123;&#125;&quot;</span>, Thread.currentThread().getName(), i))</span><br><span class="line">    .publishOn(Schedulers.newBoundedElastic(<span class="number">1</span>,<span class="number">1</span>,<span class="string">&quot;pub1&quot;</span>))</span><br><span class="line">    .doOnNext(i -&gt; log.info(<span class="string">&quot;main 2: &#123;&#125;, number: &#123;&#125;&quot;</span>, Thread.currentThread().getName(), i))</span><br><span class="line">    .subscribeOn(Schedulers.newBoundedElastic(<span class="number">1</span>,<span class="number">1</span>,<span class="string">&quot;sub1&quot;</span>))</span><br><span class="line">    .subscribe();</span><br><span class="line"></span><br><span class="line"><span class="comment">// log</span></span><br><span class="line">main <span class="number">1</span>: sub2-<span class="number">3</span>, number: <span class="number">1</span></span><br><span class="line">main <span class="number">1</span>: sub2-<span class="number">3</span>, number: <span class="number">2</span></span><br><span class="line">main <span class="number">1</span>: sub2-<span class="number">3</span>, number: <span class="number">3</span></span><br><span class="line">main <span class="number">2</span>: pub1-<span class="number">2</span>, number: <span class="number">1</span></span><br><span class="line">main <span class="number">2</span>: pub1-<span class="number">2</span>, number: <span class="number">2</span></span><br><span class="line">main <span class="number">2</span>: pub1-<span class="number">2</span>, number: <span class="number">3</span></span><br></pre></td></tr></table></figure>
<h3 id="subscribeOn">subscribeOn</h3>
<p>subscribeOn은 호출된 곳의 앞쪽 publisher 체인과 뒷쪽의 subscriber 체인을 한꺼번에 별도의 스레드로 분리한다.<br>
느린 publisher 와 빠른 subscriber 의 조합에서 쓰기 적합하다고 하는데… 무슨 말인지 잘 모르겠다. 외부서비스에서 데이터를 읽어올때 쓰기 좋다고 한다.</p>
<p>위 예시처럼 subscribeOn을 동일한 체인에서 중첩해서 사용할 경우<br>
첫번째 subscribeOn 앞뒤 체인을 묶어서 sub2 스케줄러에서 담당하고<br>
두번째 subscribeOn 앞뒤 체인을 묶어서 sub1 스케줄러가 담당해야 하지만 이미 sub2에서 담당해서 그대로 sub2로 돌게 된다.</p>
<h3 id="publishOn">publishOn</h3>
<p>publishOn은 호출된 곳의 앞쪽 publisher 체인은 그대로 두고 뒷쪽 subscriber 체인만 별도의 스레드로 분리한다.<br>
빠른 publisher와 느린 subscriber 일때 쓰기 좋다고 하고 외부서비스로 데이터를 쓰는 작업할 때 좋닫고 한다.<br>
위 예시에서 subscribeOn으로 sub2 스레드에서 돌다가 publishOn을 만나면서 pub1 스케줄러에 작업을 할당하고 나머지 연산을 진행한다.</p>
<p>🔗 출처<br>
<a target="_blank" rel="external nofollow noopener noreferrer" href="https://wiki.terzeron.com/Programming/Java/Reactor_Flux%EC%9D%98_publishOn_subscribeOn%EC%9D%84_%EC%9D%B4%EC%9A%A9%ED%95%9C_%EC%8A%A4%EC%BC%80%EC%A5%B4%EB%A7%81">Reactor Flux의 publishOn subscribeOn을 이용한 스케쥴링</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time datetime="2021-12-03T13:20:10.000Z" title="2021. 12. 3. 오후 10:20:10">2021-12-03</time>&nbsp;게시 됨</span><span class="level-item"><time datetime="2023-05-14T14:50:58.310Z" title="2023. 5. 14. 오후 11:50:58">2023-05-14</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/book/">book</a><span> / </span><a class="link-muted" href="/categories/book/%EC%8B%A4%EC%A0%84-%EC%8A%A4%ED%94%84%EB%A7%815%EB%A5%BC-%ED%99%9C%EC%9A%A9%ED%95%9C-%EB%A6%AC%EC%95%A1%ED%8B%B0%EB%B8%8C-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/">실전! 스프링5를 활용한 리액티브 프로그래밍</a></span><span class="level-item">7분안에 읽기 (약 1117 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/12/03/book/%EC%8B%A4%EC%A0%84-%EC%8A%A4%ED%94%84%EB%A7%815%EB%A5%BC-%ED%99%9C%EC%9A%A9%ED%95%9C-%EB%A6%AC%EC%95%A1%ED%8B%B0%EB%B8%8C-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/4-2/">4-2. 리액터 프로젝트 심화학습</a></h1><div class="content"><p align="center">
  <img src="/img/book/스프링5를-활용한-리액티브-프로그래밍/book-cover.jpg" width="50%">
</p>
<h2 id="리액티브-스트림의-수명-주기">리액티브 스트림의 수명 주기</h2>
<h3 id="조립-assembling-단계">조립(assembling) 단계</h3>
<ul>
<li>처리 흐름에서 사용하는 연산자를 조합한 빌더 API처럼 보이지만 일반적인 빌더 패턴과 달리 리액터 API는 불변성(Immutability)을 제공한다.(적용된 각각의 연산자가 새로운 객체를 생성한다.)</li>
<li>스트림 구성을 조작하고 더나은 스트림 전달을 위한 다양한 기술을 적용할 수 있는 단계</li>
</ul>
<h3 id="구독-단계">구독 단계</h3>
<ul>
<li>특정 Publisher를 구독할 때 발생</li>
<li>조립 단계에서 일련의 Publisher 체인이 연결되었고 최상위 래퍼를 구독하면 해당 체인에 대한 구독 프로세스가 시작된다.</li>
<li>조립단계와 동일한 최적화를 수행할 수 있다.</li>
<li>리액터에서 멀티 스레딩을 지원하는 일부 연산자는 구독이 발생하는 작업자를 변경할 수 있다.</li>
</ul>
<h3 id="런타임-단계">런타임 단계</h3>
<ul>
<li>게시자와 구독자 간에 실제 신호가 교환되는 단계</li>
<li>교환하는 처음 두 신호는 <code>onSubscribe</code>, <code>request</code>
<ul>
<li>onSubscribe 메서드는 최상위 소스에서 호출</li>
<li>구독이 모든 구독자 체인을 통과하여 마지막 구독자가 구독 체인에 대한 정보를 수신하고 메시지 수신을 시작하려면 Subscription#request 메서드를 호출해 전송을 시작해야 한다.</li>
</ul>
</li>
<li>런타임 중에도 request를 줄이기 위한 최적화를 적용할 수 있다.</li>
</ul>
<h2 id="리액터에서-스레드-스케줄링-모델">리액터에서 스레드 스케줄링 모델</h2>
<p>멀티스레딩 실행을 위해 제공하는 연산자 사이의 차이점에 대해서 확인</p>
<p>다른 워커로 실행을 전환할 수 있는 네 가지 연산자</p>
<h3 id="publishOn-연산자">publishOn 연산자</h3>
<ul>
<li>런타임 실행의 일부를 지정된 워커로 이동</li>
<li>Scheduler 인터페이스를 사용하여 현재 스트림에 대한 특정 워커를 선택할 수 있다.</li>
<li>내부적으로 전용 워커가 메시지를 하나씩 처리할 수 있도록 새로운 원소를 제공하는 큐를 가지고 있다.</li>
<li>리액티브 스트림의 모든 원소는 하나씩(동시에는 아니지만) 처리되므로 항상 모든 이벤트에 순서를 엄격하게 정의할 수 있다.(이 속성을 **직렬성(serializability)**라고 한다.)</li>
<li>병렬 처리를 할 수 없다는 말처럼 들리지만 병렬 처리도 가능한데 예를 들어 처리 단계 사이에 비동기 영역을 추가해서 독립적으로 작업해 비동기 처리를 할 수 있다.</li>
</ul>
<h3 id="subscribeOn-연산자">subscribeOn 연산자</h3>
<ul>
<li>구독체인에서 워커의 작업 위치를 변경</li>
<li>보통 호출 시점에서 상위 스트림에 해당하는 부분의 스레드를 설정</li>
</ul>
<h3 id="parallel-연산자">parallel 연산자</h3>
<ul>
<li>하위 스트림에 대한 플로 분할과 분할된 플로 간 균형 조정 역할</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Flux.range(<span class="number">0</span>, <span class="number">10000</span>)</span><br><span class="line">  .parallel()</span><br><span class="line">  .runOn(Schedulers.parallel())</span><br><span class="line">  .map()</span><br><span class="line">  .filter()</span><br><span class="line">  .subscribe()</span><br></pre></td></tr></table></figure>
<ul>
<li>parallel연산자를 사용하면 <strong>ParallelFlux</strong>를 동작시킨다.
<ul>
<li>다수의 Flux를 추상화하여 Flux간에 데이터의 크기 균형을 이룬다.</li>
</ul>
</li>
</ul>
<h3 id="Scheduler">Scheduler</h3>
<ul>
<li><code>Scheduler.schedule</code> : Runnable 작업을 예약가능</li>
<li><code>Scheduler.createWorker</code> : 동일한 방법으로 Runnable 작업 예약이 가능한 Worker 인터페이스의 인스턴스를 제공</li>
<li>Scheduler인터페이스 / Workder인터페이스의 차이점 : 워커 풀 / Thread 또는 리소스를 추상화한 것</li>
<li>리액터에서 제공하는 스케줄러 인터페이스의 3가지 주요 구현체
<ul>
<li><code>SingleScheduler</code> : 모든 작업을 한 개의 전용 워커에 예약가능, 시간에 의존적</li>
<li><code>ParallelScheduler</code> : 고정된 크기의 작업자 풀에서 작동(CPU 코어 수로 기본크기 제한)</li>
<li><code>ElasticScheduler</code> : 동적으로 작업자를 만들고 스레드 풀을 캐시, 생성된 스레드 풀의 최대 개수는 제한되지 않음</li>
</ul>
</li>
</ul>
<h3 id="리액터-컨텍스트">리액터 컨텍스트</h3>
<ul>
<li>Context는 스트림을 따라 전달되는 인터페이스</li>
<li>런타임 단계에서 필요한 컨텍스트 정보에 엑세스할 수 있도록 하는 것</li>
<li>멀티스레드 환경의 비동기 처리방식에서 ThreadLocal가 가지는 한계를 해결할 수 있다.
<ul>
<li>변수에 데이터를 넣은 후 publishOn 등을 통해 다른 워커에서 작업 플로를 수행하면 데이터를 쌓은 스레드와 작업 스레드가 달라서 데이터에 접근할 수 없다.</li>
</ul>
</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time datetime="2021-12-03T12:15:32.000Z" title="2021. 12. 3. 오후 9:15:32">2021-12-03</time>&nbsp;게시 됨</span><span class="level-item"><time datetime="2023-05-14T14:50:58.310Z" title="2023. 5. 14. 오후 11:50:58">2023-05-14</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/book/">book</a><span> / </span><a class="link-muted" href="/categories/book/%EC%8B%A4%EC%A0%84-%EC%8A%A4%ED%94%84%EB%A7%815%EB%A5%BC-%ED%99%9C%EC%9A%A9%ED%95%9C-%EB%A6%AC%EC%95%A1%ED%8B%B0%EB%B8%8C-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/">실전! 스프링5를 활용한 리액티브 프로그래밍</a></span><span class="level-item">9분안에 읽기 (약 1391 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/12/03/book/%EC%8B%A4%EC%A0%84-%EC%8A%A4%ED%94%84%EB%A7%815%EB%A5%BC-%ED%99%9C%EC%9A%A9%ED%95%9C-%EB%A6%AC%EC%95%A1%ED%8B%B0%EB%B8%8C-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/4/">4. 리액터 프로젝트 - 리액티브 앱의 기초</a></h1><div class="content"><p align="center">
  <img src="/img/book/스프링5를-활용한-리액티브-프로그래밍/book-cover.jpg" width="50%">
</p>
<p>리액티브 스트림 스펙은 리액티브 라이브러리가 서로 호환할 수 있게 해주며 여러 중요한 개선 사항이 많았지만 API 및 규칙만 정의하고 일상적인 사용을 위한 라이브러리는 제공하지 않았다.</p>
<p>리액티브 프레임워크중에서 가장 유명한 라이브러리 중 하나인 <code>리액터 프로젝트(Project Reactor)</code>는 1.x 버전에서 리액터 패턴, 함수형 프로그래밍 및 리액티브 프로그래밍과 같은 메시지 처리에 대한 모범 사례를 통합하여 비동기 논블로킹 처리를 지원하도록 설계하였다.</p>
<p>이후 여러 부족한 부분들을 보완하면서 2.x를 거쳐 현재는 3.x 버전으로 릴리즈되어있다.</p>
<h2 id="리액터-프로젝트-필수-요소">리액터 프로젝트 필수 요소</h2>
<ul>
<li>비동기 파이프라인을 구축할 때 <strong>콜백 지옥</strong>과 <strong>깊게 중첩된 코드</strong>를 생략</li>
<li>코드 <strong>가독성</strong>을 높이고 리액터 라이브러리에 의해 정의된 워크플로에 **조합성(composability)**을 추가</li>
<li>리액터 API는 연산자를 연결해서 사용하는 것을 권장하며 이를 통해 복잡하고 재사용 가능한 실행 그래프(execution graph)를 작성할 수 있다.
<ul>
<li>그래프는 실행 흐름만 정의하며 구독자가 <strong>실제 구독을 했을 때만 데이터 플로가 기동</strong>된다.</li>
</ul>
</li>
<li>오류 발생 가능성이 있는 비동기 요청의 결과를 <strong>효율적으로 처리</strong>하여 유연하지만 <strong>복원력</strong> 있는 코드를 작성할 수 있다.</li>
</ul>
<p>배압은 리액티브 스트림 스펙의 핵심 속성으로 리액터 역시 동일하다.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(데이터 플로)--▶️          --▶️         --▶️</span><br><span class="line">  게시자           연산자        연산자        구독자</span><br><span class="line">            ◀️--          ◀️--         ◀️--(요청)</span><br></pre></td></tr></table></figure>
<p>배압 전파의 일반적인 모드를 모두 지원</p>
<ul>
<li>푸시 전용 : subscription.request(Long.MAX_VALUE)</li>
<li>풀 전용 : subscription.request(1)</li>
<li>풀-푸시(혼합형) : 구독자가 수요를 실시간으로 제어할 수 있고 게시자가 데이터 소비 속도에 적응할 수 있는 경우</li>
<li>풀-푸시 모델을 지원하지 않는 이전 API를 적용할 때는 예전 스타일의 배압 메커니즘을 제공한다.</li>
</ul>
<h2 id="Flux와-Mono">Flux와 Mono</h2>
<p>데이터를 기반으로 리액티브 스트림을 생성하는 팩토리 메서드를 제공</p>
<p>Mono는 Flux와 비슷하지만 하나의 요소를 대상으로 사용되는데 HTTP 요청이나 DB 쿼리와 같은 비동기 작업을 래핑하는데 매우 유용</p>
<p>Flux와 Mono는 구독 루틴을 단순화하는 <code>subscribe()</code> 메서드를 람다 기반으로 재정의한다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Flux.just(<span class="string">&quot;A&quot;</span>,<span class="string">&quot;B&quot;</span>,<span class="string">&quot;C&quot;</span>)</span><br><span class="line">  .subscribe(</span><br><span class="line">    data -&gt; log.info(<span class="string">&quot;onNext: &#123;&#125;&quot;</span>, data),</span><br><span class="line">    err -&gt; &#123; <span class="comment">/* ignored */</span> &#125;,</span><br><span class="line">    () -&gt; log.info(<span class="string">&quot;onComplete&quot;</span>)</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">onNext: A</span></span><br><span class="line"><span class="comment">onNext: B</span></span><br><span class="line"><span class="comment">onNext: C</span></span><br><span class="line"><span class="comment">onComplete</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>또한 subscription으로 구독을 직접 제어하거나 직접 Subscriber 인터페이스를 구현하여 스트림을 구독할 수 있다.</p>
<h2 id="연산자를-이용해-리액티브-시퀀스-변환하기">연산자를 이용해 리액티브 시퀀스 변환하기</h2>
<p>연산자의 종류가 너무 많아서 적절한 연산자를 선택하는 가이드를 포함한 아래 링크를 참조</p>
<p><a target="_blank" rel="external nofollow noopener noreferrer" href="https://projectreactor.io/docs/core/release/reference/#which-operator">Which operator do I need?</a></p>
<ul>
<li>원소 매핑 : map(1:1) …</li>
<li>필터링 : filter …</li>
<li>시퀀스 수집? 합치기? : collectList() …</li>
<li>원소 줄이기 : reduce, scan …</li>
<li>스트림 조합 : concat, merge, zip …</li>
<li>스트림 내의 원소 일괄 처리
<ul>
<li>buffer : List와 같은 컨테이너를 이용한 Buffering, <code>Flux&lt;List&lt;T&gt;&gt;</code></li>
<li>window : <code>Flux&lt;Flux&lt;T&gt;&gt;</code>와 같은 형태로 스트림을 스트림으로 Windowing</li>
<li>groupBy : <code>Flux&lt;GroupedFlux&lt;K, T&gt;&gt;</code> 유형의 스트림으로 Grouping</li>
</ul>
</li>
<li>flatmap : 논리적으로 map과 flatten의 2가지 작업으로 구성
<ul>
<li>map파트는 들어오는 각 원소를 리액티브 스트림(<code>T -&gt; Flux&lt;R&gt;</code>)으로 변환</li>
<li>flatten파트는 생성된 모든 리액티브 시퀀스를 R 타입의 원소를 통과시키는 새로운 리액티브 시퀀스로 병합</li>
</ul>
</li>
<li>샘플링 : sample 연산자를 사용하여 특정 기간 내 최근에 관찰된 값을 주기적으로 출력할 수 있다.</li>
<li>블로킹 구조로 전환
<ul>
<li>리액티브 애플리케이션에서 블로킹 처리를 해선 안되지만, 상위 API에서 필요로 하는 경우도 있음</li>
<li>blockFirst, blockLast, toIterable, toStream …</li>
<li><code>Mono#toFuture</code> 를 제외한 모든 메서드는 &quot;non-blocking only&quot;로 표시된 스케줄러에서 호출되면 UnsupportedOperatorException을 발생시킨다.</li>
</ul>
</li>
<li>시퀀스 엿보기
<ul>
<li><code>doOnNext(Consumer &lt;T&gt;)</code>, <code>doOnComplete()</code>, <code>doOnError(Throwable)</code>…</li>
<li>최종 시퀀스를 수정하지 않고 프로세스 파이프라인의 중간에 있는 각 원소나 특정 시그널을 처리해야 하는 경우</li>
</ul>
</li>
</ul>
<h2 id="Hot-스트림과-cold-스트림">Hot 스트림과 cold 스트림</h2>
<h3 id="1-콜드-퍼블리셔-cold-publisher">1. 콜드 퍼블리셔(cold publisher)</h3>
<ul>
<li>구독자가 나타날 때마다 시퀀스 데이터가 생성되는 방식</li>
<li>구독자 없이는 데이터 생성 X</li>
<li>대표적으로 HTTP 요청이 이런식으로 동작한다.</li>
</ul>
<h3 id="2-핫-퍼블리셔-hot-publisher">2. 핫 퍼블리셔(hot publisher)</h3>
<ul>
<li>데이터 생성 시 구독자의 존재 여부에 의존하지 않는 방식</li>
<li>첫 구독자가 없더라도 원소를 만들어 낼 수 있다.</li>
<li>이때 구독자가 나타나면 이전 생성값 말고 새로운 값만 보낼 수도 있다.</li>
<li>리액터 라이브러리에 포함된 대부분은 <code>Processor</code> 인터페이스를 상속한다.</li>
</ul>
<p>콜드 퍼블리셔를 리액티브 변환을 통해 핫 퍼블리셔로 전환할 수 있다.</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time datetime="2021-11-28T11:13:34.000Z" title="2021. 11. 28. 오후 8:13:34">2021-11-28</time>&nbsp;게시 됨</span><span class="level-item"><time datetime="2023-05-14T14:50:58.310Z" title="2023. 5. 14. 오후 11:50:58">2023-05-14</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/book/">book</a><span> / </span><a class="link-muted" href="/categories/book/%EC%8B%A4%EC%A0%84-%EC%8A%A4%ED%94%84%EB%A7%815%EB%A5%BC-%ED%99%9C%EC%9A%A9%ED%95%9C-%EB%A6%AC%EC%95%A1%ED%8B%B0%EB%B8%8C-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/">실전! 스프링5를 활용한 리액티브 프로그래밍</a></span><span class="level-item">10분안에 읽기 (약 1499 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/11/28/book/%EC%8B%A4%EC%A0%84-%EC%8A%A4%ED%94%84%EB%A7%815%EB%A5%BC-%ED%99%9C%EC%9A%A9%ED%95%9C-%EB%A6%AC%EC%95%A1%ED%8B%B0%EB%B8%8C-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/3/">3. 스트림의 새로운 표준 - 리액티브 스트림</a></h1><div class="content"><p align="center">
  <img src="/img/book/스프링5를-활용한-리액티브-프로그래밍/book-cover.jpg" width="50%">
</p>
<h2 id="API-불일치-문제">API 불일치 문제</h2>
<p>CompletableStage를 이용하는 자바 코어 라이브러리와 RxJava 같은 다양한 라이브러리가 있어서, 코드를 작성할 때 다양한 선택을 할 수 있지만 과도하게 많은 선택지는 시스템을 지나치게 복잡하게 만들 수 있다.</p>
<p>핵심적인 문제는 라이브러리 공급자가 일관된 API를 만들어낼 수 있는 표준화된 방법이 없다는 사실이다.</p>
<h2 id="풀-방식과-푸시-방식">풀 방식과 푸시 방식</h2>
<p>리액티브 초기 단계에서 모든 라이브러리의 데이터 흐름은 소스에서 구독자에게 푸시되는 방식이었다.</p>
<ul>
<li>
<p>풀 방식으로 요소를 하나씩 요청할 경우 비동기 논블로킹 방식을 사용하더라도 각 요소에 대한 요청을 처리 하면서 대기시간이 발생하여 전체 처리시간 중 많은 시간을 유휴 상태로 있게 된다.</p>
</li>
<li>
<p>푸시 방식을 도입하면서 요청하는 횟수를 최소화하여 전체 처리 시간을 최적화할 수 있었다.</p>
</li>
</ul>
<p><strong>하지만</strong> 푸시 모델만 사용하는 것은 기술적 한계가 있는데</p>
<ul>
<li>메시지 기반 통신의 본질은 <code>요청에 응답하는 것</code>인데</li>
<li>프로듀서가 컨슈머의 처리 능력을 무시하면 전반적인 시스템 안정성에 영향을 미칠 수 있기 때문이다.</li>
</ul>
<h2 id="흐름제어">흐름제어</h2>
<ul>
<li>
<h3 id="느린-프로듀서와-빠른-컨슈머">느린 프로듀서와 빠른 컨슈머</h3>
<p>순수한 푸시 모델은 동적으로 시스템의 처리량을 증가시키는 것이 불가능하다.</p>
</li>
<li>
<h3 id="빠른-프로듀서와-느린-컨슈머">빠른 프로듀서와 느린 컨슈머</h3>
<p>프로듀서는 컨슈머가 처리할 수 있는 것보다 더 많은 데이터를 전송할 수 있으며 이로 인해 부하를 받는 컴포넌트에 치명적인 오류가 발생할 수 있다.</p>
</li>
</ul>
<p>이를 해결하기 위한 직관적인 방법은 <strong>큐에 수집하는 것</strong>인데 3가지 유형으로 구분할 수 있다.</p>
<ol>
<li>무제한 큐: 메모리 한도에 도달하면 전체 시스템이 손상될 가능성이 있다.(복원력이 떨어짐)</li>
<li>크기가 제한된 드롭 큐: 메시지의 중요성이 낮을 때 사용되는 방법으로 큐가 가득 차면 메시지를 무시하는데 중요한건 데이터 세트가 변경된다는 점이다.</li>
<li>크기가 제한된 블로킹 큐: 가장 느린 컨슈머의 처리량에 의해 시스템의 전체 처리량이 제한된다. 시스템의 비동기 동작을 모두 무효화하여 절대 받아들일 수 없는 시나리오다.</li>
</ol>
<p>이런 시스템 부하에 적절하게 대응하는 방법으로 <code>배압 제어 메커니즘</code>이 있다.</p>
<h2 id="리액티브-스트림의-기본-스펙">리액티브 스트림의 기본 스펙</h2>
<p>리액티브 스트림 스펙에는 <code>Publisher</code>, <code>Subscriber</code>, <code>Subscription</code>, <code>Processor</code>의 네 가지 기본 인터페이스가 정의돼 있다.</p>
<ul>
<li>
<p>Publisher : Observable과 비교하면 Publisher와 Subscriber를 연결하기 위한 표준화된 진입점을 의미</p>
</li>
<li>
<p>Subscriber : Observer와 비슷한데 onSubscribe라는 추가 메서드를 제공하는데 Subscriber에게 구독이 성공했음을 알리는 API 메서드</p>
</li>
<li>
<p>Subscription : 원소 생성을 제어하기 위해 기본적인 사항을 제공</p>
<ul>
<li>
<p>cancel() : 스트림에서 구독을 취소하거나 발행을 완전히 취소 가능</p>
</li>
<li>
<p>request(long n) : 요청하는 Publisher가 보내줘야 하는 데이터 크기를 알려줄 수 있음 ▶️ Publisher에서 유입되는 원소의 개수가 처리할 수 있는 제한을 초과하지 않을 것을 확신할 수 있다.</p>
<p>리액티브 스트림은 순수 푸시 모델과는 달리 배압을 적절하게 제어할 수 있는 하이브리드 푸시-풀 모델을 제공한다.</p>
<ul>
<li>순수 푸시 모델을 사용하고 싶으면 최대 개수 요청 request(Long.MAX_VALUE)</li>
<li>순수 풀 모델을 사용하고 싶으면 onNext()가 호출될 때마다 요청</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Processor : Publisher와 Subscriber의 혼합 형태로 Publisher와 Subscriber 사이에 몇가지 처리 단계를 추가하도록 설계됐다.</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Processor</span>&lt;T, R&gt; <span class="keyword">extends</span> <span class="title class_">Subscriber</span>&lt;T&gt;, Publisher&lt;R&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="리액티브-스트림-기술-호환성-키트-TCK">리액티브 스트림 기술 호환성 키트(TCK)</h2>
<p>모든 동작을 검증하고 반응 라이브러리를 표준화하여 서로 호환하는지 확인하는 공통 도구로 모든 리액티브 스트림 코드를 방어하고 지정된 규칙에 따라 구현을 테스트 한다.</p>
<p><a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/reactive-streams/reactive-streams-jvm/tree/master/tck">TCK github : https://github.com/reactive-streams/reactive-streams-jvm/tree/master/tck</a></p>
<hr>
<h2 id="리액티브-스트림을-활용한-비동기-및-병렬">리액티브 스트림을 활용한 비동기 및 병렬</h2>
<ul>
<li>
<p>리액티브 스트림 API는 Publisher가 생성하고 Subscriber가 소비한 <strong>모든 신호는 처리 중에 논블로킹</strong>이어야 하며 방해받지 않아야 한다고 규칙에 명시되어 있다.</p>
</li>
<li>
<p>모든 프로세서나 코어를 효율적으로 사용하려면 <strong>병렬처리</strong>가 필요하고 이는 일반적으로 onNext 메서드를 병렬로 호출하는 것을 뜻하지만 on*** 메서드의 호출은 <strong>스레드 안전성을 보장하는 방식</strong>으로 신호를 보내야 하며 다중 스레드에서 수행되는 경우 <strong>외부적인 동기화를 사용</strong>해야 한다. <strong>즉, 스트림의 요소를 병렬 처리할 수 없다.</strong></p>
</li>
<li>
<p>자원을 효율적으로 활용하기 위해 스트림 처리 파이프의 각 단계에 메시지를 비동기적으로 전달하는 것이다.</p>
<ul>
<li>상황에 따라서 처리단계를 각각 별도의 스레드로 처리하고 각 스레드 사이에 큐와 같은 데이터 구조를 적용하여 메시지를 독립적으로 제공하고 사용하도록 할수 있다.</li>
</ul>
</li>
</ul>
</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous is-invisible is-hidden-mobile"><a href="/tags/spring/page/0/">이전</a></div><div class="pagination-next"><a href="/tags/spring/page/2/">다음</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link is-current" href="/tags/spring/">1</a></li><li><a class="pagination-link" href="/tags/spring/page/2/">2</a></li><li><a class="pagination-link" href="/tags/spring/page/3/">3</a></li></ul></nav></div><div class="column column-left is-3-tablet is-3-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/img/avatar.png" alt="Jaeyong Yoo"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Jaeyong Yoo</p><p class="is-size-6 is-block">Backend Developer</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Seoul, Korea</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">포스트</p><a href="/archives"><p class="title">39</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">카테고리</p><a href="/categories"><p class="title">17</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">태그</p><a href="/tags"><p class="title">20</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/yoo0926" target="_blank" rel="external nofollow noopener noreferrer">팔로우</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="external nofollow noopener noreferrer" title="Github" href="https://github.com/yoo0926"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="external nofollow noopener noreferrer" title="Mail" href="mailto:wodydasktp@gmail.com"><i class="far fa-envelope"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/rss2.xml"><i class="fas fa-rss"></i></a></div></div></div><!--!--><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">카테고리</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/algorithm/"><span class="level-start"><span class="level-item">algorithm</span></span><span class="level-end"><span class="level-item tag">3</span></span></a><ul><li><a class="level is-mobile" href="/categories/algorithm/programmers/"><span class="level-start"><span class="level-item">programmers</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/blog/"><span class="level-start"><span class="level-item">blog</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/book/"><span class="level-start"><span class="level-item">book</span></span><span class="level-end"><span class="level-item tag">21</span></span></a><ul><li><a class="level is-mobile" href="/categories/book/%EB%A7%8C%EB%93%A4%EB%A9%B4%EC%84%9C-%EB%B0%B0%EC%9A%B0%EB%8A%94-%ED%81%B4%EB%A6%B0-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98/"><span class="level-start"><span class="level-item">만들면서 배우는 클린 아키텍처</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li><li><a class="level is-mobile" href="/categories/book/%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8%EC%99%80-AWS%EB%A1%9C-%ED%98%BC%EC%9E%90-%EA%B5%AC%ED%98%84%ED%95%98%EB%8A%94-%EC%9B%B9%EC%84%9C%EB%B9%84%EC%8A%A4/"><span class="level-start"><span class="level-item">스프링부트와 AWS로 혼자 구현하는 웹서비스</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/book/%EC%8B%A4%EC%A0%84-%EC%8A%A4%ED%94%84%EB%A7%815%EB%A5%BC-%ED%99%9C%EC%9A%A9%ED%95%9C-%EB%A6%AC%EC%95%A1%ED%8B%B0%EB%B8%8C-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"><span class="level-start"><span class="level-item">실전! 스프링5를 활용한 리액티브 프로그래밍</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/docker/"><span class="level-start"><span class="level-item">docker</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/etc/"><span class="level-start"><span class="level-item">etc</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/functional/"><span class="level-start"><span class="level-item">functional</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/git/"><span class="level-start"><span class="level-item">git</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/interview/"><span class="level-start"><span class="level-item">interview</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/spring/"><span class="level-start"><span class="level-item">spring</span></span><span class="level-end"><span class="level-item tag">3</span></span></a><ul><li><a class="level is-mobile" href="/categories/spring/WebFlux/"><span class="level-start"><span class="level-item">WebFlux</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/sql/"><span class="level-start"><span class="level-item">sql</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul><li><a class="level is-mobile" href="/categories/sql/postgresql/"><span class="level-start"><span class="level-item">postgresql</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/web/"><span class="level-start"><span class="level-item">web</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">최근 글</h3><article class="media"><div class="media-content"><p class="date"><time datetime="2023-05-21T05:13:38.000Z">2023-05-21</time></p><p class="title"><a href="/2023/05/21/blog/hexo-upgrade/">Hexo 버전 업그레이드, 경고 지우기</a></p><p class="categories"><a href="/categories/blog/">blog</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time datetime="2023-04-02T14:13:58.000Z">2023-04-02</time></p><p class="title"><a href="/2023/04/02/book/%EB%A7%8C%EB%93%A4%EB%A9%B4%EC%84%9C%20%EB%B0%B0%EC%9A%B0%EB%8A%94%20%ED%81%B4%EB%A6%B0%20%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98/clean-11/">11. 의식적으로 지름길 사용하기</a></p><p class="categories"><a href="/categories/book/">book</a> / <a href="/categories/book/%EB%A7%8C%EB%93%A4%EB%A9%B4%EC%84%9C-%EB%B0%B0%EC%9A%B0%EB%8A%94-%ED%81%B4%EB%A6%B0-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98/">만들면서 배우는 클린 아키텍처</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time datetime="2023-04-02T12:45:03.000Z">2023-04-02</time></p><p class="title"><a href="/2023/04/02/book/%EB%A7%8C%EB%93%A4%EB%A9%B4%EC%84%9C%20%EB%B0%B0%EC%9A%B0%EB%8A%94%20%ED%81%B4%EB%A6%B0%20%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98/clean-10/">10. 아키텍처 경계 강제하기</a></p><p class="categories"><a href="/categories/book/">book</a> / <a href="/categories/book/%EB%A7%8C%EB%93%A4%EB%A9%B4%EC%84%9C-%EB%B0%B0%EC%9A%B0%EB%8A%94-%ED%81%B4%EB%A6%B0-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98/">만들면서 배우는 클린 아키텍처</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time datetime="2023-04-02T09:26:30.000Z">2023-04-02</time></p><p class="title"><a href="/2023/04/02/book/%EB%A7%8C%EB%93%A4%EB%A9%B4%EC%84%9C%20%EB%B0%B0%EC%9A%B0%EB%8A%94%20%ED%81%B4%EB%A6%B0%20%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98/clean-9/">9. 애플리케이션 조립하기</a></p><p class="categories"><a href="/categories/book/">book</a> / <a href="/categories/book/%EB%A7%8C%EB%93%A4%EB%A9%B4%EC%84%9C-%EB%B0%B0%EC%9A%B0%EB%8A%94-%ED%81%B4%EB%A6%B0-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98/">만들면서 배우는 클린 아키텍처</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time datetime="2023-04-02T08:16:29.000Z">2023-04-02</time></p><p class="title"><a href="/2023/04/02/book/%EB%A7%8C%EB%93%A4%EB%A9%B4%EC%84%9C%20%EB%B0%B0%EC%9A%B0%EB%8A%94%20%ED%81%B4%EB%A6%B0%20%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98/clean-8/">8. 경계 간 매핑하기</a></p><p class="categories"><a href="/categories/book/">book</a> / <a href="/categories/book/%EB%A7%8C%EB%93%A4%EB%A9%B4%EC%84%9C-%EB%B0%B0%EC%9A%B0%EB%8A%94-%ED%81%B4%EB%A6%B0-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98/">만들면서 배우는 클린 아키텍처</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">아카이브</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2023/05/"><span class="level-start"><span class="level-item">5월 2023</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/04/"><span class="level-start"><span class="level-item">4월 2023</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/03/"><span class="level-start"><span class="level-item">3월 2023</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/02/"><span class="level-start"><span class="level-item">2월 2023</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/01/"><span class="level-start"><span class="level-item">1월 2023</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/01/"><span class="level-start"><span class="level-item">1월 2022</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/12/"><span class="level-start"><span class="level-item">12월 2021</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/11/"><span class="level-start"><span class="level-item">11월 2021</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/09/"><span class="level-start"><span class="level-item">9월 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/08/"><span class="level-start"><span class="level-item">8월 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/06/"><span class="level-start"><span class="level-item">6월 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/05/"><span class="level-start"><span class="level-item">5월 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/04/"><span class="level-start"><span class="level-item">4월 2021</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/12/"><span class="level-start"><span class="level-item">12월 2020</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/11/"><span class="level-start"><span class="level-item">11월 2020</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">태그</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/JWT/"><span class="tag">JWT</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/algorithm/"><span class="tag">algorithm</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/blog/"><span class="tag">blog</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/book/"><span class="tag">book</span><span class="tag">21</span></a></div><div class="control"><a class="tags has-addons" href="/tags/docker/"><span class="tag">docker</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/functional/"><span class="tag">functional</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/git/"><span class="tag">git</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/googleTagManager/"><span class="tag">googleTagManager</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/hexo/"><span class="tag">hexo</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/interview/"><span class="tag">interview</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/java/"><span class="tag">java</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/kakao/"><span class="tag">kakao</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/kakaotalk/"><span class="tag">kakaotalk</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/open-graph/"><span class="tag">open graph</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/postgresql/"><span class="tag">postgresql</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/programmers/"><span class="tag">programmers</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/spring/"><span class="tag">spring</span><span class="tag">13</span></a></div><div class="control"><a class="tags has-addons" href="/tags/sql/"><span class="tag">sql</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/web/"><span class="tag">web</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%EC%9B%94%EA%B0%84%EC%BD%94%EB%93%9C%EC%B1%8C%EB%A6%B0%EC%A7%80/"><span class="tag">월간코드챌린지</span><span class="tag">1</span></a></div></div></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">업데이트 소식 받기</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="구독"></div></div></form></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo-header.png" alt="하루하루 끄적끄적" height="28"></a><p class="is-size-7"><span>&copy; 2023 Jaeyong Yoo</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="external nofollow noopener noreferrer">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="external nofollow noopener noreferrer">Icarus</a><br><span id="busuanzi_container_site_uv"><span id="busuanzi_value_site_uv">0</span>명의 사용자가 방문 함</span></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="external nofollow noopener noreferrer" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="external nofollow noopener noreferrer" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="external nofollow noopener noreferrer" title="Download on GitHub" href="https://github.com/yoo0926/yoo0926.github.io"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("ko");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="맨 위로" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "이 웹 사이트는 귀하의 경험을 향상시키기 위해 Cookie를 사용합니다.",
          dismiss: "무시",
          allow: "허용",
          deny: "거부",
          link: "더 알아보기",
          policy: "Cookie 정책",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="입력 하세요..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"입력 하세요...","untitled":"(제목 없음)","posts":"포스트","pages":"페이지","categories":"카테고리","tags":"태그"});
        });</script></body></html>