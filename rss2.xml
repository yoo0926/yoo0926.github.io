<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>하루하루 끄적끄적</title>
    <link>https://yoo0926.github.io/</link>
    
    <atom:link href="https://yoo0926.github.io/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>티끌모아 태산이라 티끌부터 모아본다.</description>
    <pubDate>Fri, 16 Jun 2023 12:02:42 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>Spring Event와 ApplicationEventPublisher</title>
      <link>https://yoo0926.github.io/2023/06/16/spring/spring-3/</link>
      <guid>https://yoo0926.github.io/2023/06/16/spring/spring-3/</guid>
      <pubDate>Fri, 16 Jun 2023 11:55:27 GMT</pubDate>
      
        
        
      <description>&lt;p style=&quot;text-align:center&quot;&gt;
  &lt;img src=&quot;/img/spring/spring-3-1.png&quot; alt=&quot;spring event&quot;&gt;
&lt;/p&gt;
&lt;h2 id=&quot;Spring에서-Event&quot;&gt;Spring에서 Event&lt;/h2&gt;
&lt;</description>
        
      
      
      
      <content:encoded><![CDATA[<p style="text-align:center">  <img src="/img/spring/spring-3-1.png" alt="spring event"></p><h2 id="Spring에서-Event">Spring에서 Event</h2><p>Spring은 일반적으로 DI를 통해 메서드를 호출하여 데이터를 전달한다.</p><p>규모가 작을 때는 큰 문제가 없지만 도메인이 점점 복잡히질 경우 여러 도메인 사이에 강한 의존성 결합으로 시스템이 복잡해지는 문제가 발생할 수 있다.</p><p>Spring은 Event를 통해 Bean과 Bean 사이의 데이터를 전달할 수 있는데 ApplicationContext에 이벤트를 넘겨주면 Listener에서 받아서 처리한다.</p><p>이벤트를 발생시키는 publisher와 받아서 처리하는 Listener, 전달할 데이터를 가지고 있는 event클래스로 구성된다.</p><h2 id="ApplicationEventPublisher">ApplicationEventPublisher</h2><p>Spring의 ApplicationContext가 상속하는 인터페이스 중 하나로 옵저버 패턴의 구현체이다.</p><p>Publisher와 Listener를 Spring의 Bean으로 등록하고 publishEvent()가 실행되면 등록된 listener에 Event를 던진다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestEvent</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String eventId;</span><br><span class="line">    <span class="keyword">private</span> String type;</span><br><span class="line">    <span class="keyword">private</span> String data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> TestEvent <span class="title function_">toCompleteEvent</span><span class="params">(String data)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> TestEvent.builder()</span><br><span class="line">                .eventId(UUID.randomUUID().toString())</span><br><span class="line">                .type(<span class="string">&quot;completed&quot;</span>)</span><br><span class="line">                .data(data)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> TestEvent <span class="title function_">toErrorEvent</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> TestEvent.builder()</span><br><span class="line">                .eventId(UUID.randomUUID().toString())</span><br><span class="line">                .type(<span class="string">&quot;error&quot;</span>)</span><br><span class="line">                .data(<span class="string">&quot;data is Null&quot;</span>)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Spring 4.2 부터는 ApplicationEvent를 상속받지 않아도 된다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EventTestService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ApplicationEventPublisher applicationEventPublisher;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;String&gt; <span class="title function_">publishTest</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Mono.fromCallable(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span>(message != <span class="literal">null</span>)&#123;</span><br><span class="line">                applicationEventPublisher.publishEvent(TestEvent.toCompleteEvent(message));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                applicationEventPublisher.publishEvent(TestEvent.toErrorEvent());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;result: &quot;</span> + message;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ApplicationContext를 주입받아도 되지만 명시적으로 ApplicationEventPublisher를 주입받아서 사용한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestEventListener</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@EventListener</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onTestEventHandle</span><span class="params">(TestEvent event)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;event Id: &quot;</span> + event.getEventId() + <span class="string">&quot;, type: &quot;</span> + event.getType() + <span class="string">&quot;, Message: &quot;</span> + event.getData());</span><br><span class="line">        log.info(<span class="string">&quot;Handling context started event.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Spring Bean에 등록된 EventListener에서 이벤트를 받아서 처리한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2023</span>-<span class="number">01</span>-<span class="number">19</span> <span class="number">15</span>:<span class="number">26</span>:<span class="number">28.072</span>  INFO <span class="number">20172</span> --- [ctor-http-nio-<span class="number">3</span>] c.e.s.listener.TestEventListener         : event Id: 8f9d4534-7ada-404a-9b1b-71f2958a749b, type: completed, Message: testSample!</span><br><span class="line"><span class="number">2023</span>-<span class="number">01</span>-<span class="number">19</span> <span class="number">15</span>:<span class="number">26</span>:<span class="number">28.072</span>  INFO <span class="number">20172</span> --- [ctor-http-nio-<span class="number">3</span>] c.e.s.listener.TestEventListener         : Handling context started event.</span><br></pre></td></tr></table></figure><p>잘 돌아간다.</p>]]></content:encoded>
      
      
      
      
      <comments>https://yoo0926.github.io/2023/06/16/spring/spring-3/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>ThreadLocal과 Netty</title>
      <link>https://yoo0926.github.io/2023/06/15/spring/spring-2/</link>
      <guid>https://yoo0926.github.io/2023/06/15/spring/spring-2/</guid>
      <pubDate>Thu, 15 Jun 2023 11:23:11 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;Spring에서 Bean들은 Spring Container에 의해서 싱글톤으로 관리되는데 이는 애플리케이션에 한개의 인스턴스만 존재하는데 여러 Thread가 동시에 접근할 경우 동시성 이슈가 발생할 수 있는데 이를 해결하기 위해 Java에서는 T</description>
        
      
      
      
      <content:encoded><![CDATA[<p>Spring에서 Bean들은 Spring Container에 의해서 싱글톤으로 관리되는데 이는 애플리케이션에 한개의 인스턴스만 존재하는데 여러 Thread가 동시에 접근할 경우 동시성 이슈가 발생할 수 있는데 이를 해결하기 위해 Java에서는 ThreadLocal 객체를 활용할 수 있다.</p><p>ThreadLocal은 Thread만 접근가능한 저장소로 여러 Thread가 접근할 경우 각각의 Thread를 식별해서 저장소를 구분한다. 따라서 같은 인스턴스의 ThreadLocal 필드에 여러 Thread가 접근하더라도 상관이 없다.</p><p>get(), set(), remove() 같은 메서드를 통해 조회, 저장, 저장소를 초기화한다.</p><p>톰캣과 같은 WAS에선 Thread Pool을 만들고 Request가 들어오면 각 Thread가 해당 요청을 담당하여 프로세스를 처리한다.</p><p>Spring Boot가 실행되면 내부적으로 ThreadPoolExecutor 구현체를 생성해서 내장 톰캣이 사용할 Thread Pool을 생성하는 구조<br>Thread Pool 을 사용하는 환경에선 Thread Pool을 통해 Thread가 재사용될 수 있으므로 사용이 끝나면 명시적으로 초기화를 해줘야 한다.<br>ThreadPoolExecutor를 확장해서 beforeExecute()와 afterExecute() 메서드에서 이러한 문제들을 해결할 수 있다.<br>기존 서블릿 기반의 Spring Boot는 Tomcat을 기본 Embeded WAS로 사용하는데 WebFlux의 경우 Netty를 기본으로 사용한다.</p><p>Tomcat은 요청 당 하나의 Thread가 동작하지만 Netty는 1개의 이벤트를 받는 Thread와 다수의 Worker Thread로 동작하게 된다.<br>Netty는 channel에서 발생하는 이벤트를 EventLoop가 처리하는 구조로 동작하는데 EventLoop는 이벤트를 실행하기 위한 무한루프 Thread라고 볼수 있다.</p><p>Netty에 대한 자세한 내용은 다음에 더 찾아보자.</p><p>아래는 webFlux에서 ThreadLocal에 저장하던 데이터를 어떻게 보관하는지 찾아본 글 내용이 흥미로워서 나중에 보려고 추가함<br><a href="https://sightstudio.tistory.com/15">https://sightstudio.tistory.com/15</a></p>]]></content:encoded>
      
      
      <category domain="https://yoo0926.github.io/categories/spring/">spring</category>
      
      
      <category domain="https://yoo0926.github.io/tags/spring/">spring</category>
      
      
      <comments>https://yoo0926.github.io/2023/06/15/spring/spring-2/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Java Enum을 활용해보기</title>
      <link>https://yoo0926.github.io/2023/06/14/java/java-01/</link>
      <guid>https://yoo0926.github.io/2023/06/14/java/java-01/</guid>
      <pubDate>Wed, 14 Jun 2023 10:37:34 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;제휴사 연동서비스를 개발하던 중 퇴사자분이 만들어놓은 코드를 만났는데 대략 비슷하게 구현을 해보면 이렇다.&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span c</description>
        
      
      
      
      <content:encoded><![CDATA[<p>제휴사 연동서비스를 개발하던 중 퇴사자분이 만들어놓은 코드를 만났는데 대략 비슷하게 구현을 해보면 이렇다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getStatusType</span><span class="params">(String type, String code)</span> &#123;</span><br><span class="line">  <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="keyword">switch</span>(type)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;Booking&quot;</span>:</span><br><span class="line">      <span class="keyword">if</span>(<span class="string">&quot;BK04&quot;</span>.equals(code))&#123;</span><br><span class="line">        result = <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(List.of(<span class="string">&quot;BK03&quot;</span>,<span class="string">&quot;BK05&quot;</span>).contains(code))&#123;</span><br><span class="line">        result = <span class="string">&quot;CANCEL&quot;</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(List.of(<span class="string">&quot;BK01&quot;</span>,<span class="string">&quot;BK02&quot;</span>).contains(code))&#123;</span><br><span class="line">        result = <span class="string">&quot;HOLD&quot;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;Payment&quot;</span>:</span><br><span class="line">      <span class="keyword">if</span>(<span class="string">&quot;BK04&quot;</span>.equals(code))&#123;</span><br><span class="line">        result = <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(List.of(<span class="string">&quot;BK03&quot;</span>,<span class="string">&quot;BK05&quot;</span>,<span class="string">&quot;BK06&quot;</span>,<span class="string">&quot;BK07&quot;</span>).contains(code))&#123;</span><br><span class="line">        result = <span class="string">&quot;CANCEL&quot;</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(List.of(<span class="string">&quot;BK01&quot;</span>,<span class="string">&quot;BK02&quot;</span>,<span class="string">&quot;BK09&quot;</span>).contains(code))&#123;</span><br><span class="line">        result = <span class="string">&quot;HOLD&quot;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">bookingType</span> <span class="operator">=</span> getStatusType(<span class="string">&quot;Booking&quot;</span>, vo.getCode());</span><br><span class="line"><span class="type">String</span> <span class="variable">paymentType</span> <span class="operator">=</span> getStatusType(<span class="string">&quot;Payment&quot;</span>, vo.getCode());</span><br><span class="line">String otherType ...</span><br></pre></td></tr></table></figure><p>이 코드는 Booking과 Payment 같은 타입과 기존 아이템의 상태코드 값을 받아서 매칭되는 상태값을 반환하는 메서드였다. 코드는 처음에 보면 별 생각이 없었지만, 타입 유형이 늘어나고 코드가 많아지면 switch문이 복잡해지고 유지보수가 어려워지는 문제가 생길 수 있다고 생각이 들었다.</p><p>검색을 하던 도중 시간이 좀 지난 글이지만 <a href="https://techblog.woowahan.com/2527/">우아한형제들 기술블로그 - Java Enum 활용기</a> 라는 글에서 <strong><strong>3. 데이터 그룹관리</strong></strong> 세션의 내용을 적용할 수 있겠다고 판단되었다. Enum을 활용하여 데이터를 그룹화 하고 각 타입은 본인이 수행해야할 기능만 책임지도록 하는게 중요해 보였다.</p><p>개선된 Enum 클래스는 대략 아래와 같다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">BookingType</span>&#123;</span><br><span class="line">  OK(<span class="string">&quot;완료&quot;</span>, List.of(ItemStatus.OK),</span><br><span class="line">  CANCEL(<span class="string">&quot;취소&quot;</span>, List.of(ItemStatus.CANCEL, ItemStatus.REFUND),</span><br><span class="line">  HOLD(<span class="string">&quot;대기&quot;</span>, List.of(ItemStatus.PENDING, ItemStatus.UNAVAILABLE),</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  EMPTY(<span class="string">&quot;없음&quot;</span>, Collections.emptyList());</span><br><span class="line">  <span class="keyword">private</span> String title;</span><br><span class="line">  <span class="keyword">private</span> List&lt;ItemStatus&gt; codeList;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> BookingType <span class="title function_">findByItemStatus</span><span class="params">(ItemStatus code)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Arrays.stream(NaverBookingType.values())</span><br><span class="line">              .filter(itemCode -&gt; itemCode.hasStatusCode(code))</span><br><span class="line">              .findAny()</span><br><span class="line">              .orElse(EMPTY);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasStatusCode</span><span class="params">(ItemStatus code)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> typeList.stream()</span><br><span class="line">             .anyMatch(statusCode == code);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ItemStatus</span> <span class="variable">code</span> <span class="operator">=</span> ItemStatus.findByCode(vo.getCode());</span><br><span class="line"><span class="type">BookingType</span> <span class="variable">bookingType</span> <span class="operator">=</span> BookingType.findByItemStatus(code);</span><br><span class="line"><span class="type">PaymentType</span> <span class="variable">paymentType</span> <span class="operator">=</span> PaymentType.findByItemStatus(code);</span><br><span class="line"><span class="type">OtherType</span> <span class="variable">otherType</span> <span class="operator">=</span> ...</span><br></pre></td></tr></table></figure><p>이제는 직관적으로 각 유형에 대한 상태코드를 볼 수 있다. BookingType의 OK가 가진 상태코드를 직관적으로 볼수 있어서 가독성이 좋아졌다.</p><p>데이터들의 그룹화를 통해서 상태매핑 관계를 파악하기 더 수월해지고 입출력도 Enum을 사용해서 별도의 검증없이도 예측이 가능하고 실수로 다른 문자열이 들어올 일이 없어서 타입 안정성이 보장된다.</p><p>추후 기능 확장 시에도 Enum 클래스만 수정하면 되서 side-effect가 적을 것으로 기대된다.</p>]]></content:encoded>
      
      
      <category domain="https://yoo0926.github.io/categories/java/">java</category>
      
      
      <category domain="https://yoo0926.github.io/tags/java/">java</category>
      
      
      <comments>https://yoo0926.github.io/2023/06/14/java/java-01/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[WebFlux] map과 flatMap에 대해서</title>
      <link>https://yoo0926.github.io/2023/06/13/spring/WebFlux/spring-webflux-4/</link>
      <guid>https://yoo0926.github.io/2023/06/13/spring/WebFlux/spring-webflux-4/</guid>
      <pubDate>Tue, 13 Jun 2023 11:57:35 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;spring WebFlux를 사용하다보면 체인 연산자로 FlatMap을 사용해야할지, Map을 사용해야할지 헷갈리는 경우가 있어서 정리해봤다.&lt;/p&gt;
&lt;h3 id=&quot;map-함수&quot;&gt;&lt;strong&gt;map 함수&lt;/strong&gt;&lt;/h3&gt;
&lt;blockqu</description>
        
      
      
      
      <content:encoded><![CDATA[<p>spring WebFlux를 사용하다보면 체인 연산자로 FlatMap을 사용해야할지, Map을 사용해야할지 헷갈리는 경우가 있어서 정리해봤다.</p><h3 id="map-함수"><strong>map 함수</strong></h3><blockquote><p>public final <V>Flux<V> map(Function&lt;? superT,? extends V&gt; mapper)</p></blockquote><ul><li>Transform the items emitted by this <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html">Flux</a> by applying a synchronous function to each item.</li></ul><p style="text-align:center">  <img src="/img/spring/webflux-04/01.png" alt="flux.map"></p><p>map 함수는 데이터 스트림의 각 요소를 변환하는데 사용되는 함수로 각 요소를 <code>동기적으로 처리</code>하며, 각 요소를 변환하여 새로운 데이터 스트림을 반환한다.</p><p>간단한 샘플코드를 보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">sampleMapTest</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">// Arrange</span></span><br><span class="line">Function&lt;String, String&gt; mapper = (str) -&gt; str.toUpperCase();</span><br><span class="line">Flux&lt;String&gt; testFlux = Flux.just(<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;carrot&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Act</span></span><br><span class="line">Flux&lt;String&gt; resultFlux = testFlux.map(mapper);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Assert</span></span><br><span class="line">StepVerifier.create(resultFlux)</span><br><span class="line">        .expectNext(<span class="string">&quot;APPLE&quot;</span>, <span class="string">&quot;BANANA&quot;</span>, <span class="string">&quot;CARROT&quot;</span>)</span><br><span class="line">        .expectComplete()</span><br><span class="line">        .verify();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Function mapper는 스트림을 구독할 때 실행되며 각 요소의 순서를 유지하며 입력값을 변환하여 새로운 값으로 출력하게 된다.</p><h3 id="flatMap-함수"><strong>flatMap 함수</strong></h3><blockquote><p>public final <V>Flux<V> flatMap(Function&lt;? superT,? extendsPublisher&lt;? extends V&gt;&gt; mapper, int concurrency)</p></blockquote><ul><li>Transform the elements emitted by this <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html">Flux</a> asynchronously into Publishers, then flatten these inner publishers into a single <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html">Flux</a> through merging, which allow them to interleave.</li></ul><p style="text-align:center">  <img src="/img/spring/webflux-04/02.png" alt="flux.flatMap"></p><p>flatMap 함수는 데이터 스트림의 각 요소별로 publisher를 생성하여 여러개의 하위 스트림이 생성되고 subscribe를 통해 단일 스트림으로 묶은 Publisher로 반환한다.</p><p>이러한 Publisher를 비동기적으로 처리하여 순서를 보장하지 않기 때문에 순서를 보장하고 싶으면 flatMapSequential 이나 concatMap 등을 사용할 수 있다.</p><p>샘플코드를 보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">sampleFlatMapTest</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">// Arrange</span></span><br><span class="line">  Function&lt;String, Publisher&lt;String&gt;&gt; mapper = (str) -&gt; Flux.just(str.toUpperCase().split(<span class="string">&quot;&quot;</span>)).subscribeOn(Schedulers.boundedElastic());</span><br><span class="line">  Flux&lt;String&gt; testFlux = Flux.just(<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;carrot&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Act</span></span><br><span class="line">  Flux&lt;String&gt; resultFlux = testFlux.flatMap(mapper);</span><br><span class="line"></span><br><span class="line">List&lt;String&gt; output = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">  resultFlux.subscribe(output::add);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Assert</span></span><br><span class="line">  assertThat(output).containsExactlyInAnyOrder(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;P&quot;</span>, <span class="string">&quot;P&quot;</span>, <span class="string">&quot;L&quot;</span>, <span class="string">&quot;E&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;A&quot;</span>, <span class="string">&quot;N&quot;</span>, <span class="string">&quot;A&quot;</span>, <span class="string">&quot;N&quot;</span>, <span class="string">&quot;A&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;A&quot;</span>, <span class="string">&quot;R&quot;</span>, <span class="string">&quot;R&quot;</span>, <span class="string">&quot;O&quot;</span>, <span class="string">&quot;T&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mapper에서 Publisher로 반환되는데 별도의 스레드를 할당하고 flatMap에서 비동기로 동작하게 되면서 순서를 보장하지 않는 flatMap의 응답값은 apple, banana, carrot의 글자가 섞이게 된다.</p><h2 id="사용-시-고려사항">사용 시 고려사항</h2><p>map은 각 요소가 1:1로 매핑되서 동기적으로 처리된다.</p><p>flatMap은 각 요소에 대해서 1:다 매핑이 되서 단일 스트림으로 병합되고 publisher의 동작에 따라서 동기적, 혹은 비동기적으로 동작할 수 있다.</p><p>단순히 DTO 객체변환이라든지, 단일요소에 대한 간단한 계산같은건 map을 사용하면 좋고 각 요소의 처리 시간이 다를 수 있는 작업이나 외부 서비스, DB 호출 등의 작업을 할때는 비동기 동작이 가능한 flatMap을 사용하는게 좋다.</p><p>map은 단일 데이터 스트림의 각 요소를 독립적으로 처리하기 때문에 요소의 크기에 따라 성능차이가 크진 않지만 flatMap은 데이터 스트림을 개별적으로 처리 후 병합하기 위해 데이터 스트림의 크기나 작업량에 따라서 성능적으로 영향이 map에 비해서 상대적으로 클 수 있다.</p>]]></content:encoded>
      
      
      <category domain="https://yoo0926.github.io/categories/spring/">spring</category>
      
      <category domain="https://yoo0926.github.io/categories/spring/WebFlux/">WebFlux</category>
      
      
      <category domain="https://yoo0926.github.io/tags/spring/">spring</category>
      
      
      <comments>https://yoo0926.github.io/2023/06/13/spring/WebFlux/spring-webflux-4/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Hexo 버전 업그레이드, 경고 지우기</title>
      <link>https://yoo0926.github.io/2023/05/21/blog/hexo-upgrade/</link>
      <guid>https://yoo0926.github.io/2023/05/21/blog/hexo-upgrade/</guid>
      <pubDate>Sun, 21 May 2023 05:13:38 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;버전-업그레이드&quot;&gt;버전 업그레이드&lt;/h2&gt;
&lt;p&gt;오랜만에 블로그를 정비하다가 hexo 버전을 업그레이드 하고 싶었다.&lt;br&gt;
node가 그렇게 익숙하진 않아서 구글링으로 찾아보니 그냥 원하는 버전을 npm으로 설치하면 된다고 한다.&lt;br</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="버전-업그레이드">버전 업그레이드</h2><p>오랜만에 블로그를 정비하다가 hexo 버전을 업그레이드 하고 싶었다.<br>node가 그렇게 익숙하진 않아서 구글링으로 찾아보니 그냥 원하는 버전을 npm으로 설치하면 된다고 한다.<br><a href="https://github.com/hexojs/hexo/issues/4572">How can I upgrade hexo? #4572</a></p><p>7.0.0버전이 최신이긴 한데 이슈 생기면 대응하기 귀찮으니까 그냥 바로 아래의 6.3.0 으로 업그레이드 후 실행했다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">npm i hexo@6.3.0</span><br><span class="line">hexo s</span><br><span class="line"></span><br><span class="line">WARN  YAMLException: please see https://github.com/hexojs/hexo/issues/4917</span><br><span class="line">FATAL </span><br><span class="line">TypeError: Cannot <span class="built_in">read</span> property <span class="string">&#x27;length&#x27;</span> of undefined</span><br><span class="line">    at composeNode (D:\workspace\blog\node_modules\hexo\node_modules\js-yaml\lib\loader.js:1492:60)     </span><br><span class="line">    at composeNode (D:\workspace\blog\node_modules\hexo\node_modules\js-yaml\lib\loader.js:1441:12)</span><br><span class="line">    at readDocument (D:\workspace\blog\node_modules\hexo\node_modules\js-yaml\lib\loader.js:1625:3)</span><br><span class="line">    at loadDocuments (D:\workspace\blog\node_modules\hexo\node_modules\js-yaml\lib\loader.js:1688:5)</span><br><span class="line">    at Object.load (D:\workspace\blog\node_modules\hexo\node_modules\js-yaml\lib\loader.js:1714:19)</span><br><span class="line">    at Hexo.yamlHelper (D:\workspace\blog\node_modules\hexo\lib\plugins\renderer\yaml.js:20:15)</span><br><span class="line">    at Hexo.tryCatcher (D:\workspace\blog\node_modules\bluebird\js\release\util.js:16:23)</span><br><span class="line">    at Hexo.&lt;anonymous&gt; (D:\workspace\blog\node_modules\bluebird\js\release\method.js:15:34)</span><br><span class="line">    at D:\workspace\blog\node_modules\hexo\lib\hexo\render.js:81:22</span><br><span class="line">    at tryCatcher (D:\workspace\blog\node_modules\bluebird\js\release\util.js:16:23)</span><br><span class="line">    at Promise._settlePromiseFromHandler (D:\workspace\blog\node_modules\bluebird\js\release\promise.js:547:31)</span><br><span class="line">    at Promise._settlePromise (D:\workspace\blog\node_modules\bluebird\js\release\promise.js:604:18)</span><br><span class="line">    at Promise._settlePromise0 (D:\workspace\blog\node_modules\bluebird\js\release\promise.js:649:10)</span><br><span class="line">    at Promise._settlePromises (D:\workspace\blog\node_modules\bluebird\js\release\promise.js:729:18)</span><br><span class="line">    at _drainQueueStep (D:\workspace\blog\node_modules\bluebird\js\release\async.js:93:12)</span><br><span class="line">    at _drainQueue (D:\workspace\blog\node_modules\bluebird\js\release\async.js:86:9)</span><br><span class="line">    at Async._drainQueues (D:\workspace\blog\node_modules\bluebird\js\release\async.js:102:5)</span><br><span class="line">    at Immediate.Async.drainQueues [as _onImmediate] (D:\workspace\blog\node_modules\bluebird\js\release\async.js:15:14)</span><br><span class="line">    at processImmediate (internal/timers.js:464:21)</span><br></pre></td></tr></table></figure><p>??? 뭐야 갑자기 왜…</p><p>당황했지만 일단 에러 로그에서 들어가보라고 나온 github issue 를 들어가보니 비슷한 오류에 대해서 이미 많은 토론이 진행되어 있었다.</p><p>6.1.0 버전으로 올렸을때 이런 이슈가 발생했고(2,3 도 비슷한듯) 해결책은 크게 두가지 였는데</p><ol><li>6.0.0 으로 다운그레이드</li><li>js-yaml 을 4.1.0 으로 업그레이드</li></ol><p>이와 별개로 현재 사용중인 icarus 테마도 지원하는 버전이 있을거라고 생각해서 들어가보니 5.0.1 버전에서 hexo 6에 대한 언급이 있어서 이참에 최신버전으로 올렸다.</p><p style="text-align:center">  <img src="/img/blog/hexo-icarus-release-note.png" alt="hexo-icarus-theme 5.0.1 release note"></p><p>일단 위 내용들을 고려해서 6.0.0 으로 다운그레이드를 시도 했고 다시 실행해보니 정상적으로 실행되었다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm i hexo@6.0.0</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>아직 의문인 점은 6.3.0 버전에서 설치되는 js-yaml은 분명 4.1.0 인데 서버 실행 시 오류가 발생하고 6.0.0으로 한번 내렸다가 다시 6.3.0 으로 올리면 정상적으로 실행된다는 점이다 … ㅎㅎ;;</p><h2 id="거슬리던-경고들">거슬리던 경고들</h2><p>하는 김에 그동안 거슬렸던 경고들도 몇개 있었는데 대략 아래와 같은 내용이었다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">INFO  Validating config</span><br><span class="line">Inferno is <span class="keyword">in</span> development mode.</span><br><span class="line">INFO  =======================================</span><br><span class="line"> ██╗ ██████╗ █████╗ ██████╗ ██╗   ██╗███████╗</span><br><span class="line"> ██║██╔════╝██╔══██╗██╔══██╗██║   ██║██╔════╝</span><br><span class="line"> ██║██║     ███████║██████╔╝██║   ██║███████╗</span><br><span class="line"> ██║██║     ██╔══██║██╔══██╗██║   ██║╚════██║</span><br><span class="line"> ██║╚██████╗██║  ██║██║  ██║╚██████╔╝███████║</span><br><span class="line"> ╚═╝ ╚═════╝╚═╝  ╚═╝╚═╝  ╚═╝ ╚═════╝ ╚══════╝</span><br><span class="line">=============================================</span><br><span class="line">INFO  === Checking package dependencies ===</span><br><span class="line">INFO  === Checking theme configurations ===</span><br><span class="line">WARN  Theme configurations failed one or more checks.</span><br><span class="line">WARN  Icarus may still run, but you will encounter unexcepted results.</span><br><span class="line">WARN  Here is some information <span class="keyword">for</span> you to correct the configuration file.</span><br><span class="line">WARN  [</span><br><span class="line">  &#123;</span><br><span class="line">    keyword: <span class="string">&#x27;const&#x27;</span>,</span><br><span class="line">    dataPath: <span class="string">&#x27;.widgets[7].type&#x27;</span>,</span><br><span class="line">    schemaPath: <span class="string">&#x27;#/properties/type/const&#x27;</span>,</span><br><span class="line">    params: &#123; allowedValue: <span class="string">&#x27;profile&#x27;</span> &#125;,</span><br><span class="line">    message: <span class="string">&#x27;should be equal to constant&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>로그로 봤을땐 테마의 위젯 설정값이 뭔가 잘못된거 같길래 한참 이것저것 검색하다가 위젯 설정값을 찬찬히 보니까 type의 값을 주석처리 해놔서 발생한 오류였다.<br>진짜 이거 찾느라 시간 보낸거 아까워서 ㅠㅠ 나처럼 바보짓 하는 사람 없길 바라면 적는다.</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="comment"># Where should the widget be placed, left sidebar or right sidebar</span></span><br><span class="line">  <span class="attr">position:</span> <span class="string">left</span></span><br><span class="line">  <span class="attr">type:</span> <span class="comment">#adsense</span></span><br><span class="line">  <span class="comment"># AdSense client ID</span></span><br><span class="line">  <span class="attr">client_id:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">  <span class="comment"># AdSense AD unit ID</span></span><br><span class="line">  <span class="attr">slot_id:</span> <span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure><p>작업들을 하면서 느끼는건데 Jekyll을 사용해서 샘플로 만들어봤을때 너무 느린 속도가 싫어서 Hexo를 선택했는데 포스팅한 글을 git으로 동시관리가 안되고 별도 repo 설정해서 이중관리 해야하는 부분이나 영어보다 중국어 레퍼런스가 더 많아서 관련 자료 찾는데 쉽지 않은 부분 때문에 요즘엔 다른 엔진으로 갈아타는건 어떨까 하는 생각도 든다.</p><p>일단 블로그 글도 별로 없는데 이런거 고민할 필요는 없을거 같기도 하고 ㅋㅋㅋ 나중에 다시 생각해보자</p>]]></content:encoded>
      
      
      <category domain="https://yoo0926.github.io/categories/blog/">blog</category>
      
      
      <category domain="https://yoo0926.github.io/tags/blog/">blog</category>
      
      <category domain="https://yoo0926.github.io/tags/hexo/">hexo</category>
      
      
      <comments>https://yoo0926.github.io/2023/05/21/blog/hexo-upgrade/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>log4j2 설정</title>
      <link>https://yoo0926.github.io/2023/04/17/spring/log4j-1/</link>
      <guid>https://yoo0926.github.io/2023/04/17/spring/log4j-1/</guid>
      <pubDate>Mon, 17 Apr 2023 09:34:51 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;사내 프로젝트의 여러가지 설정, 프로퍼티들은 dev, test, master로 분리되어있는데 살펴보다보니 log4j2-test.xml이 없고 test 프로파일로 빌드 시 log4j2-dev.xml을 바라보고 있었다.&lt;/p&gt;
&lt;p&gt;시간도 좀 여유가</description>
        
      
      
      
      <content:encoded><![CDATA[<p>사내 프로젝트의 여러가지 설정, 프로퍼티들은 dev, test, master로 분리되어있는데 살펴보다보니 log4j2-test.xml이 없고 test 프로파일로 빌드 시 log4j2-dev.xml을 바라보고 있었다.</p><p>시간도 좀 여유가 있던 시점이라 그냥 내가 만들어서 분리시켰는데 하는김에 SQL 관련 로그 설정을 변경했고 공부도 할겸 내용을 정리했다.</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- SQL Logger --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;jdbc.connection&quot;</span> <span class="attr">additivity</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">level</span> <span class="attr">value</span>=<span class="string">&quot;OFF&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;console&quot;</span>/&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;jdbc.audit&quot;</span> <span class="attr">additivity</span>=<span class="string">&quot;false&quot;</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">level</span> <span class="attr">value</span>=<span class="string">&quot;OFF&quot;</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;console&quot;</span>/&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">logger</span>&gt;</span> </span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;jdbc.resultset&quot;</span> <span class="attr">additivity</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">level</span> <span class="attr">value</span>=<span class="string">&quot;OFF&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;console&quot;</span>/&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;jdbc.sqlonly&quot;</span> <span class="attr">additivity</span>=<span class="string">&quot;false&quot;</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">level</span> <span class="attr">value</span>=<span class="string">&quot;OFF&quot;</span>/&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;console&quot;</span>/&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br><span class="line">   </span><br><span class="line"><span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;jdbc.resultsettable&quot;</span> <span class="attr">additivity</span>=<span class="string">&quot;false&quot;</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">level</span> <span class="attr">value</span>=<span class="string">&quot;info&quot;</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;console&quot;</span>/&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">logger</span>&gt;</span> </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;jdbc.sqltiming&quot;</span> <span class="attr">additivity</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">level</span> <span class="attr">value</span>=<span class="string">&quot;info&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;console&quot;</span>/&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>키</th><th>내용</th></tr></thead><tbody><tr><td>jdbc.connection</td><td>열려있는 모든 번호와 연결 수립 및 해제 이벤트를 기록. 이는 연결 문제를 찾아내는데 매우 유용 (Connection Pool 설정)</td></tr><tr><td>jdbc.audit</td><td>ResultSet을 제외한 모든 JDBC 호출 정보를 로그로 남긴다. 많은 양의 로그가 생성되므로 특별히 JDBC 문제를 추적해야 할 필요가 있는 경우를 제외하고는 사용을 권장하지 않는다.</td></tr><tr><td>jdbc.resultset</td><td>ResultSet을 포함한 모든 JDBC 호출 정보를 로그로 남기므로 매우 방대한 양의 로그가 생성된다.</td></tr><tr><td>jdbc.sqlonly</td><td>SQL문만을 로그로 남기며, PreparedStatement일 경우 관련된 argument 값으로 대체된 SQL문이 보여진다. (원래는 ? 로 표시되는데, log4j 덕분에 완전한 쿼리로 보여지는 것임)</td></tr><tr><td>jdbc.resultsettable</td><td>SQL 결과 조회된 데이터의 table을 로그로 남긴다.</td></tr><tr><td>jdbc.sqltiming</td><td>SQL문과 해당 SQL을 실행시키는데 수행된 시간 정보(milliseconds)를 포함한다.</td></tr></tbody></table><p><strong>SQL관련</strong></p><p>sqlonly와 sqltiming은 sql로그를 찍는 공통적인 기능을 하며 sqltiming이 sqlonly를 포함하고 있습니다.</p><p>#{id} 등 파라미터로 넣어준 값도 모두 치환하여 출력해줍니다.</p><p>둘다 찍도록 하면 sql문이 두번 찍히니 하나만 찍어줍니다.</p><ul><li>jdbc.sqlonly : SQL문을 로그로 남깁니다.</li><li>jdbc.sqltiming : SQL문과 수행된 시간을 로그로 남깁니다.</li></ul><p><strong>TABLE관련</strong></p><p>결과를 table형식으로 만들어 출력해줍니다.</p><ul><li>jdbc.resultsettable : SQL 결과 조회된 데이터를 table 형식으로 만들어줍니다.</li></ul><p><strong>JDBC호출 관련</strong></p><p>아래 두개의 설정은 일반적으로는 킬 필요가 없는 설정입니다.</p><p>두개가 묶음으로 JDBC 호출정보를 출력해주는 기능을 하며 ResultSet을 포함하느냐 포함하지 않느냐의 차이입니다.</p><ul><li>jdbc.audit : ResultSet을 제외한 JDBC 호출 정보를 로그로 남긴다.</li><li>jdbc.resultset : ResultSet을 포함한JDBC 호출 정보를 로그로 남깁니다.</li></ul><p>additivity : 중복된 로그를 남길 지 여부를 설정한다.</p><p>기본적으로 logger는 정의한 패키지의 조상으로부터 모든 appender를 상속받아서 만약 어떤 Logger가 같은 appender를 사용한다면 메시지가 2번 찍히게 된다.</p><p>additivity=”false” 설정하면 이를 방지할 수 있다.</p><h3 id="Log-Level">Log Level</h3><p>로그 레벨은 다음과 같다. (OFF &gt; FATAL &gt; ERROR &gt; WARN &gt; INFO &gt; DEBUG &gt; TRACE &gt; ALL)</p><table><thead><tr><th>레벨</th><th>범위</th></tr></thead><tbody><tr><td>OFF</td><td>이벤트를 기록하지 않음</td></tr><tr><td>FATAL</td><td>아주 심각한 에러가 발생한 상태를 나타냄. 시스템적으로 심각한 문제가 발생해서 어플리케이션 작동이 불가능할 경우가 해당하는데, 일반적으로는 어플리케이션에서는 사용할 일이 없음.</td></tr><tr><td>ERROR</td><td>요청을 처리하는중 문제가 발생한 상태를 나타냄.</td></tr><tr><td>WARN</td><td>처리 가능한 문제이지만, 향후 시스템 에러의 원인이 될 수 있는 경고성 메시지를 나타냄.</td></tr><tr><td>INFO</td><td>로그인, 상태변경과 같은 정보성 메시지를 나타냄.</td></tr><tr><td>DEBUG</td><td>개발시 디버그 용도로 사용한 메시지를 나타냄.</td></tr><tr><td>TRACE</td><td>디버그 레벨이 너무 광범위한 것을 해결하기 위해서 좀더 상세한 상태를 나타냄.</td></tr><tr><td>ALL</td><td>모든 이벤트를 기록함</td></tr></tbody></table>]]></content:encoded>
      
      
      <category domain="https://yoo0926.github.io/categories/spring/">spring</category>
      
      
      <category domain="https://yoo0926.github.io/tags/spring/">spring</category>
      
      
      <comments>https://yoo0926.github.io/2023/04/17/spring/log4j-1/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[WebFlux] Mono.defer(), Mono.fromCallable()</title>
      <link>https://yoo0926.github.io/2023/04/04/spring/WebFlux/spring-webflux-3/</link>
      <guid>https://yoo0926.github.io/2023/04/04/spring/WebFlux/spring-webflux-3/</guid>
      <pubDate>Tue, 04 Apr 2023 00:46:08 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;code&gt;Mono.defer()&lt;/code&gt;와 &lt;code&gt;Mono.fromCallable()&lt;/code&gt; 모두 지연 평가(lazy evaluation)를 제공하는데 사용된다. 지연 평가란 호출 시점을 지연시켜서 필요한 시점에서 코드를 실행하는 </description>
        
      
      
      
      <content:encoded><![CDATA[<p><code>Mono.defer()</code>와 <code>Mono.fromCallable()</code> 모두 지연 평가(lazy evaluation)를 제공하는데 사용된다. 지연 평가란 호출 시점을 지연시켜서 필요한 시점에서 코드를 실행하는 방식을 의미한다.</p><p>Mono.defer() 메서드는 Mono의 factory 메서드 중 하나로, 인자로 전달받은 Supplier 함수를 사용하여 Mono 객체를 생성한다. 이때 Supplier 함수가 호출되는 시점은 Mono 객체를 subscribe 할 때이다.</p><p>Mono.fromCallable() 메서드는 Mono의 factory 메서드 중 하나로, 인자로 전달받은 Callable 함수를 사용하여 Mono 객체를 생성한다. 이때 Callable함수가 호출되는 시점은 Mono객체 생성 시점이다.</p><p>따라서 Mono.defer()는 Mono 객체를 생성할 때마다 Supplier함수를 실행하여 객체를 생성하는 방식을 사용하며, Mono.fromCallable()은 Mono객체를 생성하는 시점에서 Callable함수를 실행하여 객체를 생성하는 방식을 사용한다. Mono.fromCallable()은 즉시 실행되므로, Mono.defer()보다 더 많은 자원을 소비할 수 있다.</p><p>Mono.defer()는 Mono의 객체 생성 시점을 늦추고, 객체 생성과 동시에 상태를 초기화할 수 있는 장점이 있고 반면에 Mono.fromCallable()은 Callable함수의 실행 결과를 즉시 Mono객체에 포함시키므로, 결과를 즉시 필요로 하는 경우에 유용하다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">&#123;</span><br><span class="line">    callExternalService()</span><br><span class="line">            .repeat(<span class="number">3</span>)</span><br><span class="line">            .doOnNext(System.out::println)</span><br><span class="line">            .subscribe();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Mono&lt;?&gt; callExternalService()</span><br><span class="line">&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;External service is called.&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> Mono.just(<span class="string">&quot;result&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">External service is called.</span></span><br><span class="line"><span class="comment">result</span></span><br><span class="line"><span class="comment">result</span></span><br><span class="line"><span class="comment">result</span></span><br><span class="line"><span class="comment">result</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>Mono.just(“result”)의 결과를 repeat(3)으로 세 번 반복하게 되면, 해당 Mono를 세 번 실행하게 된다.</p><p>하지만, Mono.just(“result”)는 호출될 때마다 값을 생성하는 게 아니라, 최초 1회 호출시 생성한 값을 계속해서 방출하게 된다. 그래서 &quot;External service is called.&quot;는 처음 1회만 출력되고, 세 번 반복되는 Mono.just(“result”)는 이미 생성된 값을 방출하게 되므로, 추가로 호출할 필요가 없어지게 된다.</p><p>따라서 &quot;External service is called.&quot;는 최초 1회만 출력되고, 세 번 반복되는 Mono.just(“result”)는 이미 생성된 값을 방출하게 된다.</p>]]></content:encoded>
      
      
      <category domain="https://yoo0926.github.io/categories/spring/">spring</category>
      
      <category domain="https://yoo0926.github.io/categories/spring/WebFlux/">WebFlux</category>
      
      
      <category domain="https://yoo0926.github.io/tags/spring/">spring</category>
      
      
      <comments>https://yoo0926.github.io/2023/04/04/spring/WebFlux/spring-webflux-3/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>11. 의식적으로 지름길 사용하기</title>
      <link>https://yoo0926.github.io/2023/04/02/book/clean-architecture/clean-11/</link>
      <guid>https://yoo0926.github.io/2023/04/02/book/clean-architecture/clean-11/</guid>
      <pubDate>Sun, 02 Apr 2023 14:13:58 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;경제적인 관점에서 지름길을 사용하는게 더 효과적일 수 있다. 지름길을 사용하려면 일단 지름길 자체를 파악해야 한다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;유스케이스 간 모델 공유하기&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;기본적으로 유스케이스마다 다른 입출력 모델을 가져야 </description>
        
      
      
      
      <content:encoded><![CDATA[<p>경제적인 관점에서 지름길을 사용하는게 더 효과적일 수 있다. 지름길을 사용하려면 일단 지름길 자체를 파악해야 한다.</p><ol><li>유스케이스 간 모델 공유하기</li></ol><p>기본적으로 유스케이스마다 다른 입출력 모델을 가져야 한다. 입력 파라미터의 타입과 반환값의 타입이 달라야 한다는 말이다.</p><p>만약 인커밍 포트 인터페이스의 입출력 모델이 같은 모델을 공유할 경우 공유한 모델이 변경될 경우 두 유스케이스 모두 영향을 받는다. 단일 책임 원칙에서 중요하게 생각하는 “변경할 이유”를 공유하게 되는 것이다.</p><p>만약 실제로 특정 세부사항을 변경할 경우 실제 두 유스케이스 모두에 영향을 주고 싶은 것이라면 괜찮다.</p><p>시작은 공유하더라도 어느 시점에서 유스케이스가 독립적으로 분리가 필요한 시점이라면 분리해야 한다.</p><ol><li>도메인 엔티티를 입출력 모델로 사용하기</li></ol><p>도메인 엔티티를 유스케이스의 입출력 모델로 사용하면 결합이 발생한다.</p><p>유스케이스가 단순히 데이터베이스 필드 몇개를 업데이트 하는 수준으로 간단하다면 괜찮을지도 모르지만 더 복잡한 도메인 로직을 구현해야 한다면 유스케이스 인터페이스에 대한 전용 입출력 모델을 만들어야 한다.</p><p>유스케이스의 변경이 도메인 엔티티까지 전파되는걸 바라지 않는다면 말이다.</p><ol><li>인커밍 포트 건너뛰기</li></ol><p>아웃고잉 포트는 의존성 역전(안쪽으로 흐르게 하기)에 필수 요소이지만 인커밍 포트는 그렇지 않다.</p><p>인커밍 어댑터에서 인커밍 포트 없이 애플리케이션 서비스에 직접 접근하도록 할 수 있다.</p><p>이 경우 두 계층 사이의 추상화 계층을 줄이면서 괜찮게 느껴질 수 있다.</p><p>하지만 인커밍 포트를 통해 애플리케이션 중심에 접근하는 진입점을 정의하지 않으면 특정 유스케이스를 구현하기 위해 어떤 서비스 메서드를 호출해야 하는지 알기 위해 애플리케이션 내부 동작에 대해 더 알아야 한다.</p><ol><li>애플리케이션 서비스 건너뛰기</li></ol><p>만약 간단한 CRUD 유스케이스에서 애플리케이션 서비스가 도메인 로직 없이 생성, 업데이ㅌ, 삭제 요청을 그대로 영속성 어댑터에 전달하기 때문에 건너뛰고 싶을 수도 있다.</p><p>하지만 이렇게 하려면 인커밍 어댑터와 아웃고잉 어댑터 사이에 모델을 공유해야 하는데 공유해야 하는 모델이 도메인 엔티티가 되면서 앞서 이야기한 도메인 엔티티를 입출력 모델로 사용하는 경우가 될 것이다.</p><p>또한 시간이 지나서 유스케이스가 점점 복잡해지면 도메인 로직을 그대로 아웃고잉 어댑터에 추가하고 싶은 생각이 들면서 도메인 로직이 흩어져서 찾고 유지보수 하는것이 어려워 진다.</p>]]></content:encoded>
      
      
      <category domain="https://yoo0926.github.io/categories/book/">book</category>
      
      <category domain="https://yoo0926.github.io/categories/book/clean-architecture/">clean-architecture</category>
      
      
      <category domain="https://yoo0926.github.io/tags/book/">book</category>
      
      
      <comments>https://yoo0926.github.io/2023/04/02/book/clean-architecture/clean-11/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>10. 아키텍처 경계 강제하기</title>
      <link>https://yoo0926.github.io/2023/04/02/book/clean-architecture/clean-10/</link>
      <guid>https://yoo0926.github.io/2023/04/02/book/clean-architecture/clean-10/</guid>
      <pubDate>Sun, 02 Apr 2023 12:45:03 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;일정 규모 이상의 프로젝트라면 계층 간의 경계가 약화되고, 코드는 점점 테스트하기 어려워질 것이다.&lt;/p&gt;
&lt;p&gt;아키텍처의 경계를 강제한다는 것은 각 계층간의 의존성이 올바른 방향을 향하도록 강제하는 것을 말한다. 바깥쪽에서 안쪽으로, 어댑터 →</description>
        
      
      
      
      <content:encoded><![CDATA[<p>일정 규모 이상의 프로젝트라면 계층 간의 경계가 약화되고, 코드는 점점 테스트하기 어려워질 것이다.</p><p>아키텍처의 경계를 강제한다는 것은 각 계층간의 의존성이 올바른 방향을 향하도록 강제하는 것을 말한다. 바깥쪽에서 안쪽으로, 어댑터 → 애플리케이션 → 도메인 으로 의존성이 흘러가야 한다.</p><hr><p>의존성 규칙을 강제하는 가장 기본적인 방법은 접근 제한자를 사용하는 것이다.</p><p>public, private, protected는 많이 알고 있지만 default에 대해서 깊게 생각하는 신입 개발자는 많지 않다.</p><p>자바 패키지를 통해 클래스들을 응집적인 모듈로 만들어주기 때문에 default 제한자는 중요하다.</p><p>모듈 내의 클래스들은 서로 접근이 가능하지만 패키지 바깥에선 접근할 수 없다.</p><p>그럼 모듈의 진입점으로 활용할 클래스들만 골라서 public으로 만들어준다면 의존성이 잘못된 방향을 가리키게 될 확률이 줄어든다.</p><p>각 계층의 어댑터, 서비스 클래스는 외부에서 접근할 필요가 없으니 default 제한자로 생성하고 다른 계층에서 접근해야 하는 domain 패키지는 public으로 만들 수 있다.</p><p>마찬가지로 웹어댑터와 영속성 어댑터에서 접근 가능해야 하는 애플리케이션 계층의 인커밍,아웃고잉 포트 역시 public으로 구현해야 한다.</p><p>default 제한자는 몇 개 정도의 클래스로만 이뤄진 작은 모듈에서 가장 효과적이다.</p><p>패키지 내 클래스가 일정 수준을 넘어서게 되면 보통 하위 패키지를 만드는 방법을 선호하는데 이렇게 하면 자바는 하위 패키지를 다른 패키지로 취급하여 하위 패키지의 default 멤버에 접근할 수 없게 된다.</p><p>이렇게 되면 하위 패키지의 멤버는 public으로 만들어서 바깥으로 노출시켜야 하는데 의존성 규칙이 깨질 수 있는 환경이 될 수 있다.</p><hr><p>클래스에 public 제한자를 사용하면 아키텍처의 의존성 방향이 잘못되더라도 컴파일러에서 이를 확인할 수 없다.</p><p>이때 컴파일 후 런타임에서 체크하는 방법을 도입할 수 있는데 ArchUnit은 Junit과 같은 단위 테스트 프레임워크 기반에서 아키텍처의 의존성 규칙 위반을 발견하면 예외를 던질 수 있는 API를 제공한다.</p><p>ArchUnit API를 이용하면 헥사고날 아키텍처 내에서 관련된 모든 패키지를 명시할 수 있는 일종의 도메인 특화 언어(DSL)을 만들 수 있고 패키지 사이의 의존성 방향이 올바른지 자동으로 체크할 수 있다.</p><p>네이버에서 유닛테스트에 해당 라이브러리를 도입한 사례는 나중에 참고해보자 <a href="https://d2.naver.com/helloworld/9222129">https://d2.naver.com/helloworld/9222129</a></p><hr><p>Maven이나 Gradle은 자바에서 많이 사용하는 빌드 도구인데 주요한 기능 중 하나는 의존성 해결이다.</p><p>잘못된 의존성을 막기 위해 아키텍처를 여러 개의 빌드 아티팩트로 만들 수 있다.</p><p>각 모듈 혹은 계층에 대해 전용 코드베이스와 빌드 아티팩트로 분리된 빌드 모듈(JAR 파일)을 만들고 각 모듈의 빌트 스크립트에서는 아키텍처에서 허용하는 의존성만 지정하게 되면 클래스들이 클래스패스에 존재하지도 않아 컴파일 에러가 발생하여 잘못된 의존성을 만들수조차 없게 될 것이다.</p><p>또한 빌드 모듈로 아키텍처 경계를 구분하는 것을 패키지로 구분하는 방식에 비해 몇가지 장점이 더 있는데</p><ol><li>빌드 도구는 순환 의존성(circular dependency)를 허용하지 않는다. 의존성을 해결하는 과정에서 무한 루프에 빠지기 때문에 빌드 도구를 사용하면 순환의존성이 없음을 확신할 수 있다.</li><li>빌드 모듈 방식은 다른 모듈을 고려하지 않고 특정 모듈의 코드를 격리한 채로 변경할 수 있다.<br>특정 어댑터에서 컴파일 에러가 발생하는 애플리케이션 계층을 리팩토링 할 경우 같은 빌드 모듈에 있다면 컴파일 에러를 고쳐야 애플리케이션 계층의 테스트가 실행되겠지만 서로 다른 빌드 모듈에 독립적으로 존재할 경우 어댑터의 컴파일 에러와 상관없이 애플리케이션 계층을 테스트할 수 있을 것이다.</li><li>모듈 간 의존성이 빌드 스크립트에 분명하게 선언돼 있기 때문에 새로운 의존성을 추가할 때 의식적으로 한번 더 생각해볼 수 있다.</li></ol>]]></content:encoded>
      
      
      <category domain="https://yoo0926.github.io/categories/book/">book</category>
      
      <category domain="https://yoo0926.github.io/categories/book/clean-architecture/">clean-architecture</category>
      
      
      <category domain="https://yoo0926.github.io/tags/book/">book</category>
      
      
      <comments>https://yoo0926.github.io/2023/04/02/book/clean-architecture/clean-10/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>9. 애플리케이션 조립하기</title>
      <link>https://yoo0926.github.io/2023/04/02/book/clean-architecture/clean-9/</link>
      <guid>https://yoo0926.github.io/2023/04/02/book/clean-architecture/clean-9/</guid>
      <pubDate>Sun, 02 Apr 2023 09:26:30 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;유스케이스, 웹 어댑터, 영속성 어댑터를 구현했으니 이것들이 동작하는 애플리케이션으로 조립해보자.&lt;/p&gt;
&lt;p&gt;각 클래스를 그냥 필요할때 인스턴스화 하지 않는 이유는 코드의 의존성이 올바른 방향을 가리키게 하기 위해서다. 모든 의존성은 안쪽, 애</description>
        
      
      
      
      <content:encoded><![CDATA[<p>유스케이스, 웹 어댑터, 영속성 어댑터를 구현했으니 이것들이 동작하는 애플리케이션으로 조립해보자.</p><p>각 클래스를 그냥 필요할때 인스턴스화 하지 않는 이유는 코드의 의존성이 올바른 방향을 가리키게 하기 위해서다. 모든 의존성은 안쪽, 애플리케이션의 도메인 코드 방향으로 향해야 도메인 코드가 바깥 계층의 변경으로부터 안전하다.</p><p>헥사고날 아키텍처 스타일은 하나의 코드를 훨씬 더 테스트하기 쉽다. 한 클래스가 필요로 하는 모든 객체를 생성자로 전달할 수 있다면 실제 객체 대신 목으로 전달할 수 있고, 이렇게 되면 격리된 단위 테스트를 생성하기 쉬워진다.</p><p>가장 추천하는 건 객체 인스턴스를 생성할 책임을 모든 클래스에 대한 의존성을 가지는 설정 컴포넌트를 만드는 것이다.</p><ul><li>각 계층의 어댑터 인스턴스 생성</li><li>HTTP요청, 데이터베이스 접근 등 외부 접근에 대한 전달을 보장</li><li>각 어댑터에 유스케이스 인스턴스 제공</li></ul><p>그 외 설정 파일이나 설정 파라미터의 소스에도 접근해야 한다.</p><p>단일 책임 원칙을 위반하게 되지만 나머지 부분을 깔끔하게 유지하기 위해서 구성요소들을 연결하는 바깥쪽 컴포넌트가 필요하다.</p><p>스프링 프레임워크를 이용해서 애플리케이션을 조립한 결과물을 애플리케이션 컨텍스트(application context)라고 한다. 애플리케이션 컨텍스트는 애플리케이션을 구성하는 모든 객체(bean)을 포함한다.</p><p>일반적으로는 스프링의 클래스패스 스캐닝으로 조립하는데 클래스패스에서 접근 가능한 모든 클래스를 확인해서 @Component 어노테이션이 붙은 클래스를 찾아서 각 클래스의 객체를 생성한다.</p><p>이때 필요한 모든 필드를 인자로 받는 생성자가 필요한데 Lombok 라이브러리의 @RequiredArgsConstructor 어노테이션을 사용하면 모든 final 필드를 인자로 받는 생성자를 자동으로 만들수도 있다.</p><p>각 클래스들의 인스턴스를 만들어 애플리케이션 컨텍스트에 추가하게 되는데 어노테이션 기반이라 필요한 곳에 작성만 잘하면 손쉽게 애플리케이션을 조립할 수 있지만 몇가지 단점도 존재한다.</p><ol><li>클래스에 프레임워크에 특화된 어노테이션을 붙여야 한다는 점에서 침투적이다.<br>일반적인 애플리케이션 개발에선 필요한 경우 한두개 정도는 용인되더라도 다른 개발자들이 사용할 라이브러리나 프레임워크를 만드는 입장이라면 사용자가 스프링 프레임워크의 의존성에 엮이게 되서 쓰지 말아야 한다.</li><li>스프링 전문가가 아니라면 문제가 발생했을 때 원인을 찾는데 많은 시간이 소요될 수 있다.<br>이는 클래스패스 스캐닝이 단순히 스프링에게 부모 패키지를 알려 준 후 이 패키지 안에서 @Compoment가 붙은 모든 클래스를 찾는 방법이기 때문이다.<br>애플리케이션 내 모든 클래스를 하나하나 다 알기 어렵다.</li></ol><p>좀 더 제어하기 쉬운 대안으로 스프링의 Java Config로 조립하는 방법이 있다.</p><p>이 방식은 애플리케이션 컨텍스트에 추가할 빈을 생성하는 설정 클래스를 만든다.</p><p>@Configuration 어노테이션을 사용하여 설정 클래스임을 표시하여 클래스패스 스캐닝을 사용하는 방식은 모든 빈을 가져오는 대신 설정 클래스만 선택하기 때문에 제어가 한결 쉽다.</p><p>빈 자체는 설정 클래스 내의 @Bean 어노테이션이 붙은 팩토리 메서드를 통해 생성한다.</p><p>@EnabledJpaRepositories 어노테이션을 사용하여 스프링 부트가 정의된 모든 스프링 데이터 리포지토리 인터페이스의 구현체를 제공할 것이다.</p><p>이 어노테이션은 설정 클래스가 아니라 메인 애플리케이션에도 붙일 수 있지만 그럴 경우 애플리케이션이 시작할 때마다 JPA를 활성화해서 영속성이 실질적으로 필요없는 테스트에서 애플리케이션을 실행할 때도 JPA 리포지토리들을 활성화 할 것이다.<br>따라서 이러한 기능 어노테이션은 별도의 설정 모듈에 있는 것이 한꺼번에 모든 것이 시작할 필요가 없어져서 애플리케이션을 더 유연하게 만들어 준다.</p><p>이러한 방식은 일반적인 클래스패스 스캐닝 방식에 비해 @Component 어노테이션을 코드 여기저기에 붙이도록 강제하지 않아서 애플리케이션 계층을 스프링 프레임워크에 대한 의존성 없이 깔끔하게 유지할 수 있다.</p><p>다만, 설정 클래스가 생성하는 빈이 설정 클래스와 같은 패키지에 존재하지 않는다면 이 빈들을 public 으로 만들어야 한다.</p>]]></content:encoded>
      
      
      <category domain="https://yoo0926.github.io/categories/book/">book</category>
      
      <category domain="https://yoo0926.github.io/categories/book/clean-architecture/">clean-architecture</category>
      
      
      <category domain="https://yoo0926.github.io/tags/book/">book</category>
      
      
      <comments>https://yoo0926.github.io/2023/04/02/book/clean-architecture/clean-9/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>8. 경계 간 매핑하기</title>
      <link>https://yoo0926.github.io/2023/04/02/book/clean-architecture/clean-8/</link>
      <guid>https://yoo0926.github.io/2023/04/02/book/clean-architecture/clean-8/</guid>
      <pubDate>Sun, 02 Apr 2023 08:16:29 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;앞서 웹, 애플리케이션, 도메인, 영속성 계층의 역할에 대해선 이야기 했으니 각 계층의 모델을 매핑하는 것에 대해서 이야기해보자.&lt;/p&gt;
&lt;p&gt;매핑을 하지 않으면 양 계층에서 같은 모델을 사용하게 되면서 두 계층이 강하게 결합된다.&lt;/p&gt;
&lt;p&gt;</description>
        
      
      
      
      <content:encoded><![CDATA[<p>앞서 웹, 애플리케이션, 도메인, 영속성 계층의 역할에 대해선 이야기 했으니 각 계층의 모델을 매핑하는 것에 대해서 이야기해보자.</p><p>매핑을 하지 않으면 양 계층에서 같은 모델을 사용하게 되면서 두 계층이 강하게 결합된다.</p><p>하지만 보일러플레이트 코드를 너무 많이 만들게 되는 단점이 발생하기도 한다.</p><p>매핑하기는 크게 4가지 전략이 있다.</p><ol><li>매핑하지 않기 전략</li></ol><p>계층들을 연결하는 포트 인터페이스가 도메인 모델을 입출력 모델로 사용하여 모든 계층이 같은 모델을 사용한다면 계층간 매핑이 전혀 필요없다.</p><p>하지만 이러한 전략은 특정 계층에 특별한 요구사항이 발생할 경우 그와 상관없는 모든 계층의 모델에 새로운 필드나 어노테이션이 추가될 수 있다.</p><p>도메인 모델이 다른 계층들과 관련된 이유로 변경되야 하므로 단일 책임 원칙을 위반한다.</p><p>하지만 간단한 CRUD 유스케이스같은 경우는 같은 필드를 가진 웹 모델을 도메인 모델로, 혹은 도메인 모델을 영속성 모델로 매핑할 필요가 없을 것이다.</p><p>모든 계층이 정확히 같은 구조의, 정확히 같은 정보를 필요로 한다면 매핑하지 않기 전략은 좋은 선택지가 될 수 있다.</p><ol><li>양방향 매핑 전략</li></ol><p>각 계층이 전용 모델을 가진 매핑 전략을 말한다.</p><p>각 어댑터가 전용 모델을 가지고 있어서 해당 모델을 도메인 모델로, 도메인 모델을 해당 모델로 매핑할 책임을 가지고 있다.</p><p>웹 계층의 컨트롤러는 웹 모델을 서비스와 연결되는 포트 인터페이스에서 도메인 모델로 매핑하고 반환된 도메인 객체를 다시 웹 모델로 매핑한다. 영속성 계층도 이와 유사하게 구현한다.</p><p>각 계층은 전용 모델을 가지고 있으므로 각 계층이 전용 모델을 변경하더라도 다른 계층에는 영향이 없다.</p><p>각 모델은 계층에 필요한 데이터, 유스케이스를 제일 잘 구현할 수 있고 도메인 모델은 웹이나 영속성의 관심사로 오염되지 않는 깨끗한 도메인 모델로 이어져서 단일 책임 원칙을 만족한다.</p><p>개념적으로 매핑하지 않기 다음으로 간단하여 매핑 책임이 명확한데 매핑보다 도메인 로직에 집중할 수 있다.</p><p>다만, 너무 많은 보일러플레이트 코드가 생기는데 두 모델 간 매핑을 구현하는 데 꽤 시간이 들고 매핑 프레임워크를 사용하여 내부 동작을 제네릭과 리플렉션 뒤로 숨길 경우 디버깅하기도 쉽지 않다.</p><p>또다른 단점으로 도메인 모델이 계층 경계를 넘어서 통신하는데 사용된다는 것이다.</p><p>인커밍, 아웃고잉 포트는 도메인 객체를 입력 파라미터와 반환값으로 사용하면서 바깥쪽 계층의 요구에 따라 변경에 취약해질 수 있다.</p><ol><li>완전 매핑 전략</li></ol><p>각 연산마다 모두 별도의 입출력 모델을 사용할 수 있다. 계층 경계를 넘어 통신할 때 도메인 모델을 사용하는게 아니라 각 작업에 특화된 전용 모델을 만드는 것이다.</p><p>당연히 한 계층을 다른 여러 개의 커맨드로 연결하게 되면 하나의 웹 모델과 도메인 모델 간의 매핑보다 더 많은 코드가 필요하지만 여러 유스케이스의 요구사항을 함께 다뤄야 하는 매핑에 비해 구현하고 유지보수 하기가 훨씬 쉽다.</p><p>완전 매핑 전략은 전역적으로 적용하기 보다는 웹 계층과 애플리케이션 계층 사이에 상태 변경 유스케이스의 경계를 명확하게 할 때 가장 좋다.</p><p>애플리케이션 계층과 영속성 계층 사이에는 매핑 오버헤드 때문에 추천하지 않는다.</p><ol><li>단방향 매핑 전략</li></ol><p>모든 계층의 모델들이 같은 인터페이스를 구현한다. 이 인터페이스는 관련있는 모든 필드에 대한 getter 메서드를 제공하여 도메인 모델의 상태를 캡슐화 한다.</p><p>웹, 영속성 계층으로 도메인 객체를 전달하고 싶으면 별도의 매핑 없이 할수 있다. 모든 계층이 바라보는 상태 인터페이스를 사용할지, 전용 모델로 매핑할지는 바깥 계층에서 정할 수 있다.</p><p>행동을 변경하는 것이 상태 인터페이스에 의해 노출돼 있지 않기 때문에 실수로 도메인 객체의 상태를 변경하는 일은 발생하지 않는다.</p><p>각 매핑 전략은 저마다의 장단점이 있때문에 한 전략을 전역적으로 사용하기 보다는 그때그때 상황에 맞는 전략을 구사해야 한다.</p>]]></content:encoded>
      
      
      <category domain="https://yoo0926.github.io/categories/book/">book</category>
      
      <category domain="https://yoo0926.github.io/categories/book/clean-architecture/">clean-architecture</category>
      
      
      <category domain="https://yoo0926.github.io/tags/book/">book</category>
      
      
      <comments>https://yoo0926.github.io/2023/04/02/book/clean-architecture/clean-8/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>7. 아키텍처 요소 테스트하기</title>
      <link>https://yoo0926.github.io/2023/04/02/book/clean-architecture/clean-7/</link>
      <guid>https://yoo0926.github.io/2023/04/02/book/clean-architecture/clean-7/</guid>
      <pubDate>Sun, 02 Apr 2023 01:12:23 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;기본 전제&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;만드는 비용이 적고&lt;/li&gt;
&lt;li&gt;유지보수 하기 쉬워야 하며&lt;/li&gt;
&lt;li&gt;빨리 실행되고 안정적인 작은 크기의 테스트들에 대해 높은 커버리지를 유지해야 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;테스트 피라미드&lt;/p&gt;
</description>
        
      
      
      
      <content:encoded><![CDATA[<p>기본 전제</p><ul><li>만드는 비용이 적고</li><li>유지보수 하기 쉬워야 하며</li><li>빨리 실행되고 안정적인 작은 크기의 테스트들에 대해 높은 커버리지를 유지해야 한다.</li></ul><p>테스트 피라미드</p><ul><li>시스템 테스트 : 애플리케이션을 구성하는 모든 객체 네트워크를 가동시켜 특정 유스케이스가 전 계층에서 잘 동작하는지 검증</li><li>통합테스트: 연결된 여러 유닛을 인스턴스화하고 시작점이 되는 클래스의 인터페이스로 데이터를 보낸 후 유닛들의 네트워크가 기대한대로 잘 동작하는지 검증</li><li>단위테스트 : 하나의 클래스를 인스턴스화하고 해당 클래스의 인터페이스를 통해 기능들을 테스트</li></ul><p>클린 아키텍처 기준</p><ul><li>단위 테스트 : 특정 코드의 중요한 로직들이 의도한대로 별도의 외부 의존성 없이 제대로 돌아가는지 검증이 필요한 경우, 도메인 엔티티 테스트, 유스케이스 테스트</li><li>통합 테스트 : 웹 어댑터, 영속성 어댑터와 같이 외부 클라이언트와 상호작용을 통해 검증이 필요한 경우</li><li>시스템 테스트 : 전체 애플리케이션을 띄우고 API를 통해 요청을 보내고 모든 계층이 조화롭게 잘 동작하는지 검증</li></ul><p>앞서 단위, 통합 테스트를 잘 구현했다면 시스템 테스트는 일부 겹치는 로직도 있지만 단위,통합만으로 알아차리지 못한 계층 간 매핑 버그 같은건 시스템 테스트를 통해서 알게되는 경우도 있다.</p><p>시스템 테스트를 통해 중요한 시나리오들을 모두 커버하면 배포할 준비가 된것이다.</p><p>단순히 라인 커버리지를 100%로 만드는 것을 목표로 테스트하는건 잘못된 지표이다.</p><p>처음 몇번의 배포는 믿음의 도약을 하고 이후 버그를 수정하고 이로부터 배우는 것을 목표로 삼는 다면 제대로 가는 것이다.</p><p>“테스트가 이 버그를 왜 잡지 못했을까?” 를 생각하고 이에 대한 답변을 기록하고, 이 케이스를 커버할 수 있는 테스트를 추가해야 한다.</p><p>새로운 필드를 추가할때마다 테스트를 고치는데 한 시간을 써야 한다면 뭔가 잘못된것이다.</p><p>테스트가 구조적 변경에 너무 취약하여 리팩토링할 때마다 테스트 코드도 변경해야 한다면 테스트로서의 가치를 잃는다.</p><p>헥사고날 아키텍처는 도메인 로직과 바깥으로 향한 어댑터를 깔끔하게 분리하여 핵심 도메인 로직은 단위 테스트로, 어댑터는 통합 테스트로 처리하는 명확한 테스트 전략을 정의할 수 있다.</p>]]></content:encoded>
      
      
      <category domain="https://yoo0926.github.io/categories/book/">book</category>
      
      <category domain="https://yoo0926.github.io/categories/book/clean-architecture/">clean-architecture</category>
      
      
      <category domain="https://yoo0926.github.io/tags/book/">book</category>
      
      
      <comments>https://yoo0926.github.io/2023/04/02/book/clean-architecture/clean-7/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>6. 영속성 어댑터 구현하기</title>
      <link>https://yoo0926.github.io/2023/03/25/book/clean-architecture/clean-6/</link>
      <guid>https://yoo0926.github.io/2023/03/25/book/clean-architecture/clean-6/</guid>
      <pubDate>Sat, 25 Mar 2023 06:10:36 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;전통적인 계층형 아키텍처에서는 결국 모든 것이 영속성 계층에 의존하게 되어 ‘데이터베이스 주도 설계’가 되는 문제가 있다.&lt;/p&gt;
&lt;p&gt;이러한 의존성을 역전시키기 위해 영속성 계층을 애플리케이션 계층의 플러그인으로 만드는 방식으로 구현해야 한다.</description>
        
      
      
      
      <content:encoded><![CDATA[<p>전통적인 계층형 아키텍처에서는 결국 모든 것이 영속성 계층에 의존하게 되어 ‘데이터베이스 주도 설계’가 되는 문제가 있다.</p><p>이러한 의존성을 역전시키기 위해 영속성 계층을 애플리케이션 계층의 플러그인으로 만드는 방식으로 구현해야 한다.</p><h3 id="의존성-역전">의존성 역전</h3><p>애플리케이션 서비스에서는 영속성 기능을 사용하기 위해 포트 인터페이스를 호출한다.</p><p>육각형 아키텍처에서 영속성 어댑터는 아웃고잉 어댑터이다. 애플리케이션에 의해 호출뿐, 애플리케이션을 호출하진 않기 때문이다.</p><p>포트는 애플리케이션 서비스와 영속성 코드 사이의 간접적인 계층으로 영속성 계층에 대한 코드 의존성을 없애기 위해 이러한 간접 계층이 추가되었다.</p><p>이제 영속성 코드를 리팩토링하더라도 코어 코드를 변경하는 결과로 이어지진 않는다.</p><h3 id="영속성-어댑터의-책임">영속성 어댑터의 책임</h3><p>영속성 어댑터가 하는 일은 보통 아래와 같다.</p><ol><li>입력을 받는다</li><li>데이터베이스 포맷으로 매핑</li><li>입력을 데이터베이스로 보낸다</li><li>데이터베이스 출력을 애플리케이션 포맷으로 매핑</li><li>출력을 반환한다.</li></ol><p>중요한건 영속성 어댑터의 입력 모델이 영속성 어댑터 내부가 아닌 애플리케이션 코어에 있기 때문에 영속성 어댑터 내부를 변경하는 것이 코어에 영향을 미치지 않는다는 점이다.</p><p>출력 모델도 동일하게 애플리케이션 코어에 위치해야 한다.</p><h3 id="포트-인터페이스-나누기">포트 인터페이스 나누기</h3><p>보통 특정 엔티티가 필요로 하는 모든 데이터베이스 연산을 하나의 리포지토리 인터페이스에 넣는 식으로 구현한다.</p><p>하지만 이러한 방식은 코드에 불필요한 의존성이 생기게 되는데 데이터베이스 연산에 의존하는 각 서비스는 인터페이스에 단 하나의 메서드나 사용하더라도 ‘넓은’ 포트 인터페이스에 의존성을 갖게 되는 문제가 발생한다.</p><p>맥락 상 필요하지 않는 메서드에 생긴 의존성은 코드를 이해하고 테스트하기 어렵게 만든다.</p><p>인터페이스 분리 원칙(Interface Segregation Principle, ISP)을 적용하여 클라이언트가 오직 자신이 필요로 하는 메서드만 알게 만들어 각각의 특화된 인터페이스로 분리해야 한다.</p><p>이렇게 되면 각 서비스는 실제로 필요한 메서드에만 의존하고, 포트의 이름은 역할을 명확하게 표현할 수 있으며 서비스 코드를 짤 때 필요한 포트에 연결만 하면 된다.</p><h3 id="영속성-어댑터-나누기">영속성 어댑터 나누기</h3><p>위에서 나눈 포트 인터페이스처럼 영속성 어댑터도 한개만 만들라는 규칙은 없다. 예를 들면 영속성 연산이 필요한 도메인 클래스(DDD의 애그리거트) 하나당 하나의 영속성 어댑터를 구현할 수도 있다.</p><p>도메인 코드는 영속성 포트에 의해 정의된 명세를 어떤 클래스가 충족시키는지에 관심이 없다. 모든 포트가 구현돼 있기만 한다면 영속성 계층에서 하고 싶은 어떤 작업이든 해도 된다.</p><p>애그리거트당 하나의 영속성 어댑터 접근 방식 또한 나중에 여러 개의 바운디드 컨텍스트(bounded context)의 영속성 요구사항을 분리하기 위한 좋은 토대가 된다. 바운디드 컨텍스트 간의 경계를 명확하게 구분하고 싶다면 각 바운디드 컨텍스트가 영속성 어댑터를 하나씩 가지고 있어야 한다.</p><p>account와 관련된 서비스가 billing과 관련된 영속성 어댑터에 접근하지 않아야 한다. 경계 너머의 다른 무언가가 필요하다면 전용 인커밍 포트를 통해 접근해야 한다.</p><h3 id="스프링-데이터-JPA-예제">스프링 데이터 JPA 예제</h3><p>앞서 살펴본 Account 클래스는 유효한 상태의 Account 엔티티만 생성할 수 있는 팩터리 메서드를 제공하고 계좌 잔고 확인 등 유효성 검증을 모든 상태 변경 메서드에서 수행하기 때문에 유효하지 않은 도메인 모델을 생성할 수 없다. 즉, 최대한 불변성을 유지하려고 한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> buckpal.domain;</span><br><span class="line"></span><br><span class="line"><span class="meta">@AllArgsConstructor(access = AccessLevel.PRIVATE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Account</span>&#123;</span><br><span class="line"><span class="meta">@Getter</span> <span class="keyword">private</span> <span class="keyword">final</span> AccountId id;</span><br><span class="line"><span class="meta">@Getter</span> <span class="keyword">private</span> <span class="keyword">final</span> ActivityWindow activityWindow;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Money baselineBalance;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Account <span class="title function_">withoutId</span><span class="params">(Money baselineBalance, ActivityWindow activityWindow)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Account</span>(<span class="literal">null</span>, baselineBalance, activityWindow);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Account <span class="title function_">withId</span><span class="params">(AccountId accountId, Money baselineBalance, ActivityWindow activityWindow)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Account</span>(accountId, baselineBalance, activityWindow);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Money <span class="title function_">calculateBalance</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">withdraw</span><span class="params">(Money money, AccountId targetAccountId)</span>&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">deposit</span><span class="params">(Money money, AccountId sourceAccountId)</span>&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JPA를 사용하려면 계좌의 데이터베이스 상태를 표현하는 @Entity 어노테이션이 추가된 클래스가 필요하다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> buckpal.adapter.persistence;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name = &quot;account&quot;)</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AccountJpaEntity</span> &#123;</span><br><span class="line"><span class="meta">@Id</span></span><br><span class="line"><span class="meta">@GeneratedValue</span></span><br><span class="line"><span class="keyword">private</span> Long id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> buckpal.adapter.persistence;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name = &quot;activity&quot;)</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ActivityJpaEntity</span> &#123;</span><br><span class="line"><span class="meta">@Id</span></span><br><span class="line"><span class="meta">@GeneratedValue</span></span><br><span class="line"><span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Column</span> <span class="keyword">private</span> LocalDataTime timestamp;</span><br><span class="line"><span class="meta">@Column</span> <span class="keyword">private</span> Long ownerAccountId;</span><br><span class="line"><span class="meta">@Column</span> <span class="keyword">private</span> Long sourceAccountId;</span><br><span class="line"><span class="meta">@Column</span> <span class="keyword">private</span> Long targetAccountId;</span><br><span class="line"><span class="meta">@Column</span> <span class="keyword">private</span> Long amount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JPA의 @ManyToOne이나 @OneToMany 어노테이션을 이용해서 ActivityJpaEntity와 AccountJpaEntity를 연결해서 관계를 표현할 수도 있었지만 데이터베이스 쿼리에 부수효과가 생길 수 있어서 일단 제외했다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">ActivityRepository</span> <span class="keyword">extends</span> <span class="title class_">JpaRepository</span>&lt;ActivityJpaEntity, Long&gt; &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Query(&quot;select a from ActivityJpaEntity a &quot; +</span></span><br><span class="line"><span class="meta">&quot;where a.ownerAccountId = :ownerAccountId &quot; +</span></span><br><span class="line"><span class="meta">&quot;and a.timestamp &gt;= :since&quot;)</span></span><br><span class="line">List&lt;ActivityJpaEntity&gt; <span class="title function_">findByOwnerSince</span><span class="params">(</span></span><br><span class="line"><span class="params"><span class="meta">@Param(&quot;ownerAccountId&quot;)</span> Long ownerAccountId,</span></span><br><span class="line"><span class="params"><span class="meta">@Param(&quot;since&quot;)</span> LocalDateTime since)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Query(&quot;select sum(a.amount) from ActivityJpaEntity a &quot; +</span></span><br><span class="line"><span class="meta">&quot;where a.targetAccountId = :accountId &quot; +</span></span><br><span class="line"><span class="meta">&quot;and a.ownerAccountId = :accountId &quot; +</span></span><br><span class="line"><span class="meta">&quot;and a.timestamp &lt; :until&quot;)</span></span><br><span class="line">Long <span class="title function_">getDepositBalanceUntil</span><span class="params">(</span></span><br><span class="line"><span class="params"><span class="meta">@Param(&quot;accountId&quot;)</span> Long accountId,</span></span><br><span class="line"><span class="params"><span class="meta">@Param(&quot;until&quot;)</span> LocalDateTime until)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Query(&quot;select sum(a.amount) from ActivityJpaEntity a &quot; +</span></span><br><span class="line"><span class="meta">&quot;where a.sourceAccountId = :accountId &quot; +</span></span><br><span class="line"><span class="meta">&quot;and a.ownerAccountId = :accountId &quot; +</span></span><br><span class="line"><span class="meta">&quot;and a.timestamp &lt; :until&quot;)</span></span><br><span class="line">Long <span class="title function_">getWithdrawalBalanceUntil</span><span class="params">(</span></span><br><span class="line"><span class="params"><span class="meta">@Param(&quot;accountId&quot;)</span> Long accountId,</span></span><br><span class="line"><span class="params"><span class="meta">@Param(&quot;until&quot;)</span> LocalDateTime until)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>스프링 부트는 이 리포지토리를 자동으로 찾고 스프링 데이터는 실제 데이터베이스와 통신하는 인터페이스 구현체를 제공한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="meta">@PersistenceAdapter</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AccountPersistenceAdapter</span> <span class="keyword">implements</span></span><br><span class="line"><span class="title class_">LoadAccountPort</span>,</span><br><span class="line">UpdateAccountStatePort &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> SpringDataAccountRepository accountRepository;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ActivityRepository activityRepository;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AccountMapper accountMapper;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Account <span class="title function_">loadAccount</span><span class="params">(</span></span><br><span class="line"><span class="params">AccountId accountId,</span></span><br><span class="line"><span class="params">LocalDateTime baselineDate)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="type">AccountJpaEntity</span> <span class="variable">account</span> <span class="operator">=</span></span><br><span class="line">accountRepository.findById(accountId.getValue())</span><br><span class="line">.orElseThrow(EntityNotFoundException::<span class="keyword">new</span>);</span><br><span class="line"></span><br><span class="line">List&lt;ActivityJpaEntity&gt; activities =</span><br><span class="line">activityRepository.findByOwnerSince(</span><br><span class="line">accountId.getValue(),</span><br><span class="line">baselineDate);</span><br><span class="line"></span><br><span class="line"><span class="type">Long</span> <span class="variable">withdrawalBalance</span> <span class="operator">=</span> orZero(activityRepository</span><br><span class="line">.getWithdrawalBalanceUntil(</span><br><span class="line">accountId.getValue(),</span><br><span class="line">baselineDate));</span><br><span class="line"></span><br><span class="line"><span class="type">Long</span> <span class="variable">depositBalance</span> <span class="operator">=</span> orZero(activityRepository</span><br><span class="line">.getDepositBalanceUntil(</span><br><span class="line">accountId.getValue(),</span><br><span class="line">baselineDate));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> accountMapper.mapToDomainEntity(</span><br><span class="line">account,</span><br><span class="line">activities,</span><br><span class="line">withdrawalBalance,</span><br><span class="line">depositBalance);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Long <span class="title function_">orZero</span><span class="params">(Long value)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> value == <span class="literal">null</span> ? <span class="number">0L</span> : value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateActivities</span><span class="params">(Account account)</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (Activity activity : account.getActivityWindow().getActivities()) &#123;</span><br><span class="line"><span class="keyword">if</span> (activity.getId() == <span class="literal">null</span>) &#123;</span><br><span class="line">activityRepository.save(accountMapper.mapToJpaEntity(activity));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>영속성 측면과의 타협 없이 풍부한 도메인 모델을 생성하고 싶다면 도메인 모델과 영속성 모델을 매핑하는 것이 좋다.</p><p>트랜잭션 경계는 어디에 위치해야 할까?</p><p>트랜잭션은 하나의 유스케이스에 대해서 일어나는 모든 쓰기 작업에 걸쳐 있어야 한다.</p><p>가장 쉬운건 @Transactional 어노테이션을 서비스 클래스에 붙여서 모든 public 메서드를 트랜잭션으로 감싸게 하는 것이다</p><p>도메인 코드에 플러그인처럼 동작하는 영속성 어댑터를 만들면 서로 분리되서 풍부한 도메인 모델을 만들 수 있고 포트의 명세만 지켜진다면 영속성 계층 전체를 교체할 수도 있다.</p>]]></content:encoded>
      
      
      <category domain="https://yoo0926.github.io/categories/book/">book</category>
      
      <category domain="https://yoo0926.github.io/categories/book/clean-architecture/">clean-architecture</category>
      
      
      <category domain="https://yoo0926.github.io/tags/book/">book</category>
      
      
      <comments>https://yoo0926.github.io/2023/03/25/book/clean-architecture/clean-6/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>5. 웹 어댑터 구현하기</title>
      <link>https://yoo0926.github.io/2023/03/15/book/clean-architecture/clean-5/</link>
      <guid>https://yoo0926.github.io/2023/03/15/book/clean-architecture/clean-5/</guid>
      <pubDate>Wed, 15 Mar 2023 09:14:12 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;의존성-역전&quot;&gt;의존성 역전&lt;/h3&gt;
&lt;p&gt;웹 어댑터는 인커밍 어댑터로 외부로부터 요청을 받아 애플리케이션 코어를 호출하여 어떤 일을 해야할지 알려준다. 이때 제어의 흐름은 웹 어댑터 계층의 컨트롤러에서 애플리케이션 계층의 서비스로 흐른다</description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="의존성-역전">의존성 역전</h3><p>웹 어댑터는 인커밍 어댑터로 외부로부터 요청을 받아 애플리케이션 코어를 호출하여 어떤 일을 해야할지 알려준다. 이때 제어의 흐름은 웹 어댑터 계층의 컨트롤러에서 애플리케이션 계층의 서비스로 흐른다. 애플리케이션 계층은 서비스와 통신할 수 있는 특정 포트를 중간 계층으로 구현하고 웹 어댑터는 이러한 포트를 호출할 수 있다.</p><ul><li><a href="http://addapter.in.web">addapter.in.web</a> → <a href="http://application.port.in">application.port.in</a> ← application.service<ul><li>컨트롤러 → <interface> 포트 ← 서비스</li></ul></li></ul><p>여기서 가만히 보면 의존성 역전 원칙이 적용된 걸 알수 있는데 제어의 흐름이 왼쪽에서 오른쪽 즉, 웹 어댑터가 유스케이스를 직접 호출할수도 있다.</p><ul><li><a href="http://addapter.in.web">addapter.in.web</a> → application.service<ul><li>컨트롤러 → 서비스</li></ul></li></ul><p>컨트롤러에서 서비스를 직접 호출하지 않고 포트를 두는 이유는 애플리케이션 코어가 외부와 통신할 수 있는 곳의명세가 바로 포트이기 때문이다.</p><p>포트를 적절한 위치에 구현하게 되면 외부와 어떤 통신을 하는지 명확하게 알기 쉬워 유지보수에 큰 도움이 된다.</p><h3 id="웹-어댑터의-책임">웹 어댑터의 책임</h3><p>일반적으로 웹 어댑터는 다음과 같은 일을 한다.</p><ol><li>HTTP 요청을 자바 객체로 매핑</li><li>권한 검사</li><li>입력 유효성 검증</li><li>입력을 유스케이스의 입력 모델로 매핑</li><li>유스케이스 호출</li><li>유스케이스의 출력을 HTTP로 매핑</li><li>HTTP 응답을 반환</li></ol><p>이 과정에서 한가지라도 예외가 발생하면 웹 어댑터는 오류를 반환단다.</p><p>웹 어댑터에 많은 기능과 책임이 들어간거 같지만 이것들은 모두 애플리케이션 계층에서 신경쓰면 안되는 것들이다.</p><p>HTTP와 관련된 로직을 애플리케이션 계층에서 알게 된다면 HTTP가 아닌 다른 통신방식을 사용하는 인커밍 포트를 구현할 때 동일한 도메인 로직을 수행할 수 없게 된다.</p><h3 id="컨트롤러-나누기">컨트롤러 나누기</h3><p>스프링 MVC 프레임워크에서는 위에서 언급한 책임들을 수행할 컨트롤러 클래스를 구현할 수 있다. 웹 어댑터를 구성할땐 하나의 클래스에 많은 기능을 담기보단 가능하면 최대한 기능을 작게 분할하여 여러 개의 어댑터로 구성하는 편이 좋다.</p><p>계좌와 관련된 REST API를 설계한다고 할때 보통 AccountController 클래스를 만들게 된다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountController</span>&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/accounts&quot;)</span></span><br><span class="line">List&lt;AccountResource&gt; <span class="title function_">listAccounts</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;/accounts/&#123;id&#125;&quot;)</span></span><br><span class="line">AccountResource <span class="title function_">getAccount</span><span class="params">(<span class="meta">@PathVariable(&quot;accountId&quot;)</span> Long accountId)</span> &#123;&#125; </span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;/accounts/&#123;id&#125;/balance&quot;)</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">getAccountBalance</span><span class="params">(<span class="meta">@PathVariable(&quot;accountId&quot;)</span> Long accountId)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@PostMapping(&quot;/accounts&quot;)</span></span><br><span class="line">AccountResource <span class="title function_">createAccount</span><span class="params">(<span class="meta">@RequestBody</span> AccountResource account)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@PostMapping(&quot;/accounts/send/&#123;sourceAccountId&#125;/&#123;targetAccountId&#125;/&#123;amount&#125;&quot;)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">sendMoney</span><span class="params">(</span></span><br><span class="line"><span class="params"><span class="meta">@PathVariable(&quot;sourceAccountId&quot;)</span> Long sourceAccountId;</span></span><br><span class="line"><span class="params"><span class="meta">@PathVariable(&quot;targetAccountId&quot;)</span> Long targetAccountId;</span></span><br><span class="line"><span class="params"><span class="meta">@PathVariable(&quot;amount&quot;)</span> Long amount)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Account와 관련된 모든 기능이 하나의 컨트롤러에서 처리되서 효율적이고 괜찮게 보일 수 있지만 몇가지 단점이 있다.</p><ol><li>클래스의 코드는 적을수록 좋다.<br>하나의 클래스에 너무 많은 코드가 있다면 시간이 지나면서 늘어나는 코드 그 이상으로 파악하는 것에 난이도가 높아진다. 이것은 메서드를 아무리 깔끔하게 분리해놔도 쉽지 않다.<br>또한 테스트 코드를 작성하더라도 프로덕션 코드에 비해 더 추상적인 테스트 코드의 특성상 클래스 단위를 작게 해야 찾기 쉬워진다.</li><li>가장 중요한 부분은 모델의 재사용을 촉진한다는 점이다.<br>위 코드는 AccountResource 라는 단일 모델 클래스를 공유하는데 여기에 연산에 필요한 모든 데이터를 담다보면 특정 연산에선 필요없는 필드도 생길수 밖에 없다.<br>새로운 기능을 추가하거나 기존 기능을 수정할때 불필요한 필드에 대한 고민이 들어가면서 난이도만 늘어날뿐이다.</li></ol><p>따라서 가급적 별도의 패키지 안에 별도의 컨트롤러를 만드는 방식이 좋다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SendMoneyController</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> SendMoneyUseCase;</span><br><span class="line"></span><br><span class="line"><span class="meta">@PostMapping(&quot;/accounts/send/&#123;sourceAccountId&#125;/&#123;targetAccountId&#125;/&#123;amount&#125;&quot;)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">sendMoney</span><span class="params">(</span></span><br><span class="line"><span class="params"><span class="meta">@PathVariable(&quot;sourceAccountId&quot;)</span> Long sourceAccountId,</span></span><br><span class="line"><span class="params"><span class="meta">@PathVariable(&quot;targetAccountId&quot;)</span> Long targetAccountId,</span></span><br><span class="line"><span class="params"><span class="meta">@PathVaribale(&quot;amount&quot;)</span> Long amount)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="type">SendMoneyCommand</span> <span class="variable">command</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SendMoneyCommand</span>(<span class="keyword">new</span> <span class="title class_">AccountId</span>(sourceAccountId), <span class="keyword">new</span> <span class="title class_">AccountId</span>(targetAccountId), Money.of(amount));</span><br><span class="line">sendMoneyUseCase.sendMoney(command);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>각 컨트롤러는 Create, Update와 같은 컨트롤러 자체의 모델을 가지고 있거나, 원시값을 받아도 된다.</p><p>이러한 전용모델 클래스는 컨트롤러의 패키지에 private 으로 선언할 수 있어서 다른 곳에서 재사용될 일이 없고 다른 컨트롤러에서 사용할때도 한번 더 생각해볼 수 있게 된다.</p><p>웹어댑터를 구현할 땐 HTTP요청이 어플리케이션의 유스케이스 호출로 변환하고 결과를 다시 HTTP로 변환하여 어떠한 도메인 로직도 수행하지 않도록 구현해야 한다.</p>]]></content:encoded>
      
      
      <category domain="https://yoo0926.github.io/categories/book/">book</category>
      
      <category domain="https://yoo0926.github.io/categories/book/clean-architecture/">clean-architecture</category>
      
      
      <category domain="https://yoo0926.github.io/tags/book/">book</category>
      
      
      <comments>https://yoo0926.github.io/2023/03/15/book/clean-architecture/clean-5/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>4. 유스케이스 구현하기</title>
      <link>https://yoo0926.github.io/2023/03/05/book/clean-architecture/clean-4/</link>
      <guid>https://yoo0926.github.io/2023/03/05/book/clean-architecture/clean-4/</guid>
      <pubDate>Sun, 05 Mar 2023 08:14:21 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;앞서 설계한 패키지대로 코드를 작성하면 애플리케이션, 웹, 영속성 계층이 아주 느슨하게 결합돼 있기 때문에 필요한 대로 도메인 코드를 자유롭게 모델링할 수 있다.&lt;/p&gt;
&lt;p&gt;육각형 아키텍처는 도메인 중심의 아키텍처에 적합하기 때문에 도메인 엔티</description>
        
      
      
      
      <content:encoded><![CDATA[<p>앞서 설계한 패키지대로 코드를 작성하면 애플리케이션, 웹, 영속성 계층이 아주 느슨하게 결합돼 있기 때문에 필요한 대로 도메인 코드를 자유롭게 모델링할 수 있다.</p><p>육각형 아키텍처는 도메인 중심의 아키텍처에 적합하기 때문에 도메인 엔티티를 만드는 것으로 시작한 후 해당 도메인 엔티티를 중심으로 유스케이스를 구현한다.</p><h3 id="유스케이스-둘러보기">유스케이스 둘러보기</h3><p>유스케이스는 일반적으로 아래와 같은 단계를 따른다.</p><ol><li>입력을 받는다</li><li>비즈니스 규칙을 검증한다</li><li>모델 상태를 조작한다</li><li>출력을 반환한다.</li></ol><p>유스케이스는 인커밍 어댑터로부터 입력을 받는데 유스케이스 코드는 도메인 로직에만 집중하고 ‘입력 유효성 검증’은 다른 곳에서 처리하는게 좋다.</p><p>그러나 유스케이스는 비즈니스 규칙을 검증할 책임이 있고 도메인 엔티티와 이 책임을 공유한다.</p><h3 id="입력-유효성-검증">입력 유효성 검증</h3><p>입력 유효성 검증이 유스케이스의 책임이 아니라도 애플리케이션 계층의 책임은 맞다. 유효성 검증을 하지 않으면 애플리케이션 코어의 바깥쪽으로부터 유효하지 않은 입력값을 받게 되고, 모델의 상태를 해칠 수 있다.</p><p><code>입력 모델(input model)</code>에서 이러한 검증을 담당해보자.</p><p>유스케이스에서 입력에 사용할 모델 클래스의 생성자 내에서 특정 조건에 위배될 경우 객체 생성 자체를 막고 예외를 던지면 될 것이다.</p><p>또한 필드에 final을 붙여서 불변 필드로 만들어 생성에 성공하면 유효한 상태를 유지하고 잘못된 상태로 변경할 수 없다는 사실을 보장할 수 있다.</p><p>사실 이런 기능들은 Bean Validation API를 사용하면 편하게 사용할 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SendMoneyCommand</span> <span class="keyword">extends</span> <span class="title class_">SelfValidating</span>&lt;SendMoneyCommand&gt; &#123;</span><br><span class="line"><span class="meta">@NotNull</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Money;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">SendMoneyCommand</span><span class="params">(Money money)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>.money = money;</span><br><span class="line">requiredGreaterThan(money, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">this</span>.validateSelf();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SelfValidating 추상 클래스는 validateSelf() 메서드를 제공하여 호출하면 필드에 지정된 Bean Validation 어노테이션(@NotNull 같은)을 검증하고 유효성 검증 규칙을 위반한 경우 예외를 던진다.</p><h3 id="생성자의-힘">생성자의 힘</h3><p>필드가 많아질 경우 빌더패턴을 도입해서 생성자를 private으로 만들고 빌더의 build() 메서드 내부에 생성자 호출을 숨길 수 있다.</p><p>다만, 만약 빌더와 생성자에 새로운 필드를 추가하고 빌더를 호출하는 코드에 새로운 필드를 추가하는 걸 깜빡하더라도 컴파일러는 이러한 시도에 대해서 경고해주지 못할 수 있다.</p><p>빌더 뒤에 숨기지 말고 생성자를 직접 사용했다면 컴파일 에러에 따라 나머지 코드에 변경사항을 반영할 수 있을 것이다.</p><ul><li><p>난 저자랑 생각이 다름</p><p>저자가 예시에서 파라미터가 20개인 생성자를 호출하는 대신 빌더를 사용하면 이러이러 하다 라고 말했는데 코드의 가독성 측면에서 빌더패턴이 훨씬 보기 좋다고 생각한다.</p><p>빌더 호출 코드에 깜빡할 경우가 얼마나 될것이며 단위테스트 과정에서 어느정도 걸러낼 수 있다고 생각된다.</p><p>오히려 생성자의 파라미터 20개가 모두 String 타입일 경우 지저분한 코드를 보는게 더 스트레스 받을거 같다.</p></li></ul><h3 id="유스케이스마다-다른-입력-모델">유스케이스마다 다른 입력 모델</h3><p>각기 다른 유스케이스에 동일한 모델을 사용하고 싶은 경우가 있다.</p><p><code>계좌 등록하기</code>와 <code>계좌 업데이트 하기</code>라는 두개의 기능을 구현할 때 계좌에 대한 등록시점에선 소유권을 체크하기 위해 계좌의 소유자 ID 필드가 무조건 필요하지만 업데이트는 계좌번호만 체크한다고 했을때 ID 필드는 null을 허용하도록 만들수 있다.</p><p>일단 불변 도메인 모델에 null을 허용하는 것부터 일단 코드 스멜이 난다고 볼수 있다.(잠재적으로 side-Effect가 발생할수도 있는 코드를 말한다.)</p><p>단일책임원칙을 고려했을 때 각 유스케이스의 전용 입력모델을 사용하는게 결합도도 낮추고 부수효과도 줄일 수 있는 방법이다. 다만, 모든 입력 데이터에 대해서 각 유스케이스 별 모델 매핑을 해줘야하는 비용이 있지만 매핑 전략에 대해선 후술 한다.</p><h3 id="비즈니스-규칙-검증하기">비즈니스 규칙 검증하기</h3><p>검증은 크게 두가지를 생각해볼 수 있다.</p><ol><li>입력 유효성 검증</li><li>비즈니스 규칙 검증</li></ol><p>둘을 구분하는 가장 실용적인 방법은 <strong>특정 검증이 도메인의 상태에 접근이 필요한지?</strong> **를 생각해보면 된다. 가령 단순히 입력 데이터의 유효성 체크는 도메인의 상태를 체크할 필요 없이 선언적으로 검증이 가능하지만 비즈니스 규칙은 좀 더 맥락을 이해하고 구현할 필요가 있다.</p><p>“출금계좌는 초과출금될 수 없다.” 라는 규칙을 검증할땐 출금계좌의 존재여부 부터 체크하는 등 도메인의 상태에 접근해야 하지만<br>”출금금액은 0보다 커야한다.” 라는 규칙은 도메인의 상태에 접근없이 입력 데이터를 단순히 체크하기만 하면 된다</p><p>비즈니스 규칙 검증은 보통 도메인 엔티티 내부에 직접 구현하는게 가장 좋다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">withDraw</span><span class="params">(Money money, AccountId targetAccountId)</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(!mayWithDraw(money))&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이렇게 하면 지켜야하는 비즈니스 로직 옆에 있기 때문에 위치를 정하기도, 추론하기도 쉽다.</p><p>만약 엔티티 내부에 위치하기 어렵다면 유스케이스에서 도메인을 사용하기 전에 검증하는 방식도 있을 것이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequriedArgsConstruct</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SendMoneyService</span> <span class="keyword">implements</span> <span class="title class_">SendMoneyUseCase</span> &#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">SendMoney</span><span class="params">(SendMoneyCommand command)</span>&#123;</span><br><span class="line">requriedSourceAccount(command.getSourceAccountId());</span><br><span class="line">requriedTargetAccount(command.getTargetAccountId());</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>유효성 검증 코드를 실행 후 오류가 발생하면 유효성 전용 예외처리를 통해 사용자</p><h3 id="풍부한-도메인-모델-vs-빈약한-도메인-모델">풍부한 도메인 모델 vs 빈약한 도메인 모델</h3><ul><li>풍부한 도메인 모델 : 애플리케이션의 코어에 있는 도메인 엔티티에 최대한 많은 로직이 담겨있다. 도메인의 상태를 변경하는 메서드를 제공하고 비즈니스 규칙 검증에 유효한 값만 허용한다.</li><li>빈약한 도메인 모델 : 도메인 엔티티는 최대한 적은 로직을 가지고 있다. 보통 getter, setter를 제외한 다른로직은 모두 유스케이스에 구현한다.</li></ul><p>결국 복잡한 비즈니스 모델이 어디에 있냐의 차이로 스타일의 차이라고 봐도 무방할 거 같다.</p><h3 id="유스케이스마다-다른-출력모델">유스케이스마다 다른 출력모델</h3><p>입력에 대한 처리가 끝나면 출력을 해야하는데 이때도 동일하게 각 유스케이스마다 다른 출력모델을 사용하는게 좋다.</p><p>어떤 출력에선 Account 모델 자체를 받고 싶어할 수도 있고, 단순히 성공실패 여부 등 boolean 값만을 받고 싶을 수도 있다.</p><p>정답은 없지만 명확한 규칙이 없다면 최대한 작은 데이터를 반환하는게 좋다. 모델 클래스를 통째로 반환하면 강한 결합이 일어나는데 한 유스케이스의 출력 모델에 새로운 필드가 추가될 경우 동일한 모델을 공유하는 다른 유스케이스에서도 해당 필드를 처리해야 하는 것처럼 영향이 있기 때문에 모델은 구체적이고 작게  결합은 약하게 하는게 좋다.</p><p>같은 이유로 도메인 엔티티 자체를 출력모델로 사용하는 것도 최대한 자제해야한다.</p><h3 id="읽기-전용-유스케이스는-어떨까">읽기 전용 유스케이스는 어떨까?</h3><p>상태를 변경할 필요 없이 단순히 DB를 조회해서 값을 반환하기만 하는 읽기 전용 유스케이스를 구현해야 할때 상태변경 유스케이스와 동일한 형식으로 만들게 되면 간단한 기능에 비해 구현해야하는 것들이 많아질 수 있다. 간단히 쿼리만 조회해야 한다면 쿼리 서비스를 만들 수 있다.</p><p>인커밍 전용 포트를 만들어서 쿼리 서비스에서 구현하는 것이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GetAccountQueryService</span> <span class="keyword">implements</span> <span class="title class_">GetAccountBalanceService</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> LoadAccountPort loadAccountPort;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Money <span class="title function_">getAccountBalance</span><span class="params">(AccountId accountId)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> loadAccountPort.loadAccount(accountId, LocalDateTime.now())</span><br><span class="line">.calculateBalance();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>쿼리서비스는 유스케이스 서비스와 동일한 방식으로 동작하는데 GetAccountBalanceQuery 라는 인커밍 포트를 구현하고, 데이터베이스로부터 실제로 데이터를 로드하기 위해 LoadAccountPort라는 아웃고잉 포트를 호출한다.</p><p>이처럼 읽기 전용 쿼리는 쓰기가 가능한 유스케이스(or 커맨드)와 코드 상에서 명확히 구분되는데 이런 방식은 CQS(Command-Query Separation)나 CQRS(Command-Query Responsibility Segregation) 같은 개념과 잘 맞는다.</p>]]></content:encoded>
      
      
      <category domain="https://yoo0926.github.io/categories/book/">book</category>
      
      <category domain="https://yoo0926.github.io/categories/book/clean-architecture/">clean-architecture</category>
      
      
      <category domain="https://yoo0926.github.io/tags/book/">book</category>
      
      
      <comments>https://yoo0926.github.io/2023/03/05/book/clean-architecture/clean-4/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>2. 의존성 역전하기</title>
      <link>https://yoo0926.github.io/2023/03/01/book/clean-architecture/clean-2/</link>
      <guid>https://yoo0926.github.io/2023/03/01/book/clean-architecture/clean-2/</guid>
      <pubDate>Wed, 01 Mar 2023 07:55:02 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;계층형 아키텍처의 대안을 이야기 하기전에 SOLID 원칙의 ‘S’와 ‘D’를 담당하는 아래 원칙들을 먼저 살펴보자.&lt;/p&gt;
&lt;h3 id=&quot;단일-책임-원칙-Single-Responsibility-Principle-SRP&quot;&gt;단일 책임 원칙(Singl</description>
        
      
      
      
      <content:encoded><![CDATA[<p>계층형 아키텍처의 대안을 이야기 하기전에 SOLID 원칙의 ‘S’와 ‘D’를 담당하는 아래 원칙들을 먼저 살펴보자.</p><h3 id="단일-책임-원칙-Single-Responsibility-Principle-SRP">단일 책임 원칙(Single Responsibility Principle, SRP)</h3><ul><li>하나의 컴포넌트는 오로지 한 가지 일만 해야 하고, 그것을 올바르게 수행해야 한다.<ul><li>이 말은 실제 의도와는 조금 다른 오해가 발생할 여지가 있으니 아래 정의가 좀 더 정확하다고 볼 수 있다.</li></ul></li><li>컴포넌트를 변경하는 이유는 오직 하나뿐이어야 한다.</li></ul><p>만약 컴포넌트를 변경할 이유가 한 가지라면 우리가 “어떤 다른 이유로” 소프트웨어를 변경하더라도 이 컴포넌트에 대해선 전혀 신경 쓸 필요가 없다.</p><p>하지만 변경할 이유라는건 컴포넌트 간의 의존성을 통해 너무 쉽게 전파된다.<br>A 컴포넌트는 B,C,D,E에 의존하고 E는 다른 의존성이 없다면<br>A는 다른 B,C,D,E가 바뀔 때 함께 바뀌어야 하지만 E는 E에 기능이 추가,변경될 때만 바뀌게 될 것이다.</p><h3 id="의존성-역전-원칙-Dependency-Inversion-Principle-DIP">의존성 역전 원칙(Dependency Inversion Principle, DIP)</h3><p>계층형에서 계층 간 의존성은 항상 다음 계층인 아래 방향을 가리킨다. 단일 책임 원칙을 고수준에서 적용할 경우 상위 계층들이 하위 계층들에 비해 변경할 이유가 더 많다.</p><p>그러므로 영속성 계층에 대한 도메인 계층의 의존성 때문에 영속성 계층을 변경할 때마다 잠재적으로 도메인 계층도 변경해야 한다. 하지만 도메인 코드는 애플리케이션에서 가장 중요한 코드인데 영속성 코드가 바뀐다고 도메인 코드까지 바꾸는게 맞을까? 이 의존성은 어떻게 제거할 수 있을까? 의존성 역전 원칙은 말 그대로의 의미이다.</p><ul><li>코드 상의 어떤 의존성이든 그 방향을 바꿀 수(역전시킬 수) 있다.<ul><li>단, 서드파티 라이브러리처럼 제어할 수 없는 코드에 의존성을 가지고 있다면 역전이 불가능하다.</li></ul></li></ul><p>일반적으로 보기 쉬운 계층형 구조의 서비스가 있다. 도메인 계층의 서비스는 영속성 계층의 엔티티와 리포지토리와 상호작용한다.</p><p>엔티티는 도메인 객체를 표현하고 도메인 코드는 이러한 엔티티의 상태를 변경하는 일을 중심으로 하니까 일단 엔티티를 도메인 계층으로 올려보면 영속성의 리포지토리가 도메인의 엔티티를 의존하는 순환의존성이 생기게 된다.</p><p style="text-align:center">  <img src="/img/book/clean-architecture/clean-2-1.jpg"></p><p>여기서 DIP를 적용하면 도메인 계층에 리포지토리에 대한 인터페이스를 만들고, 실제 리포지토리는 영속성 계층에서 구현하게 하는 것이다.</p><p style="text-align:center">  <img src="/img/book/clean-architecture/clean-2-2.jpg" style="width:500px; height:auto"></p><p>이제 도메인 계층에 인터페이스를 도입함으로써 의존성을 역전시켜서 도메인 로직은 영속성 코드에 의존하지 않고 영속성 계층이 도메인 계층에 의존하게 된다.</p><h3 id="클린-아키텍처">클린 아키텍처</h3><p>도메인 코드가 바깥으로 향하는 어떤 의존성도 없어야 함을 의미한다. 대신 의존성 역전 원칙의 도움으로 모든 의존성이 도메인 코드를 향하고 있다.</p><p>클린 아키텍처의 코어에는 주변 유스케이스에서 접근하는 도메인 엔티티들이 있다. 유스케이스는 서비스를 의미하는데 단일 책임을 갖기 위해 좀 더 세분화 시켜서 넓은 서비스 문제를 피한다.</p><p>도메인 코드에선 어떤 영속성 프레임워크나 UI 프레임워크가 사용되는지 알 수 없기 때문에 특정 프레임워크에 특화된 코드를 가질 수 없고 비즈니스 규칙에 집중할 수 있어서 자유롭게 모델링할 수 있다.</p><p>다만, 도메인 계층이 영속성이나 UI 같은 외부 계층과 철저하게 분리돼야 하므로 애플리케이션의 엔티티에 대한 모델을 각 계층에서 유지보수 해야 한다.</p><p>영속성에서 ORM을 사용하는 경우, 도메인 계층과 영속성 계층이 데이터를 주고받을 때, 두 계층에 각각 엔티티 클래스를 만들어서 서로 변환해야 하는데 이는 바람직한 방향이다.</p><p>특정 프레임워크에 특화된 문제로부터 해방시키고자 했던, 결합이 제거된 상태이다.</p><p>클린 아키텍처는 약간 추상적인 느낌이 강해서 이 원칙들을 좀 더 구체적으로 만들어주는 ‘육각형 아키텍처(헥사고날 아키텍처)’에 대해서 살펴보자.</p><h3 id="육각형-아키텍처-헥사고날-아키텍처">육각형 아키텍처(헥사고날 아키텍처)</h3><p>애플리케이션 코어가 각 어댑터와 상호작용하기 위해 특정 포트를 제공하기 때문에 ‘포트와 어댑터 아키텍처라고도 불린다. 꼭 육각형의 모양이 중요한건 아니고 팔각형이어도 상관없다.</p><p>육각형 안에는 도메인 엔티티와 이와 상호작용하는 유스케이스가 있다. 외부로 향하는 의존성이 없고 모든 의존성은 코어를 향한다.</p><p>육각형 바깥에는 웹 브라우저와 상호작용하는 웹 어댑터, 데이터베이스와 상호작용하는 영속성 어댑터, 외부 시스템와 상호작용하는 어댑터 등 애플리케이션과 상호작용하는 다양한 어댑터들이 있다.</p><p>코어와 어댑터들 간의 통신이 가능하려면 애플리케이션 코어가 각각의 포트를 제공해야 한다.</p><p>주도하는 어댑터에게는 포트가 코어에 있는 유스케이스 클래스들에  의해 구현되고 호출되는 인터페이스가 될 것이고, 주도되는 어댑터에는 어댑터에 의해 구현되고 코어에 의해 호출되는 인터페이스가 될 것이다.</p><p>이러한 아키텍처의 목적은 결국 도메인 코드가 바깥쪽 코드에 의존하지 않게 함으로써 영속성과 UI에 특화된 모든 문제로부터 도메인 로직의 결합을 제거하고 코드를 변경할 이유의 수를 줄이는 효과가 있다.</p>]]></content:encoded>
      
      
      <category domain="https://yoo0926.github.io/categories/book/">book</category>
      
      <category domain="https://yoo0926.github.io/categories/book/clean-architecture/">clean-architecture</category>
      
      
      <category domain="https://yoo0926.github.io/tags/book/">book</category>
      
      
      <comments>https://yoo0926.github.io/2023/03/01/book/clean-architecture/clean-2/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>3. 코드 구성하기</title>
      <link>https://yoo0926.github.io/2023/03/01/book/clean-architecture/clean-3/</link>
      <guid>https://yoo0926.github.io/2023/03/01/book/clean-architecture/clean-3/</guid>
      <pubDate>Wed, 01 Mar 2023 06:12:15 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;코드만 보더라도 어떤 아키텍처인지 알 수 있다면 좋지 않을까? 보통 새로운 프로젝트를 시작할 때 가장 먼저 패키지 구조를 설계하게 된다.&lt;/p&gt;
&lt;h3 id=&quot;계층으로-구성하기&quot;&gt;계층으로 구성하기&lt;/h3&gt;
&lt;p&gt;기본적인 계층형으로 프로젝트를 생성</description>
        
      
      
      
      <content:encoded><![CDATA[<p>코드만 보더라도 어떤 아키텍처인지 알 수 있다면 좋지 않을까? 보통 새로운 프로젝트를 시작할 때 가장 먼저 패키지 구조를 설계하게 된다.</p><h3 id="계층으로-구성하기">계층으로 구성하기</h3><p>기본적인 계층형으로 프로젝트를 생성한다면 아래와 같은 구조가 될 것이다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">buckpal</span><br><span class="line">    ├─domain</span><br><span class="line">    │├─Account</span><br><span class="line">    │├─Activity</span><br><span class="line">    │├─AccountRepository</span><br><span class="line">    │└─AccountService</span><br><span class="line">    ├─persistence</span><br><span class="line">    │└─AccountRepositoryImpl</span><br><span class="line">    └─web</span><br><span class="line">    └─AccountController</span><br></pre></td></tr></table></figure><p>도메인, 웹, 영속성 계층별로 패키지를 만들었고 앞서 나왔던 의존성 역전을 사용하여 domain 패키지에 AccountRepository 인터페이스를 두고 persistence 패키지에 구현체를 둬서 의존성이 도메인을 바라보도록 구성되어있다.</p><p>다만 몇가지 단점이 보이는데</p><ol><li>기능이나 특성을 구분짓는 패키지의 경계가 없다.<ul><li>새로운 기능(ex) 사용자관리)을 추가하려면 각 계층 패키지에 UserController, UserService, User 등을 추가하게 되는데 다른 기능과 섞이게 되면 예상치 못한 부수효과가 발생할 수 있다.</li></ul></li><li>애플리케이션이 어떤 유스케이스를 제공하는지 파악하기 어렵다.<ul><li>AccountController와 AccountService가 구체적으로 어떤 기능을 제공하는지 파악하려면 내부 구현 메서드를 살펴봐야 한다.</li></ul></li><li>패키지만 봐서 의도하는 아키텍처를 짐작하기 어렵다.<ul><li>육각형 아키텍처라고 추측하고 웹 어댑터와 영속성 어댑터를 찾기 위해 web, persistence 패키지를 조사해볼 순 있지만 어떤 기능이 웹어댑터에서 호출되는지, 영속성 어댑터가 도메인 계층에 어떤 기능을 제공하는지 한눈에 알 수 없다. 인커밍 포트와 아웃고잉 포트가 코드 속에 숨겨져 있다.</li></ul></li></ol><h3 id="기능으로-구성하기">기능으로 구성하기</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">buckpal</span><br><span class="line">    └─account</span><br><span class="line">    ├─Account</span><br><span class="line">    ├─AccountController</span><br><span class="line">    ├─AccountRepository</span><br><span class="line">    ├─AccountRepositoryImpl</span><br><span class="line">    └─SendMoneyService</span><br></pre></td></tr></table></figure><p>계좌 관련 기능을 모두 account 라는 패키지에 모았고 AccountService도 책임을 좁히기 위해서 SendMoneyService로 변경하였다.</p><p>이렇게 되면 ‘송금하기’ 유스케이스를 구현한 코드는 클래스명만 봐도 바로 찾을 수 있다.</p><p>하지만 기능을 기준으로 코드를 구성하면 기반 아키텍처가 명확하게 보이지 않아서 가시성이 많이 떨어진다는 큰 단점이 있다.</p><h3 id="아키텍처적으로-표현력-있는-패키지-구조">아키텍처적으로 표현력 있는 패키지 구조</h3><p>육각형 아키텍처에서 구조적으로 핵심적인 요소는 엔티티, 유스케이스, 인커밍/아웃고잉 포트, 인커밍/아웃고잉(혹은 주도하거나 주도되는) 어댑터이다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">buckpal</span><br><span class="line">    └─account</span><br><span class="line">        ├─adapter</span><br><span class="line">        │    ├─<span class="keyword">in</span></span><br><span class="line">        │    │  └─web</span><br><span class="line">        │    │     └─AccountController</span><br><span class="line">        │    ├─out</span><br><span class="line">        │    └─persistence</span><br><span class="line">        │        ├─AccountPersistenceAdapter</span><br><span class="line">        │        └─SpringDataAccountRepository</span><br><span class="line">        ├─domain</span><br><span class="line">        │    ├─Account</span><br><span class="line">        │    └─Activity</span><br><span class="line">        └─application</span><br><span class="line">              ├─SendMoneyService</span><br><span class="line">              └─port</span><br><span class="line">                  ├─<span class="keyword">in</span></span><br><span class="line">                  │  └─SendMoneyUseCase</span><br><span class="line">                  └─out</span><br><span class="line">                      ├─LoadAccountPort</span><br><span class="line">                      └─UpdateAccountStatePort</span><br></pre></td></tr></table></figure><p>도메인 모델이 속한 domain 패키지와 도메인 모델을 둘러싼 서비스 계층을 포함하는 application패키지가 있다.</p><p>SendMoneySerivce는 인커밍 포트 인터페이스인 SendMoneyUseCase를 구현 아웃고잉 포트 인터페이스이자 영속성 어댑터에 의해 구현된 LoadAccountPort와 UpdateAccountStatePort를 사용한다.</p><p>adapter 패키지는 애플리케이션 계층의 인커밍 포트를 호출하는 인커밍 어댑터와 애플리케이션 계층의 아웃고잉 포트에 대한 구현을 제공하는 아웃고잉 어댑터를 포함한다.</p><ul><li>책을 읽다가 곰곰히 생각해 봤지만<br>패키지의 구조가 표현력이 있긴한데 아직 익숙치 않아서 한눈에 들어오진 않는다. 다만, 팀원들과 이러한 아키텍처에 대한 논의가 충분히 되고 합의된 상태에서 구조를 잡는다면 코드와 아키텍처가 직접적으로 매핑되면서 추상적이던 아키텍처가 좀 더 구체적으로 파악이 가능해진거 같기도 하다.</li></ul>]]></content:encoded>
      
      
      <category domain="https://yoo0926.github.io/categories/book/">book</category>
      
      <category domain="https://yoo0926.github.io/categories/book/clean-architecture/">clean-architecture</category>
      
      
      <category domain="https://yoo0926.github.io/tags/book/">book</category>
      
      
      <comments>https://yoo0926.github.io/2023/03/01/book/clean-architecture/clean-3/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>1. 계층형 아키텍처의 문제는 무엇일까?</title>
      <link>https://yoo0926.github.io/2023/02/25/book/clean-architecture/clean-1/</link>
      <guid>https://yoo0926.github.io/2023/02/25/book/clean-architecture/clean-1/</guid>
      <pubDate>Sat, 25 Feb 2023 07:55:02 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;계층형-아키텍처란&quot;&gt;계층형 아키텍처란?&lt;/h2&gt;
&lt;p&gt;계층(layer)으로 구성된 (웹) 애플리케이션은 전통적인 웹 애플리케이션 구조를 말한다.&lt;/p&gt;
&lt;p&gt;크게보면 웹 → 도메인 → 영속성 으로 구성된 3계층으로 많이 표현되는데&lt;/p&gt;</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="계층형-아키텍처란">계층형 아키텍처란?</h2><p>계층(layer)으로 구성된 (웹) 애플리케이션은 전통적인 웹 애플리케이션 구조를 말한다.</p><p>크게보면 웹 → 도메인 → 영속성 으로 구성된 3계층으로 많이 표현되는데</p><ul><li>웹 : 요청을 받아서 서비스로 요청을 보냄</li><li>도메인(비즈니스) : 필요한 비즈니스 로직을 수행하고 엔티티의 현재 상태를 조회하거나 변경하기 위해 영속성 계층의 컴포넌트 호출</li><li>영속성 : 엔티티, 리포지터리 등 데이터베이스 관련 컴포넌트</li></ul><p>오랫동안 사용한만큼 견고한 아키텍처 패턴이 맞고 잘 이해하고 사용하면 각 계층에 독립적으로 로직을 작성하고 기존 기능에 영향없는 기능 추가도 가능하다.</p><p>다만, 계층형은 코드에 나쁜 습관들이 스며들기 쉽고 시간이 지날수록 유지보수가 힘들어지는 단점들이 있다.</p><h3 id="계층형-아키텍처는-데이터베이스-주도-설계를-유도한다">계층형 아키텍처는 데이터베이스 주도 설계를 유도한다.</h3><p>계층형의 토대는 데이터베이스라서 웹은 도메인을, 도메인은 영속성을 의존하다보니 모두 데이터베이스에  의존하게 된다.</p><p>보통 애플리케이션을 만들때 비즈니스를 관장하는 규칙이나 정책을 반영한 모델을 만드는데 이때 우리는 상태(state)가 아니라 행동(behavior)을 중심으로 모델링한다.</p><p>하지만 계층형의 설계는 보통 데이터베이스를 토대로 도메인 로직을 구현하는 방식이라서 아키텍처의 구현으로는 맞더라도 비즈니스 관점에선 다르다.</p><p>가장 중요한 도메인 로직을 먼저 만들어야 로직을 제대로 이해하는지 확인하고 이를 토대로 웹과 영속성 계층을 설계할 수 있기 때문이다.</p><p>ORM(object-relational-mapping, 객체 관계매핑) 프레임워크(JPA, 하이버네이트 등)를 사용하면 비즈니스 규칙을 영속성 관점에 섞고 싶은 생각이 들게 된다.</p><p>ORM에 의해 관리되는 엔티티들은 일반적으로 영속성 계층에 두고 도메인계층에선 엔티티에 접근가능한데 이러한 구조는 영속성 계층과 도메인 계층 사이에 강한 결합을 만들게 된다.</p><p>서비스에서 영속성 모델을 마치 비즈니스 모델처럼 사용하다보면 도메인 로직뿐만 아니라 영속성 계층과 관련된 작업들도 해줘야 한다.</p><p>영속성 코드가 사실상 도메인 코드에 녹아들면서 둘 중 하나만 바꾸는게 어려워져서 계층형의 목표와 대치되는 코드가 된다.</p><h2 id="지름길을-택하기-쉬워진다">지름길을 택하기 쉬워진다.</h2><p>계층형 아키텍처는 특정한 계층에서는 같은 계층에 있는 컴포넌트나 아래에 있는 계층에만 접근 가능하다는 규칙이 있다.</p><p>만약 상위 계층에 위치한 컴포넌트에 접근해야 한다면? 컴포넌트를 계층 아래로 내려버리면 된다. 한번은 괜찮을 수 있다. 근데 2번, 3번이 넘고 나 뿐만 아니라 다른 동료들도 그렇게 하게 되면?</p><p>유틸리티나 헬퍼 컴포넌트 등이 아래 계층으로 내려오게 되면 영속성 계층은 모든 것에 접근 가능하기 때문에 시간이 지날 수록 점점 비대해 질 것이다.</p><h3 id="테스트하기-어려워진다">테스트하기 어려워진다.</h3><p>계층형 아키텍처에서 계층을 건너뛰도록 하는 경우도 있다. 엔티티의 필드를 딱 하나만 조작하면 될 경우에 웹 계층에서 바로 영속성 계층에 접근하면 도메인 계층을 건너 뛰게 된다. 이런 경우 크게 두가지 문제가 발생하는데</p><ol><li>도메인 로직을 웹 계층에 구현하게 된다.<br>만약 유스케이스가 확장된다면 더 많은 도메인 로직이 웹 계층에 추가되면서 애플리케이션 전반으로 책임이 섞이고 핵심 도메인 로직들이 퍼져나갈 수 있다.</li><li>웹 계층 테스트에서 도메인 계층뿐만 아니라 영속성 계층도 모킹(mocking)해야 한다.<br>이 경우 단위 테스트의 복잡도가 올라가고 이렇게 복잡한 설정을 할 시간이 없어서 테스트를 안하게 되는 시작이 된다.</li></ol><h3 id="유스케이스를-숨긴다">유스케이스를 숨긴다.</h3><p>기능을 추가하거나 변경할 적절한 위치를 찾는 일이 빈번하기 때문에 ㅐ아키텍처는 코드를 빠르게 탐색하는데 도움이 돼야 한다.</p><p>계층형 아키텍처에서는 도메인 로직이 여러 계층에 걸쳐 흩어지기 쉬운 환경이라 유스케이스가 “간단”해서 도메인 계층을 생략하면 웹 계층에 존재할 수도 있고, 도메인과 영속성 모두에 접근할 수 있도록 컴포넌트의 계층을 내리면 영속성 계층에 존재할 수도 있다.</p><p>이런 경우 새로운 기능을 추가할 적당한 위치를 찾기 어려워지고 여러 개의 유스케이스를 담당하는 아주 넓은 서비스가 만들어질 수도 있다.</p><p>넓은 서비스는 영속성 계층에 많은 의존성을 갖게되고, 웹 레이어의 많은 컴포넌트가 이 서비스에 의존하게 된다. 서비스는 점점 더 복잡해지고 테스트하기도 어려워진다.</p><h3 id="동시-작업이-어려워진다">동시 작업이 어려워진다.</h3><p>새로운 기능을 추가하기 위해 3명의 개발자가 있을때 각 계층에 각각의 기능을 동시에 개발할 수 있을까?</p><p>계층형에선 영속성 계층 위에 모든 것이 만들어지기 때문에 영속성 계층을 먼저 개발ㄹ해야 하고, 그 다음에 도메인 계층, 웹 계층을 만들어야 한다.</p><p>동시에 한꺼번에가 아니라 한번에 한명의 개발자만 일할 수 있는 것이다.</p><p>또한 넓은 서비스가 있다면 서로 다른 기능을 동시에 작업하기 어려운데 병합 충돌(merge conflict)이나 롤백이 필요한 문제가 발생할 수 있다.</p><h3 id="유지보수-가능한-소프트웨어를-만드는-데-어떻게-도움이-될까">유지보수 가능한 소프트웨어를 만드는 데 어떻게 도움이 될까?</h3><p>올바르게 구축하고 몇 가지 추가적인 규칙들을 잘 적용한다면 계층형 아키텍처는 유지보수하기 매우 쉬워지며 코드를 쉽게 변경하거나 추가할 수 있다.</p><p>하지만 잘못된 방향으로 흘러가기 쉽다보니 계층형 아키텍처로 만들든 다른 아키텍처 스타일로 만들든, 지름길을 택하지 않고 유지보수하기에 더 쉬운 솔루션을 만드는 데 도움이될 것이다.</p>]]></content:encoded>
      
      
      <category domain="https://yoo0926.github.io/categories/book/">book</category>
      
      <category domain="https://yoo0926.github.io/categories/book/clean-architecture/">clean-architecture</category>
      
      
      <category domain="https://yoo0926.github.io/tags/book/">book</category>
      
      
      <comments>https://yoo0926.github.io/2023/02/25/book/clean-architecture/clean-1/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[WebFlux] Flux와 Stream의 reduce, 그리고 chatGPT</title>
      <link>https://yoo0926.github.io/2023/02/14/spring/WebFlux/spring-webflux-2/</link>
      <guid>https://yoo0926.github.io/2023/02/14/spring/WebFlux/spring-webflux-2/</guid>
      <pubDate>Tue, 14 Feb 2023 06:27:21 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;평소처럼 개발하던 중 reduce를 사용한 코드에서 오류가 발생했다.&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;</description>
        
      
      
      
      <content:encoded><![CDATA[<p>평소처럼 개발하던 중 reduce를 사용한 코드에서 오류가 발생했다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">java: cannot find symbol</span><br><span class="line">  symbol: variable accumulatedMap</span><br><span class="line"></span><br><span class="line">java: cannot find symbol</span><br><span class="line">  symbol: variable currentMap</span><br></pre></td></tr></table></figure><p>오류가 발생한 상황을 샘플코드로 대략적으로 재현해봤다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sample 1</span></span><br><span class="line">List&lt;Integer&gt; list = IntStream.range(<span class="number">0</span>,<span class="number">10</span>).boxed().collect(Collectors.toList());</span><br><span class="line"><span class="type">var</span> <span class="variable">collectMap</span> <span class="operator">=</span> list.stream()</span><br><span class="line">        .map(i -&gt; &#123;</span><br><span class="line">            Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">            map.put(<span class="string">&quot;key&quot;</span> + i, i * <span class="number">10</span>);</span><br><span class="line">            <span class="keyword">return</span> map;</span><br><span class="line">        &#125;)</span><br><span class="line">        .reduce(**Collections.emptyMap()**, (accumulatedMap, currentMap) -&gt; <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;() &#123;</span><br><span class="line">            &#123;</span><br><span class="line">                putAll(accumulatedMap);</span><br><span class="line">                putAll(currentMap);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">System.out.println(<span class="string">&quot;Stream reduce Map size: &quot;</span> + collectMap.size());</span><br><span class="line"><span class="comment">// Stream reduce Map size: 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// sample 2</span></span><br><span class="line">Flux.range(<span class="number">1</span>, <span class="number">10</span>)</span><br><span class="line">        .map(i -&gt; &#123;</span><br><span class="line">            Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">            map.put(<span class="string">&quot;key&quot;</span> + i, i * <span class="number">10</span>);</span><br><span class="line">            <span class="keyword">return</span> map;</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="comment">//.reduce(**Collections.emptyMap()** ,(accumulatedMap, currentMap) -&gt; new HashMap&lt;&gt;() &#123; // compile error!! &gt; `java: cannot find symbol`</span></span><br><span class="line">        .reduce((accumulatedMap, currentMap) -&gt; <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;() &#123;</span><br><span class="line">            &#123;</span><br><span class="line">                putAll(accumulatedMap);</span><br><span class="line">                putAll(currentMap);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        .doOnNext(map -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Flux reduce Map size: &quot;</span> + map.size());</span><br><span class="line">        &#125;)</span><br><span class="line">        .subscribe();</span><br><span class="line"><span class="comment">// Flux reduce Map size: 10</span></span><br></pre></td></tr></table></figure><p>Stream과 Flux의 reduce를 호출 시 initial 파라미터로 각각 <code>Collections.emptyMap()</code>를 사용하였으나 Stream은 정상동작하지만 Flux에선 컴파일 오류가 발생하였다.</p><p>여러 케이스로 바꿔가면서 테스트를 해보니 Collections.emptyMap()의 반환값이 불변객체라서 안되는거 같다는 추론까진 도달했지만 확신은 없었다.</p><p>구글링으로 찾아보려고 했지만 공식문서를 봐도 Flux에선 안되고 Stream에선 되는 이유에 대해서 명확한 답변을 찾기 어려워서 고민하던차에 요즘 핫한 chatGPT에 물어볼까 하는 생각이 들어서 바로 실행해봤다.</p><p>아래는 chatGPT 와 대화한 내용</p><hr><blockquote><p>i want <code>public final &lt;A&gt; Mono&lt;A&gt; reduce(A initial, BiFunction&lt;A,? super T,A&gt; accumulator)</code> example code.</p></blockquote><ul><li><p>Here’s an example of how you could use the <strong><code>reduce</code></strong> method in Spring WebFlux:</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> reactor.core.publisher.Flux;</span><br><span class="line"><span class="keyword">import</span> reactor.core.publisher.Mono;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.function.BiFunction;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReduceExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Flux&lt;Integer&gt; numbers = Flux.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        BiFunction&lt;Integer, Integer, Integer&gt; accumulator = (a, b) -&gt; a + b;</span><br><span class="line">        Mono&lt;Integer&gt; sum = numbers.reduce(<span class="number">0</span>, accumulator);</span><br><span class="line"></span><br><span class="line">        sum.subscribe(result -&gt; System.out.println(<span class="string">&quot;The sum of the numbers is: &quot;</span> + result));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This example creates a <strong><code>Flux</code></strong> of integers and then uses the <strong><code>reduce</code></strong> method to sum them up. The <strong><code>reduce</code></strong> method takes an initial value, in this case <strong><code>0</code></strong>, and a <strong><code>BiFunction</code></strong> that specifies how the current accumulation (<strong><code>a</code></strong>) is combined with each element from the flux (<strong><code>b</code></strong>) to produce the next accumulation.<br>The <strong><code>subscribe</code></strong> method is then used to subscribe to the <strong><code>Mono</code></strong> returned by <strong><code>reduce</code></strong> and print out the result.</p></li></ul><blockquote><p>initial Type is HashMap</p></blockquote><ul><li><p>Here’s an example of how you could use the <strong><code>reduce</code></strong> method with an initial value of a <strong><code>HashMap</code></strong>:</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> reactor.core.publisher.Flux;</span><br><span class="line"><span class="keyword">import</span> reactor.core.publisher.Mono;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.function.BiFunction;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReduceExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Flux&lt;String&gt; words = Flux.just(<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;cherry&quot;</span>, <span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>);</span><br><span class="line"></span><br><span class="line">        BiFunction&lt;HashMap&lt;String, Integer&gt;, String, HashMap&lt;String, Integer&gt;&gt; accumulator = (map, word) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (!map.containsKey(word)) &#123;</span><br><span class="line">                map.put(word, <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                map.put(word, map.get(word) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> map;</span><br><span class="line">        &#125;;</span><br><span class="line">        Mono&lt;HashMap&lt;String, Integer&gt;&gt; wordCounts = words.reduce(<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(), accumulator);</span><br><span class="line"></span><br><span class="line">        wordCounts.subscribe(result -&gt; System.out.println(<span class="string">&quot;The word counts are: &quot;</span> + result));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This example creates a <strong><code>Flux</code></strong> of strings and uses the <strong><code>reduce</code></strong> method to count the occurrences of each word. The <strong><code>reduce</code></strong> method takes an initial value, in this case a new empty <strong><code>HashMap</code></strong>, and a <strong><code>BiFunction</code></strong> that specifies how the current <strong><code>HashMap</code></strong> (<strong><code>map</code></strong>) is combined with each word from the flux (<strong><code>word</code></strong>) to produce the next <strong><code>HashMap</code></strong>.<br>The <strong><code>subscribe</code></strong> method is then used to subscribe to the <strong><code>Mono</code></strong> returned by <strong><code>reduce</code></strong> and print out the result.</p></li></ul><blockquote><p>Why does <code>Mono&lt;HashMap&lt;String, Integer&gt;&gt; wordCounts = words.reduce(Collections.emptyMap(), accumulator);</code> error occur?</p></blockquote><ul><li><p>The error occurs because <strong><code>Collections.emptyMap()</code></strong> returns an unmodifiable map, which means you can’t modify it. The <strong><code>reduce</code></strong> method expects the accumulator function to modify the accumulator object, which is not possible with an unmodifiable map.<br>You can resolve the issue by creating a new empty <strong><code>HashMap</code></strong> as the initial value instead of using <strong><code>Collections.emptyMap()</code></strong>, like this:</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mono&lt;HashMap&lt;String, Integer&gt;&gt; wordCounts = words.reduce(<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(), accumulator);</span><br></pre></td></tr></table></figure><p>This will give you a modifiable map that can be updated by the accumulator function as required by the <strong><code>reduce</code></strong> method.</p></li></ul><blockquote><p>But why does Java Stream API succeed?</p></blockquote><ul><li>The Java Stream API allows you to use the <strong><code>reduce</code></strong> method with an initial value of <strong><code>Collections.emptyMap()</code></strong> because the <strong><code>reduce</code></strong> operation in the Stream API operates on an internal data structure that is separate from the original data source. This allows the Stream API to handle unmodifiable maps as the initial value without any issues.<br>However, in reactive programming with Spring WebFlux, the <strong><code>reduce</code></strong> method operates on the data stream directly, so you need to provide an accumulator object that is mutable. That’s why you need to use a new empty <strong><code>HashMap</code></strong> instead of <strong><code>Collections.emptyMap()</code></strong> as the initial value.</li></ul><hr><p>별로 기대하지 않았는데 원하는 내용에 대해서 생각보다 정확한 답변을 들을 수 있었다.</p><ol><li>먼저 Flux의 reduce 호출 시<code>initial</code>가 HashMap인 케이스로 샘플코드를 요청하고 Collections.emptyMap() 을 초기값으로 사용 시 왜 오류가 나는지 물어봤고<br>Collections.emptyMap()으로 생성되는 객체는 returns an unmodifiable map 즉, immutable(불변)객체인데 reduce 메서드는 초기값으로 들어온 accumulator 객체를 수정할 것으로 예상했지만 수정이 불가능한 불변객체가 들어와서 오류가 발생하는거라고 한다.</li><li>Stream의 reduce에선 왜 성공하는지? 에 대해선<br>Stream의 reduce는 원래 데이터와는 다른 별도의 내부 데이터 구조에서 동작하기 때문에 Collections.emptyMap()의 초기값으로 reduce를 사용할 수 있지만<br>리액티브 프로그래밍 기반의 WebFlux에선 데이터 스트림에서 reduce 메서드가 직접 동작하기 때문에 변경가능한 accumulator 객체를  제공해야 하므로 변경이 가능한 빈 HashMap 객체를 생성해야 한다고 답변하였다.</li></ol><p>앞으로 나의 코딩선생님이 하나 더 늘었다는 생각에 흥분되면서도 한편으론 chatGPT를 사용해서 구글의 코딩인터뷰 Level3도 통과했다는 뉴스처럼 문맥을 파악해서 의도한 바를 정확하게 알려주는 답변을 보고 소름이 돋았다.</p>]]></content:encoded>
      
      
      <category domain="https://yoo0926.github.io/categories/spring/">spring</category>
      
      <category domain="https://yoo0926.github.io/categories/spring/WebFlux/">WebFlux</category>
      
      
      <category domain="https://yoo0926.github.io/tags/spring/">spring</category>
      
      
      <comments>https://yoo0926.github.io/2023/02/14/spring/WebFlux/spring-webflux-2/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[WebFlux] publishOn과 subscribeOn</title>
      <link>https://yoo0926.github.io/2023/01/19/spring/WebFlux/spring-webflux-1/</link>
      <guid>https://yoo0926.github.io/2023/01/19/spring/WebFlux/spring-webflux-1/</guid>
      <pubDate>Thu, 19 Jan 2023 14:21:55 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;회사에서 WebFlux로 개발하면서 publishOn과 subscribeOn의 사용법이 매번 헷갈려서 최대한 간단하게 정리를 해봤다.&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutte</description>
        
      
      
      
      <content:encoded><![CDATA[<p>회사에서 WebFlux로 개발하면서 publishOn과 subscribeOn의 사용법이 매번 헷갈려서 최대한 간단하게 정리를 해봤다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Flux.range(<span class="number">1</span>,<span class="number">3</span>)</span><br><span class="line">    .subscribeOn(Schedulers.newBoundedElastic(<span class="number">1</span>,<span class="number">1</span>,<span class="string">&quot;sub2&quot;</span>))</span><br><span class="line">    .doOnNext(i -&gt; log.info(<span class="string">&quot;main 1: &#123;&#125;, number: &#123;&#125;&quot;</span>, Thread.currentThread().getName(), i))</span><br><span class="line">    .publishOn(Schedulers.newBoundedElastic(<span class="number">1</span>,<span class="number">1</span>,<span class="string">&quot;pub1&quot;</span>))</span><br><span class="line">    .doOnNext(i -&gt; log.info(<span class="string">&quot;main 2: &#123;&#125;, number: &#123;&#125;&quot;</span>, Thread.currentThread().getName(), i))</span><br><span class="line">    .subscribeOn(Schedulers.newBoundedElastic(<span class="number">1</span>,<span class="number">1</span>,<span class="string">&quot;sub1&quot;</span>))</span><br><span class="line">    .subscribe();</span><br><span class="line"></span><br><span class="line"><span class="comment">// log</span></span><br><span class="line">main <span class="number">1</span>: sub2-<span class="number">3</span>, number: <span class="number">1</span></span><br><span class="line">main <span class="number">1</span>: sub2-<span class="number">3</span>, number: <span class="number">2</span></span><br><span class="line">main <span class="number">1</span>: sub2-<span class="number">3</span>, number: <span class="number">3</span></span><br><span class="line">main <span class="number">2</span>: pub1-<span class="number">2</span>, number: <span class="number">1</span></span><br><span class="line">main <span class="number">2</span>: pub1-<span class="number">2</span>, number: <span class="number">2</span></span><br><span class="line">main <span class="number">2</span>: pub1-<span class="number">2</span>, number: <span class="number">3</span></span><br></pre></td></tr></table></figure><h3 id="subscribeOn">subscribeOn</h3><p>subscribeOn은 호출된 곳의 앞쪽 publisher 체인과 뒷쪽의 subscriber 체인을 한꺼번에 별도의 스레드로 분리한다.<br>느린 publisher 와 빠른 subscriber 의 조합에서 쓰기 적합하다고 하는데… 무슨 말인지 잘 모르겠다. 외부서비스에서 데이터를 읽어올때 쓰기 좋다고 한다.</p><p>위 예시처럼 subscribeOn을 동일한 체인에서 중첩해서 사용할 경우<br>첫번째 subscribeOn 앞뒤 체인을 묶어서 sub2 스케줄러에서 담당하고<br>두번째 subscribeOn 앞뒤 체인을 묶어서 sub1 스케줄러가 담당해야 하지만 이미 sub2에서 담당해서 그대로 sub2로 돌게 된다.</p><h3 id="publishOn">publishOn</h3><p>publishOn은 호출된 곳의 앞쪽 publisher 체인은 그대로 두고 뒷쪽 subscriber 체인만 별도의 스레드로 분리한다.<br>빠른 publisher와 느린 subscriber 일때 쓰기 좋다고 하고 외부서비스로 데이터를 쓰는 작업할 때 좋닫고 한다.<br>위 예시에서 subscribeOn으로 sub2 스레드에서 돌다가 publishOn을 만나면서 pub1 스케줄러에 작업을 할당하고 나머지 연산을 진행한다.</p><p>🔗 출처<br><a href="https://wiki.terzeron.com/Programming/Java/Reactor_Flux%EC%9D%98_publishOn_subscribeOn%EC%9D%84_%EC%9D%B4%EC%9A%A9%ED%95%9C_%EC%8A%A4%EC%BC%80%EC%A5%B4%EB%A7%81">Reactor Flux의 publishOn subscribeOn을 이용한 스케쥴링</a></p>]]></content:encoded>
      
      
      <category domain="https://yoo0926.github.io/categories/spring/">spring</category>
      
      <category domain="https://yoo0926.github.io/categories/spring/WebFlux/">WebFlux</category>
      
      
      <category domain="https://yoo0926.github.io/tags/spring/">spring</category>
      
      
      <comments>https://yoo0926.github.io/2023/01/19/spring/WebFlux/spring-webflux-1/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
