<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>하루하루 끄적끄적</title>
    <link>https://yoo0926.github.io/</link>
    
    <atom:link href="https://yoo0926.github.io/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>티끌모아 태산이라 티끌부터 모아본다.</description>
    <pubDate>Sun, 21 Nov 2021 11:34:33 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>카카오톡 오픈그래프 캐시 삭제 방법</title>
      <link>https://yoo0926.github.io/2021/11/21/blog/ogimage-reset/</link>
      <guid>https://yoo0926.github.io/2021/11/21/blog/ogimage-reset/</guid>
      <pubDate>Sun, 21 Nov 2021 11:11:48 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;블로그 대표 이미지를 변경했음에도 카카오톡에 공유 시 기존 이미지가 계속 나오는 문제가 있었다.&lt;/p&gt;
&lt;p style=&quot;text-align:center&quot;&gt;
  &lt;img src=&quot;/img/blog/ogimage-reset/link_image1.p</description>
        
      
      
      
      <content:encoded><![CDATA[<p>블로그 대표 이미지를 변경했음에도 카카오톡에 공유 시 기존 이미지가 계속 나오는 문제가 있었다.</p><p style="text-align:center">  <img src="/img/blog/ogimage-reset/link_image1.png" alt="블로그 링크 이미지 변경 전"></p><p>사이트의 소스코드의 태그를 확인해봐도, 오픈그래프 적용을 확인해볼수 있는 페이스북의 <a href="https://developers.facebook.com/tools/debug/">Sharing Debugger</a> 사이트에서도 확인했을 때 문제가 없었으니</p><p>카카오에서 이미지 캐시가 문제라고 생각되서 구글링을 해봤고 역시 삭제하는 방법을 찾을 수 있었다.</p><h2 id="삭제방법"><a href="#삭제방법" class="headerlink" title="삭제방법"></a>삭제방법</h2><ol><li><p>카카오 개발자 사이트의 초기화 도구에서 <a href="https://developers.kakao.com/tool/clear/og">OG(Open Graph) 캐시</a>로 들어간다.</p></li><li><p>개발자 계정이 없다면 카카오 계정으로 간단하게 가입하고 있으면 로그인</p></li><li><p>삭제하려는 URL을 입력하고 초기화 한다.</p></li></ol><p style="text-align:center">  <img src="/img/blog/ogimage-reset/kakao_og_cache.png" alt="og 캐시 초기화"></p><p>이제 다시 카카오톡에 링크를 공유해보면 바뀐 이미지가 나오는걸 확인할 수 있다.</p><p style="text-align:center">  <img src="/img/blog/ogimage-reset/link_image2.png" alt="블로그 링크 이미지 변경 후"></p><hr><p>참고로 open graph 라는건 html 메타 태그의 종류 중 하나로 사용자가 링크를 sns의 입력창에 입력하면 크롤러가 미리 그 웹사이트를 방문해서 HTML head의 오픈그래프 메타 데이터를 긁어온다.</p><p>og:title, og:description, og:image 등 태그의 데이터를 바탕으로 미리보기 이미지와 설명을 만들어서 보여주게 된다.</p>]]></content:encoded>
      
      
      <category domain="https://yoo0926.github.io/categories/blog/">blog</category>
      
      
      <category domain="https://yoo0926.github.io/tags/blog/">blog</category>
      
      <category domain="https://yoo0926.github.io/tags/open-graph/">open graph</category>
      
      <category domain="https://yoo0926.github.io/tags/kakaotalk/">kakaotalk</category>
      
      
      <comments>https://yoo0926.github.io/2021/11/21/blog/ogimage-reset/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Angular 개요</title>
      <link>https://yoo0926.github.io/2021/11/13/angular/%EA%B0%9C%EC%9A%94/</link>
      <guid>https://yoo0926.github.io/2021/11/13/angular/%EA%B0%9C%EC%9A%94/</guid>
      <pubDate>Sat, 13 Nov 2021 09:12:57 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;회사 프론트엔드가 Angular로 되어있는데 이쪽을 메인잡으로 일하진 않지만 프론트 개발자를 많이 채용해서 완전히 업무를 분리하기 전까지 이쪽도 어느정도 할줄 알아야 할거같아서 Angular에 대해서 공부하면서 간단히 정리해보자&lt;/p&gt;
&lt;h2 i</description>
        
      
      
      
      <content:encoded><![CDATA[<p>회사 프론트엔드가 Angular로 되어있는데 이쪽을 메인잡으로 일하진 않지만 프론트 개발자를 많이 채용해서 완전히 업무를 분리하기 전까지 이쪽도 어느정도 할줄 알아야 할거같아서 Angular에 대해서 공부하면서 간단히 정리해보자</p><h2 id="Angular❓"><a href="#Angular❓" class="headerlink" title="Angular❓"></a>Angular❓</h2><p><strong>Angular</strong>는 Google에서 만든 **SPA(Single Page Application)**방식의 프론트엔드 개발을 위한 <strong>자바스크립트 프레임워크</strong> 이다.</p><p>개발언어로 es6, Dart 등을 지원하기도 하지만 공식적으로 <code>TypeScript</code>를 권장하고 있다.</p><p>Angular 1.x 버전을 AngularJS, Angular 2 이상 버전을 Angular 라고 부른다.</p><p>AngularJS와 Angular는 하위 호환성이 없는 브레이킹 체인지를 다수 포함하여 큰 차이점이 많은데 몇가지 정리를 하자면</p><ul><li><strong>Controller</strong>와 <strong>$scope</strong> 기반에서 <code>컴포넌트 기반 개발(CBD, Component Based Development)</code>로 전환되었다.</li><li>이전보다 향상된 모듈 시스템과 DOM 제어 기능을 제공하며 API가 단순화 되었다.</li><li>주력 개발언어로 <code>TypeScript</code>를 도입하여 대규모 개발에 적합한 정적타입과 인터페이스, 제네릭 등 타입체크지원 기능을 제공한다.</li><li>ECMAScript6에서 새롭게 도입된 모듈, 클래스, ECMAScript7의 데코레이터를 지원한다.</li><li>간단한 명령어로 개발환경을 지원하여 프로젝트 스케폴딩을 생성, 실행, 빌드할 수 있는 <code>Angular CLI</code>를 제공한다.</li></ul><h2 id="Angular-장점👍"><a href="#Angular-장점👍" class="headerlink" title="Angular 장점👍"></a>Angular 장점👍</h2><ol><li><strong>컴포넌트 기반</strong>의 기능에 따라 코드분리와 재사용성이 쉬운 장점이 있다.</li><li>SPA방식으로 다른 페이지로의 <strong>전환 속도</strong>가 빠르다.</li><li><strong>프레임워크</strong>로서 개발에 필요한 대부분의 기능을 탑재하고 있다.</li></ol><h2 id="Angular-단점👎"><a href="#Angular-단점👎" class="headerlink" title="Angular 단점👎"></a>Angular 단점👎</h2><ol><li>TypeScript를 주언어로 사용하여 이에 대한 학습이 필요하고 추가로 Angular의 여러 개념들과 기능들을 익혀야 하는만큼 <strong>학습량이 높은 편</strong>이다.</li><li>웹페이지가 모두 로딩된 이후 전환은 빠른편이지만 <strong>초기 로딩 시 느린 편</strong>이다.</li><li><strong>검색엔진 최적화</strong>가 잘 되지 않아서 구글을 제외한 다른 사이트들에서 제대로 수집되지 않는 경우가 있다고 한다.</li></ol>]]></content:encoded>
      
      
      
      
      <comments>https://yoo0926.github.io/2021/11/13/angular/%EA%B0%9C%EC%9A%94/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>유클리드 호제법</title>
      <link>https://yoo0926.github.io/2021/09/02/algo/%EC%9C%A0%ED%81%B4%EB%A6%AC%EB%93%9C-%ED%98%B8%EC%A0%9C%EB%B2%95/</link>
      <guid>https://yoo0926.github.io/2021/09/02/algo/%EC%9C%A0%ED%81%B4%EB%A6%AC%EB%93%9C-%ED%98%B8%EC%A0%9C%EB%B2%95/</guid>
      <pubDate>Thu, 02 Sep 2021 06:55:17 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;유클리드 호제법(Euclidean algorithm)은 최대공약수, 최소공배수를 구하는 가장 대중적인 알고리즘으로&lt;/p&gt;
&lt;p&gt;호제법이란 두 수가 서로 상대방 수를 나누어서 결국 원하는 수를 얻는 알고리즘을 말한다.&lt;/p&gt;
&lt;blockquote&gt;</description>
        
      
      
      
      <content:encoded><![CDATA[<p>유클리드 호제법(Euclidean algorithm)은 최대공약수, 최소공배수를 구하는 가장 대중적인 알고리즘으로</p><p>호제법이란 두 수가 서로 상대방 수를 나누어서 결국 원하는 수를 얻는 알고리즘을 말한다.</p><blockquote><p>2개의 자연수 a,b에 대해서 a를 b로 나눈 나머지를 r이라고 한다면 (단, a&gt;b)<br>a와 b의 최대공야수는 b와 r의 최대공약수와 같다.</p><p>이 성질에 따라, b를 r로 나눈 나머지 r’를 구하고, 다시 r을 r’로 나눈 나머지를 구하는 과정을 반복하여 나머지가 0이 되었을 때 나누는 수가 a와 b의 최대공약수이다.</p></blockquote><p>이해하기 쉽게 예를 들어 108과 78의 최대공약수를 구해보면 아래와 같은 연산을 할 수 있다.</p><blockquote><p>108 % 78 = 30 // 큰수를 작은수로 나누고 나머지를 구하기<br>78 % 30 = 18 // 위에서 나눈수(78)를 가져와 위의 나머지로 다시 나눠서 나머지 구하기<br>30 % 18 = 12 // 반복<br>18 % 12 = 6<br>12 % 6 = 0 // 나머지가 0이 되면 이때 나눈 수가 최대공약수(=6)</p></blockquote><p>그렇다면 최소공배수는 어떻게 구할까?</p><p>최소공배수의 규칙에서 두 수 a,b가 있을 때 <code>a * b = 최대공약수 * 최소공배수</code> 라는 공식이 성립한다.</p><p>따라서 주어진 두수를 곱하고 최대공약수로 나눠준다면 그 수가 최소공배수가 될 것이다.</p><blockquote><p>108 * 78 / 6 = 1404</p></blockquote><p>이를 간단하게 코드로 구현해보면 다음과 같다.</p><script src="https://gist.github.com/yoo0926/253e8a250ea26cb1689edb8f2f58c4ac.js"></script>]]></content:encoded>
      
      
      <category domain="https://yoo0926.github.io/categories/algorithm/">algorithm</category>
      
      
      <category domain="https://yoo0926.github.io/tags/algorithm/">algorithm</category>
      
      
      <comments>https://yoo0926.github.io/2021/09/02/algo/%EC%9C%A0%ED%81%B4%EB%A6%AC%EB%93%9C-%ED%98%B8%EC%A0%9C%EB%B2%95/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>기술면접 준비(Java)</title>
      <link>https://yoo0926.github.io/2021/08/21/interview/technical-1/</link>
      <guid>https://yoo0926.github.io/2021/08/21/interview/technical-1/</guid>
      <pubDate>Sat, 21 Aug 2021 08:25:36 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;내용은 기초적인 부분이지만 막상 면접 전에 한번이라도 정리하지 않으면 용어가 바로바로 안나오는 경우도 많기 때문에 간단하게나마 정리해 보았다.&lt;/p&gt;
&lt;h2 id=&quot;OOP란&quot;&gt;&lt;a href=&quot;#OOP란&quot; class=&quot;headerlink&quot; titl</description>
        
      
      
      
      <content:encoded><![CDATA[<p>내용은 기초적인 부분이지만 막상 면접 전에 한번이라도 정리하지 않으면 용어가 바로바로 안나오는 경우도 많기 때문에 간단하게나마 정리해 보았다.</p><h2 id="OOP란"><a href="#OOP란" class="headerlink" title="OOP란"></a>OOP란</h2><p><code>객체지향 프로그래밍(Object-Oriented Programming, OOP)</code>은 컴퓨터 프로그램을 명령어의 목록으로 보는 시각에서 벗어나 여러 개의 독립된 단위, 즉 “객체”들의 모임으로 파악하고자 하는 것 입니다. 각각의 객체는 메시지를 주고받고, 데이터를 처리할 수 있으며 대표적인 특징으로 추상화, 상속, 캡슐화, 다형성이 있습니다.</p><h2 id="직렬화-serialization-란"><a href="#직렬화-serialization-란" class="headerlink" title="직렬화(serialization)란?"></a>직렬화(serialization)란?</h2><p>객체 또는 데이터를 스트림을 통해 입출력하려면 <code>바이트(byte)형태로 변환</code>하는 것이 필요한데, 이를 <code>직렬화</code> 라고 합니다. 반대로 스트림을 통해 받은 직렬화된 객체를 원래 모양으로 만드는 과정을 <code>역직렬화</code>라고 합니다.</p><h2 id="박싱과-언박싱이란"><a href="#박싱과-언박싱이란" class="headerlink" title="박싱과 언박싱이란?"></a>박싱과 언박싱이란?</h2><p><strong>기본 자료형(Primitive data type)을 Wrapper class</strong>로 바꾸어 주는 것을 <code>박싱</code>, **Wrapper class를 기본 자료형(Primitive data type)**으로 바꿔주는 것을 <code>언박싱</code> 이라고 합니다.</p><h2 id="Static에-대해서"><a href="#Static에-대해서" class="headerlink" title="Static에 대해서"></a>Static에 대해서</h2><ul><li><code>static</code> 키워드를 쓰면 객체를 생성하지 않아도 static 변수나 static 함수를 사용할 수 있습니다.</li><li>인스턴스를 생성하면 각 인스턴스는 서로 독립적이기 때문에 서로 다른 값을 유지합니다.</li><li>각 인스턴스들이 공통적으로 같은 값이 유지되어야 하는 경우 static을 붙입니다.</li><li>static 이 붙은 메서드 에서는 인스턴스 변수를 사용할 수 없습니다.</li><li>메서드 내에서 인스턴스 변수를 쓰지 않는다면 가능하면 static을 붙이는게 호출 시간이 짧아지기 때문에 효율이 높아집니다.</li><li>클래스 설계시 static 사용 지침<ul><li>클래스의 멤버변수 중 모든 인스턴스에 공통된 값을 유지해야 하는 것이 있으면 static 을 사용합니다.</li><li>메서드 중에서 인스턴스 변수를 사용하지 않는 메서드는 static 을 사용하는 것을 고려합니다.</li></ul></li></ul><h2 id="접근-제어자에-대해서"><a href="#접근-제어자에-대해서" class="headerlink" title="접근 제어자에 대해서"></a>접근 제어자에 대해서</h2><ul><li>public : 어디서든 접근 가능</li><li>protected : 동일 패키지 혹은 상속받은 외부 패키지 클래스에서 사용</li><li>(default) : 동일 패키지 내에서만 접근 가능</li><li>private : 해당 클래스 내에서만 접근 가능</li></ul><h2 id="String-vs-StringBuffer-vs-StringBuilder"><a href="#String-vs-StringBuffer-vs-StringBuilder" class="headerlink" title="String vs StringBuffer vs StringBuilder"></a>String vs StringBuffer vs StringBuilder</h2><ul><li>String<ul><li><code>immutable(불변)</code></li><li>객체를 한 번 할당할시 <strong>메모리 공간에 변동이 없습니다</strong>.</li><li>동기화를 신경쓰지 않아도 됩니다.</li><li>엄청나게 많은 문자열을 선언 및 연산할 시 성능저하를 고려해야합니다.</li></ul></li><li>StringBuffer<ul><li><code>mutable(가변)</code></li><li>멀티스레드 환경에서도 <strong>동기화를 지원(Thread-safe)</strong></li></ul></li><li>StringBuilder<ul><li><code>mutable(가변)</code></li><li>동기화를 지원하지 <strong>않습니다</strong>.</li></ul></li><li>정리하면 적은 양의 문자열의 선언 후 연산이 필요없다면 String을 사용하고 문자열의 선언이 많이 필요하거나 연산이 필요한데 싱글스레드 환경이라면 StringBuilder를, 멀티스레드 환경이라면 StringBuffer를 사용합니다.</li></ul><h2 id="Java8-특징은"><a href="#Java8-특징은" class="headerlink" title="Java8 특징은?"></a>Java8 특징은?</h2><p>java에 <code>함수형 프로그래밍</code>이 처음으로 도입된 버전으로 새로 도입된 주요 기능으론<code>Lamda 표현식</code>, <code>Stream API</code>, <code>Optional Class</code> 같은 게 있습니다.</p><ul><li><p><strong>람다(Lamda) 표현식</strong></p><ul><li>익명함수로 이름과 식별자가 없는 함수를 말합니다. 불필요한 코드를 줄이고 가독성을 향상시키기 위함입니다.</li></ul>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list.forEach(num -&gt; System.out.println(<span class="string">&quot;number : &quot;</span> + num));</span><br></pre></td></tr></table></figure></li><li><p><strong>StreamAPI</strong></p><ul><li>람다식을 적용해서 컬렉션같은 데이터 처리연산을 하기 위한 api로 멀티 스레드를 활용해서 병렬로 연산을 수행할 수 있고, 원본 데이터를 변경하지 않는 특징이 있고 코드가 매우 간단해진다는 것을 알 수 있습니다.</li></ul></li><li><p><strong>Optional Class</strong></p><ul><li>util 패키지에 속하며 <code>NullPointException</code>을 관리하기 위해 null이 될 수 있는 객체를 감싸고 있는 래퍼 클래스입니다.</li><li>명시적으로 해당 변수가 null일 수 있음을 표현하면서 null 체크를 직접하지 않아도 됩니다.</li><li>아래는 일반적으로 많이 사용되는 optional 예제코드</li></ul>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">UserEntity</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">Optional&lt;UserEntity&gt; <span class="title">findByName</span><span class="params">(String Name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String name = <span class="string">&quot;jay&quot;</span>;</span><br><span class="line">UserEntity optUserEntity = userRepository.findByName(name)</span><br><span class="line">          .orElseThrow(() -&gt; <span class="keyword">new</span> EmptyDataException(<span class="string">&quot;해당 이름을 가진 유저가 없습니다.&quot;</span>));</span><br></pre></td></tr></table></figure></li></ul><h2 id="try-with-resource란"><a href="#try-with-resource란" class="headerlink" title="try-with-resource란?"></a>try-with-resource란?</h2><p>try-with-resources는 java7 이후 추가되었으며 <code>자동으로 자원을 해제해주는 기능</code>입니다.<br>try 구문에 <code>AutoCloseable 인터페이스</code>를 구현하는 객체를 리소스로 선언하고 사용이 끝나면 자동으로 close 해주는 기능입니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (Scanner scanner = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> File(<span class="string">&quot;newFile.txt&quot;</span>)))</span><br><span class="line">&#123;</span><br><span class="line">  System.out.println(scanner.nextLine());</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">  e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="오버로딩-오버라이딩-차이점은"><a href="#오버로딩-오버라이딩-차이점은" class="headerlink" title="오버로딩 오버라이딩 차이점은?"></a>오버로딩 오버라이딩 차이점은?</h2><p>자바에서 다형성을 지원하는 방법으로 오버로딩과 오버라이딩이 있습니다.</p><p>(다형성(polymorphism) : 하나의 객체가 여러타입을 가지는 것)</p><ul><li>오버로딩(Overloading)은 <code>같은 이름</code>의 메소드를 여러 개 가지면서 <code>매개변수의 유형과 개수가 다르도록</code> 작성하여 다양한 유형의 호출에 응답하도록 하는 것입니다.<ul><li>프로그램의 가독성 ⬆</li></ul></li><li>오버라이딩(Overriding)은 상위클래스가 가진 메소드를 <code>자식클래스에서 재정의</code> 하여 사용하는 것을 말합니다.<ul><li>하나의 코드로 여러 객체를 처리할 수 있는 장점이 있어서 사용</li></ul></li></ul><table><thead><tr><th>명칭</th><th>메소드명</th><th>매개변수</th><th>리턴타입</th></tr></thead><tbody><tr><td>오버로딩</td><td>같음</td><td>다름</td><td>같아도되고 달라도됨</td></tr><tr><td>오버라이딩</td><td>같음</td><td>같음</td><td>같아야함</td></tr></tbody></table><h2 id="HashMap-LinkedHashMap-TreeMap-비교"><a href="#HashMap-LinkedHashMap-TreeMap-비교" class="headerlink" title="HashMap, LinkedHashMap, TreeMap 비교"></a>HashMap, LinkedHashMap, TreeMap 비교</h2><ol><li>HashMap<ul><li>내부적으로 Entry의 array로 되어있고 해당 array에 index는 내부 해쉬 함수를 통해 계산합니다.</li><li>hashing을 사용하기 때문에 많은 양의 데이터를 검색하는데 뛰어난 성능을 가지고 있지만 내부 해시값에 따라서 키순서가 정해져서 특정 순서나 규칙없이 출력됩니다.</li></ul></li><li>LinkedHashMap<ul><li>내부적으로 LinkedList 형태로 저장되며 입력된 데이터의 순서를 유지할 수 있습니다.</li><li>HashMap과 기본적으로 기능은 동일하지만 순서를 유지하는 기능이 추가되면서 메모리 사용량이 더 높습니다.</li></ul></li><li>TreeMap<ul><li>Key값에 따라서 자동으로 Sort가 되는 방식이며 동기화(synchronized) 처리가 되어있어 Thread-safe 합니다.</li><li>HashMap과 다르게 키값으로 null을 허용하지 않고 내부적으로 red black tree 구조로 데이터를 저장합니다.<ul><li>red black tree 는 기존의 이진트리의 각 노드에 색깔을 저장하는 공간을 추가해서 색깔을 기준으로 균형을 맞추는 트리입니다.</li></ul></li><li>키값에 대한 Compartor(콤퍼레이터) 구현으로 정렬 순서를 변경할 수 있습니다.</li></ul></li></ol><p>정리하자면</p><ul><li>특별한 사유가 없다면 검색성능이 가장 좋은 HashMap 사용</li><li>순서를 보장하고 싶다면 LinkedHashMap 사용</li><li>키값을 일정하게 iterate 하고자한다면 TreeMap 사용</li></ul><h2 id="interface-vs-abstract"><a href="#interface-vs-abstract" class="headerlink" title="interface vs abstract"></a>interface vs abstract</h2><ul><li><p>공통점</p><ul><li>선언만 있고 구현 내용이 없습니다.</li><li>스스로 객체를 생성할 수 없지만 추상클래스를 <code>extends</code> 받거나, interface를 <code>implements</code>한 자식들만 객체를 생성할 수 있습니다.</li></ul></li><li><p><code>interface(인터페이스)</code></p><ul><li>다중 상속 가능</li><li>추상 메서드, 상수만 선언 가능(java8부터 default메서드 사용 가능)</li><li>생성자, 일반 변수를 가질 수 없음</li><li>서로 관련성이 없는 클래스들이 인터페이스를 구현하게 되는 경우</li><li>특정 데이터 타입의 행동을 명시하고 싶은데, 어디서 구현되든지 상관없을 때</li><li>다중상속을 허용하고 싶을 때</li></ul></li><li><p><code>abstract(추상 클래스)</code></p><ul><li>다중 상속 불가</li><li>추상 메서드 1개 이상, 일반 변수, 일반 메서드 선언 가능</li><li>생성자, 일반 변수 가질 수 있음</li><li>관련성이 높은 클래스간에 코드를 공유하고 싶은 경우</li><li>상속받은 클래스들이 공통적으로 가지는 메서드와 필드가 많거나, public 이외의 접근제어자 사용이 필요한 경우 사용할 수 있습니다.</li></ul></li></ul><h2 id="자바-메모리-구조"><a href="#자바-메모리-구조" class="headerlink" title="자바 메모리 구조"></a>자바 메모리 구조</h2><ul><li>메서드(Method) 영역<br>클래스 변수의 이름, 타입, 접근 제어자 등과 같은 <code>클래스와 관련된 정보를 저장</code>하며 static 변수, 전역변수 등이 저장된다.<br>코드에서 사용되는 클래스들을 로더가 읽고 클래스 별로 분류해서 저장합니다.</li><li>스택(Stack) 영역<br><code>메서드가 실행되면</code> 스택 영역에 메소드에 대한 영역이 1개 생기며 여기에 지역변수, 매개변수, 리턴값 등이 저장된다. LIFO(Last In First Out) 방식의 메모리입니다.</li><li>힙(Heap) 영역<br>new 연산자를 통해 생성된 객체와 배열의 인스턴스를 저장되고, 메모리는 가비지 컬렉터에 의해 관리됩니다.</li></ul>]]></content:encoded>
      
      
      <category domain="https://yoo0926.github.io/categories/interview/">interview</category>
      
      
      <category domain="https://yoo0926.github.io/tags/interview/">interview</category>
      
      
      <comments>https://yoo0926.github.io/2021/08/21/interview/technical-1/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[프로그래머스] 약수의 개수와 덧셈</title>
      <link>https://yoo0926.github.io/2021/06/10/algo/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EC%95%BD%EC%88%98%EC%9D%98-%EA%B0%9C%EC%88%98%EC%99%80-%EB%8D%A7%EC%85%88/</link>
      <guid>https://yoo0926.github.io/2021/06/10/algo/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EC%95%BD%EC%88%98%EC%9D%98-%EA%B0%9C%EC%88%98%EC%99%80-%EB%8D%A7%EC%85%88/</guid>
      <pubDate>Thu, 10 Jun 2021 09:39:40 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;🔗-출처&quot;&gt;&lt;a href=&quot;#🔗-출처&quot; class=&quot;headerlink&quot; title=&quot;🔗 출처&quot;&gt;&lt;/a&gt;🔗 출처&lt;/h3&gt;&lt;p&gt;약수의 개수와 덧셈 : &lt;a href=&quot;https://programmers.co.kr/learn/cour</description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="🔗-출처"><a href="#🔗-출처" class="headerlink" title="🔗 출처"></a>🔗 출처</h3><p>약수의 개수와 덧셈 : <a href="https://programmers.co.kr/learn/courses/30/lessons/77884">https://programmers.co.kr/learn/courses/30/lessons/77884</a></p><h2 id="📔-문제설명"><a href="#📔-문제설명" class="headerlink" title="📔 문제설명"></a>📔 문제설명</h2><p>두 정수 <code>left</code>와 <code>right</code>가 매개변수로 주어집니다. <code>left</code>부터 <code>right</code>까지의 모든 수들 중에서, 약수의 개수가 짝수인 수는 더하고, 약수의 개수가 홀수인 수는 뺀 수를 return 하도록 solution 함수를 완성해주세요.</p><h2 id="✅-제한사항"><a href="#✅-제한사항" class="headerlink" title="✅ 제한사항"></a>✅ 제한사항</h2><blockquote><p>1 ≤ left ≤ right ≤ 1,000</p></blockquote><h2 id="🔍-입출력-예"><a href="#🔍-입출력-예" class="headerlink" title="🔍 입출력 예"></a>🔍 입출력 예</h2><table><thead><tr><th>left</th><th>right</th><th>result</th></tr></thead><tbody><tr><td>13</td><td>17</td><td>43</td></tr><tr><td>24</td><td>27</td><td>52</td></tr></tbody></table><h2 id="📝-풀이"><a href="#📝-풀이" class="headerlink" title="📝 풀이"></a>📝 풀이</h2><p>어떤 자연수의 약수를 구하는 가장 쉬운 방법은 자연수 N을 <code>i = 1 ~ N</code> 까지 나눠서 나머지가 0으로 나오는 i의 개수를 찾으면 된다.</p><p>이러한 경우 최소값 1 ~ 자기자신 N까지 확인하므로 <code>시간복잡도는 O(n)</code> 이 나온다.</p><h3 id="더-빠르게"><a href="#더-빠르게" class="headerlink" title="더 빠르게"></a><em>더 빠르게</em></h3><p>여기서 약수의 특성에 대해서 조금 더 생각해 본다면 항상 약수는 그 짝이 되는 수가 존재한다. (ex. 15 = 3 * 5)</p><p>즉, N의 약수들 중 두 약수의 곱이 N이 되는 약수 a,b는 반드시 존재하므로 N의 제곱근까지 약수를 구하면 그 짝이 되는 약수는 자동으로 구했다고 볼 수 있다.</p><p>이 방법을 사용하여 약수를 구하면 <code>시간복잡도는 O(n^(1/2))</code> 이 나온다.</p><script src="https://gist.github.com/yoo0926/89b73775bb6cf38cb7c355f505c7b30a.js"></script><h3 id="➕-추가"><a href="#➕-추가" class="headerlink" title="➕ 추가"></a>➕ 추가</h3><p>프로그래머스에서 올린 해설을 찾아보니 애초에 문제에서 요구하는건 모든 약수를 구하는게 아니라 <em>약수의 개수가 짝수인건 더하고 홀수인건 빼는 것</em>이라서 약수가 홀수인지 짝수인지만 구하면 된다.</p><p>약수를 구해보면 약수가 홀수라면 그 수는 약수의 제곱수로 나오므로 매개변수 left ~ right 의 제곱수만 구하면 문제를 풀 수 있다.</p>]]></content:encoded>
      
      
      <category domain="https://yoo0926.github.io/categories/algorithm/">algorithm</category>
      
      <category domain="https://yoo0926.github.io/categories/algorithm/programmers/">programmers</category>
      
      
      <category domain="https://yoo0926.github.io/tags/algorithm/">algorithm</category>
      
      <category domain="https://yoo0926.github.io/tags/programmers/">programmers</category>
      
      <category domain="https://yoo0926.github.io/tags/java/">java</category>
      
      <category domain="https://yoo0926.github.io/tags/%EC%9B%94%EA%B0%84%EC%BD%94%EB%93%9C%EC%B1%8C%EB%A6%B0%EC%A7%80/">월간코드챌린지</category>
      
      
      <comments>https://yoo0926.github.io/2021/06/10/algo/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EC%95%BD%EC%88%98%EC%9D%98-%EA%B0%9C%EC%88%98%EC%99%80-%EB%8D%A7%EC%85%88/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[프로그래머스] 신규 아이디 추천</title>
      <link>https://yoo0926.github.io/2021/05/09/algo/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EC%8B%A0%EA%B7%9C-%EC%95%84%EC%9D%B4%EB%94%94-%EC%B6%94%EC%B2%9C/</link>
      <guid>https://yoo0926.github.io/2021/05/09/algo/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EC%8B%A0%EA%B7%9C-%EC%95%84%EC%9D%B4%EB%94%94-%EC%B6%94%EC%B2%9C/</guid>
      <pubDate>Sun, 09 May 2021 05:11:19 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;🔗-출처&quot;&gt;&lt;a href=&quot;#🔗-출처&quot; class=&quot;headerlink&quot; title=&quot;🔗 출처&quot;&gt;&lt;/a&gt;🔗 출처&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;신규 아이디 추천 : &lt;a href=&quot;https://programmers.co.k</description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="🔗-출처"><a href="#🔗-출처" class="headerlink" title="🔗 출처"></a>🔗 출처</h3><blockquote><p>신규 아이디 추천 : <a href="https://programmers.co.kr/learn/courses/30/lessons/72410">https://programmers.co.kr/learn/courses/30/lessons/72410</a></p></blockquote><h2 id="📔-문제-설명"><a href="#📔-문제-설명" class="headerlink" title="📔 문제 설명"></a>📔 문제 설명</h2><p>카카오에 입사한 신입 개발자 네오는 “카카오계정개발팀”에 배치되어, 카카오 서비스에 가입하는 유저들의 아이디를 생성하는 업무를 담당하게 되었습니다. “네오”에게 주어진 첫 업무는 새로 가입하는 유저들이 카카오 아이디 규칙에 맞지 않는 아이디를 입력했을 때, 입력된 아이디와 유사하면서 규칙에 맞는 아이디를 추천해주는 프로그램을 개발하는 것입니다.<br>다음은 카카오 아이디의 규칙입니다.</p><p>아이디의 길이는 3자 이상 15자 이하여야 합니다.<br>아이디는 알파벳 소문자, 숫자, 빼기(-), 밑줄(_), 마침표(.) 문자만 사용할 수 있습니다.<br>단, 마침표(.)는 처음과 끝에 사용할 수 없으며 또한 연속으로 사용할 수 없습니다.<br>“네오”는 다음과 같이 7단계의 순차적인 처리 과정을 통해 신규 유저가 입력한 아이디가 카카오 아이디 규칙에 맞는 지 검사하고 규칙에 맞지 않은 경우 규칙에 맞는 새로운 아이디를 추천해 주려고 합니다.<br>신규 유저가 입력한 아이디가 new_id 라고 한다면,</p><blockquote><p>1단계 new_id의 모든 대문자를 대응되는 소문자로 치환합니다.<br>2단계 new_id에서 알파벳 소문자, 숫자, 빼기(-), 밑줄(_), 마침표(.)를 제외한 모든 문자를 제거합니다.<br>3단계 new_id에서 마침표(.)가 2번 이상 연속된 부분을 하나의 마침표(.)로 치환합니다.<br>4단계 new_id에서 마침표(.)가 처음이나 끝에 위치한다면 제거합니다.<br>5단계 new_id가 빈 문자열이라면, new_id에 “a”를 대입합니다.<br>6단계 new_id의 길이가 16자 이상이면, new_id의 첫 15개의 문자를 제외한 나머지 문자들을 모두 제거합니다.<br>    만약 제거 후 마침표(.)가 new_id의 끝에 위치한다면 끝에 위치한 마침표(.) 문자를 제거합니다.<br>7단계 new_id의 길이가 2자 이하라면, new_id의 마지막 문자를 new_id의 길이가 3이 될 때까지 반복해서 끝에 붙입니다.</p></blockquote><p>신규 유저가 입력한 아이디를 나타내는 new_id가 매개변수로 주어질 때, “네오”가 설계한 7단계의 처리 과정을 거친 후의 추천 아이디를 return 하도록 solution 함수를 완성해 주세요.</p><h2 id="✅-제한사항"><a href="#✅-제한사항" class="headerlink" title="✅ 제한사항"></a>✅ 제한사항</h2><blockquote><p>new_id는 길이 1 이상 1,000 이하인 문자열입니다.<br>new_id는 알파벳 대문자, 알파벳 소문자, 숫자, 특수문자로 구성되어 있습니다.<br>new_id에 나타날 수 있는 특수문자는 -_.~!@#$%^&amp;*()=+[{]}:?,&lt;&gt;/ 로 한정됩니다.</p></blockquote><h2 id="🔍-입출력-예"><a href="#🔍-입출력-예" class="headerlink" title="🔍 입출력 예"></a>🔍 입출력 예</h2><table style="width:100%">  <thead style="background-color:#a1a1a1">    <tr>      <th style="color:white">no</th>      <th style="color:white">new_id</th>      <th style="color:white">result</th>    </tr>  </thead>  <tbody>    <tr>      <td>예1</td>      <td>"...!@BaT#*..y.abcdefghijklm"</td>      <td>"bat.y.abcdefghi"</td>    </tr>    <tr>      <td>예2</td>      <td>"z-+.^."</td>      <td>"z--"</td>    </tr>    <tr>      <td>예3</td>      <td>"=.="</td>      <td>"aaa"</td>    </tr>    <tr>      <td>예4</td>      <td>"123_.def"</td>      <td>"123_.def"</td>    </tr>    <tr>      <td>예4</td>      <td>"abcdefghijklmn.p"</td>      <td>"abcdefghijklmn"</td>    </tr>  </tbody></table><h2 id="📝-풀이"><a href="#📝-풀이" class="headerlink" title="📝 풀이"></a>📝 풀이</h2><p>정규식을 사용하면 어렵지 않게 풀 수있는데 정규식을 자주 쓰진 않아서 자세한 규칙들은 블로그를 검색해보고 정규식 검증은 <a href="https://regexr.com/">https://regexr.com</a>에서 진행했다.</p><script src="https://gist.github.com/yoo0926/9131c666c3fcd1d601b1fc92f291a8b0.js"></script>]]></content:encoded>
      
      
      <category domain="https://yoo0926.github.io/categories/algorithm/">algorithm</category>
      
      <category domain="https://yoo0926.github.io/categories/algorithm/programmers/">programmers</category>
      
      
      <category domain="https://yoo0926.github.io/tags/algorithm/">algorithm</category>
      
      <category domain="https://yoo0926.github.io/tags/programmers/">programmers</category>
      
      <category domain="https://yoo0926.github.io/tags/java/">java</category>
      
      <category domain="https://yoo0926.github.io/tags/kakao/">kakao</category>
      
      
      <comments>https://yoo0926.github.io/2021/05/09/algo/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EC%8B%A0%EA%B7%9C-%EC%95%84%EC%9D%B4%EB%94%94-%EC%B6%94%EC%B2%9C/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>5.중간메모</title>
      <link>https://yoo0926.github.io/2021/04/25/spring/book/%EC%8A%A4%ED%94%84%EB%A7%81-%EB%B6%80%ED%8A%B8%EC%99%80-AWS%EB%A1%9C-%ED%98%BC%EC%9E%90-%EA%B5%AC%ED%98%84%ED%95%98%EB%8A%94-%EC%9B%B9%EC%84%9C%EB%B9%84%EC%8A%A4/5/</link>
      <guid>https://yoo0926.github.io/2021/04/25/spring/book/%EC%8A%A4%ED%94%84%EB%A7%81-%EB%B6%80%ED%8A%B8%EC%99%80-AWS%EB%A1%9C-%ED%98%BC%EC%9E%90-%EA%B5%AC%ED%98%84%ED%95%98%EB%8A%94-%EC%9B%B9%EC%84%9C%EB%B9%84%EC%8A%A4/5/</guid>
      <pubDate>Sun, 25 Apr 2021 09:08:54 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;복습 겸 다시 프로젝트 생성해서 만들어보다가 몇가지 간략히 정리&lt;/p&gt;
&lt;h2 id=&quot;1-springboot에서-html파일을-templates에서-읽도록-하기&quot;&gt;&lt;a href=&quot;#1-springboot에서-html파일을-templates에서-읽</description>
        
      
      
      
      <content:encoded><![CDATA[<p>복습 겸 다시 프로젝트 생성해서 만들어보다가 몇가지 간략히 정리</p><h2 id="1-springboot에서-html파일을-templates에서-읽도록-하기"><a href="#1-springboot에서-html파일을-templates에서-읽도록-하기" class="headerlink" title="1. springboot에서 html파일을 templates에서 읽도록 하기"></a>1. springboot에서 html파일을 templates에서 읽도록 하기</h2><p>템플릿 엔진과 관련된 의존성을 추가하면 자동으로 <code>/recourses/templates</code> 아래에서 템플릿 파일을 찾도록 하는거 같은데 원래 기본 경로는 <code>/recourses/static</code> 이다.</p><p>따라서 별다른 설정을 하지 않고 html 파일을 templates 폴더 밑에 놓고 찾으려고 하면 당연히 404 에러를 볼수 밖에 없다.</p><p>html 파일을 templates 아래에 관리하고 싶다면 몇가지 작업을 해야하는데</p><p>우선 스프링부트에서 WebMVC 설정을 유지하면서 기능을 확장하기 위해 <code>WebMvcConfigurer</code>를 <code>implements</code> 하고 <code>addResourceHandlers</code> 를 오버라이드하여 아래와 같이 작성한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addResourceHandler(<span class="string">&quot;/**&quot;</span>)</span><br><span class="line">                .addResourceLocations(<span class="string">&quot;classpath:/templates/&quot;</span>)</span><br><span class="line">                .setCacheControl(CacheControl.maxAge(<span class="number">10</span>, TimeUnit.MINUTES));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="2-application-properties-gt-application-yml-변환"><a href="#2-application-properties-gt-application-yml-변환" class="headerlink" title="2. application.properties -&gt; application.yml 변환"></a>2. application.properties -&gt; application.yml 변환</h2><p>가독성 측면에서 yaml 파일이 더 좋아보여서 기존 내용을 변환해서 쓰려다보니 naver oauth2 설정을 하면 오류가 발생한다.</p><p><code>redirect-uri: &#39;&#123;baseUrl&#125;/&#123;action&#125;/oauth2/code/&#123;registrationId&#125;&#39;</code></p><p>yaml 에서는 / (슬러시)를 그대로 쓰면 파싱 에러가 난다. 따옴표나 작은 따옴표로 감싸주면 된다.</p>]]></content:encoded>
      
      
      <category domain="https://yoo0926.github.io/categories/spring/">spring</category>
      
      <category domain="https://yoo0926.github.io/categories/spring/book/">book</category>
      
      
      <category domain="https://yoo0926.github.io/tags/spring/">spring</category>
      
      
      <comments>https://yoo0926.github.io/2021/04/25/spring/book/%EC%8A%A4%ED%94%84%EB%A7%81-%EB%B6%80%ED%8A%B8%EC%99%80-AWS%EB%A1%9C-%ED%98%BC%EC%9E%90-%EA%B5%AC%ED%98%84%ED%95%98%EB%8A%94-%EC%9B%B9%EC%84%9C%EB%B9%84%EC%8A%A4/5/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>4.머스테치로 화면 구성하기</title>
      <link>https://yoo0926.github.io/2021/04/22/spring/book/%EC%8A%A4%ED%94%84%EB%A7%81-%EB%B6%80%ED%8A%B8%EC%99%80-AWS%EB%A1%9C-%ED%98%BC%EC%9E%90-%EA%B5%AC%ED%98%84%ED%95%98%EB%8A%94-%EC%9B%B9%EC%84%9C%EB%B9%84%EC%8A%A4/4/</link>
      <guid>https://yoo0926.github.io/2021/04/22/spring/book/%EC%8A%A4%ED%94%84%EB%A7%81-%EB%B6%80%ED%8A%B8%EC%99%80-AWS%EB%A1%9C-%ED%98%BC%EC%9E%90-%EA%B5%AC%ED%98%84%ED%95%98%EB%8A%94-%EC%9B%B9%EC%84%9C%EB%B9%84%EC%8A%A4/4/</guid>
      <pubDate>Thu, 22 Apr 2021 09:08:51 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;4-머스테치로-화면-구성하기&quot;&gt;&lt;a href=&quot;#4-머스테치로-화면-구성하기&quot; class=&quot;headerlink&quot; title=&quot;4. 머스테치로 화면 구성하기&quot;&gt;&lt;/a&gt;4. 머스테치로 화면 구성하기&lt;/h1&gt;&lt;h2 id=&quot;4-1-서버-템플릿-</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="4-머스테치로-화면-구성하기"><a href="#4-머스테치로-화면-구성하기" class="headerlink" title="4. 머스테치로 화면 구성하기"></a>4. 머스테치로 화면 구성하기</h1><h2 id="4-1-서버-템플릿-엔진"><a href="#4-1-서버-템플릿-엔진" class="headerlink" title="4.1 서버 템플릿 엔진"></a>4.1 서버 템플릿 엔진</h2><p>템플릿 엔진이란, <strong>지정된 템플릿 양식과 데이터</strong>가 합쳐져 HTML문서를 출력하는 소프트웨어를 이야기한다.</p><p>서버 템플릿 엔진을 이용한 화면 생성은 서버에서 Java 코드로 문자열을 만든 뒤 이 문자열을 HTML로 변환하여 브라우저로 전달한다.</p><p>반면 클라이언트 템플릿 엔진(Vue, React 등)을 이용한 SPA(Single Page Application)은 브라우저에서 화면을 생성한다. 즉, 서버에서 이미 코드가 벗어난 경우라서</p><p>서버에서는 Json 혹은 Xml 형식의 데이터만 전달하고 클라이언트에서 조립한다.</p><p>최근엔 리액트나 뷰와 같은 자바스크립트 프레임워크에서 서버사이드렌더링을 지원하는 모습을 볼 수 있지만 그건 나중에 생각하자.</p><hr><h3 id="머스테치"><a href="#머스테치" class="headerlink" title="머스테치"></a>머스테치</h3><p>머스테치는 많은 언어를 지원하는 심플한 템플릿 엔진이다.</p><p>스프링 부트에서 공식 지원하는 템플릿 엔진으로 gradle에 의존성 한줄 추가하면 바로 사용할 수 있다.</p><p>파일위치는 기본적으로 <code>src/main/resources/templates</code>이며 이 위치에 머스테치 파일을 두면 스프링 부트에서 자동으로 로딩한다.</p><p>해당 위치에 index.mustache를 생성한 후 이 머스테치에 URL을 매핑하는데 이는 Controller에서 진행한다.</p><ul><li>IndexController</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>머스테치 스타터 의존성을 추가했기 때문에 컨트롤러에서 문자열을 반환할 때 <strong>앞의 경로와 뒤의 파일 확장자는 자동으로 지정</strong>된다.</p><p>즉, 여기선 “index”를 반환하므로 <code>src/main/resources/templates/index.mustache</code>로 전환되어 <strong>View Resolver</strong>가 처리하게 된다.</p><p>(View Resolver는 URL 요청의 결과를 전달할 타입과 값을 지정하는 관리자 격으로 볼 수 있다.)</p><hr><p>화면 구성 시 bootstrap을 사용하는데 공통된 부분에 대해선 layout을 따로 둬서 header와 footer 파일을 각각 만들어서 공통된 코드는 해당 위치에 생성한다.</p><p>여기서 <strong>페이지 로딩속도를 높이기 위해</strong> css는 header에, js는 footer에 두는데 HTML은 위에서부터 코드가 실행되기 때문에 head가 다 실행되고서야 body가 실행된다.</p><p>즉, head가 다 불러지지 않으면 사용자 쪽에선 백지 화면만 노출되며 특히 js의 용량이 크면 클수록 body 부분의 실행이 늦어지기 때문에 js는 body 하단에 두어 화면이 다 그려진 뒤에 호출하는 것이 좋다.</p><p>header와 footer를 index에 추가하는건 아래와 같다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;&gt;layout/header&#125;&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>스프링 부트로 시작하는 웹 서비스<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col-md-12&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;row&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col-md-6&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/posts/save&quot;</span> <span class="attr">role</span>=<span class="string">&quot;button&quot;</span> <span class="attr">clas</span>=<span class="string">&quot;btn btn-primary&quot;</span>&gt;</span>글 등록<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">&#123;&#123;&gt;layout/footer&#125;&#125;</span><br></pre></td></tr></table></figure><p><code>&#123;&#123;> &#125;&#125;</code> 는 현재 머스테치 파일을 기준으로 다른 파일을 가져온다.</p><p>화면의 버튼에 API를 호출하는 js파일을 작성하여 footer.mustache에 추가한다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://code.jquery.com/jquery-3.3.1.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--index.js 추가--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;/js/app/index.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>index.js 호출 코드는 절대경로(/)로 바로 시작하는데 스프링 부트는 기본적으로 <code>src/main/resources/static</code>에 위치한 자바스크립트, CSS, 이미지 등 정적 파일들은 URL에서 / 로 설정된다.</p><hr><ul><li>PostsRepository 인터페이스</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PostsRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">Posts</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Query(&quot;SELECT p FROM Posts p ORDER BY p.id DESC&quot;)</span></span><br><span class="line">    <span class="function">List&lt;Posts&gt; <span class="title">findAllDesc</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>@Query 어노테이션을 사용하면 SpringDataJpa에서 제공하지 않는 메소드를 쿼리로 직접 작성할 수 있다.</p><p>보통 규모가 있는 프로젝트에선 데이터 조회는 FK의 조인, 복잡한 조건 등으로 인해 Entity 클래스만으로 처리가 어려워 조회용 프레임워크를 추가로 사용한다.</p><p>대표적 예로 <code>querydsl</code>, jooq, MyBatis 등이 있는데 해당 프레임워크 중 하나로 조회를 하고 그 외 등록/수정/삭제 등은 SpringDataJpa를 통해 진행한다.</p><ul><li>PostsService</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="meta">@Transactional(readOnly = true)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;PostsListResponseDto&gt; <span class="title">findAllDesc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> postsRepository.findAllDesc().stream().map(PostsListResponseDto::<span class="keyword">new</span>).collect(Collectors.toList());</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>@Transactional 어노테이션에 추가된 readOnly 옵션을 true로 주면 <strong>트랜잭션 범위는 유지</strong>하되, 조회기능만 남겨두어 조회 속도가 개선되기 때문에 등록, 수정, 삭제 기능이 전혀 없는 서비스 메소드에서 사용하는 것을 추천한다.</p><hr><ul><li>IndexController</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PostsService postsService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">(Model model)</span> </span>&#123;</span><br><span class="line">        model.addAttribute(<span class="string">&quot;posts&quot;</span>, postsService.findAllDesc());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Model</p><ul><li>서버 템플릿 엔진에서 사용할 수 있는 객체를 저장할 수 있다.</li><li>여기서는 postsService.findAllDesc()로 가져온 결과를 posts로 index.mustache에 전달한다.</li></ul><hr><p>REST에서 CURD는 다음과 같이 HTTP Method에 매핑된다.</p><ul><li>생성(Create) : POST</li><li>읽기(Read) : GET</li><li>수정(Update) : PUT</li><li>삭제(Delete) : DELETE</li></ul>]]></content:encoded>
      
      
      <category domain="https://yoo0926.github.io/categories/spring/">spring</category>
      
      <category domain="https://yoo0926.github.io/categories/spring/book/">book</category>
      
      
      <category domain="https://yoo0926.github.io/tags/spring/">spring</category>
      
      
      <comments>https://yoo0926.github.io/2021/04/22/spring/book/%EC%8A%A4%ED%94%84%EB%A7%81-%EB%B6%80%ED%8A%B8%EC%99%80-AWS%EB%A1%9C-%ED%98%BC%EC%9E%90-%EA%B5%AC%ED%98%84%ED%95%98%EB%8A%94-%EC%9B%B9%EC%84%9C%EB%B9%84%EC%8A%A4/4/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>3.JPA로 데이터베이스 다루기</title>
      <link>https://yoo0926.github.io/2021/04/22/spring/book/%EC%8A%A4%ED%94%84%EB%A7%81-%EB%B6%80%ED%8A%B8%EC%99%80-AWS%EB%A1%9C-%ED%98%BC%EC%9E%90-%EA%B5%AC%ED%98%84%ED%95%98%EB%8A%94-%EC%9B%B9%EC%84%9C%EB%B9%84%EC%8A%A4/3/</link>
      <guid>https://yoo0926.github.io/2021/04/22/spring/book/%EC%8A%A4%ED%94%84%EB%A7%81-%EB%B6%80%ED%8A%B8%EC%99%80-AWS%EB%A1%9C-%ED%98%BC%EC%9E%90-%EA%B5%AC%ED%98%84%ED%95%98%EB%8A%94-%EC%9B%B9%EC%84%9C%EB%B9%84%EC%8A%A4/3/</guid>
      <pubDate>Thu, 22 Apr 2021 09:08:48 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;3-JPA&quot;&gt;&lt;a href=&quot;#3-JPA&quot; class=&quot;headerlink&quot; title=&quot;3 JPA&quot;&gt;&lt;/a&gt;3 JPA&lt;/h2&gt;&lt;p&gt;Posts 클래스는 실제 DB의 테이블과 매칭될 클래스로 &lt;code&gt;Entity 클래스&lt;/code&gt;라고 </description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="3-JPA"><a href="#3-JPA" class="headerlink" title="3 JPA"></a>3 JPA</h2><p>Posts 클래스는 실제 DB의 테이블과 매칭될 클래스로 <code>Entity 클래스</code>라고 부른다.</p><p>DB데이터에 작업할 경우 실제 쿼리를 날리기 보단 이 Entity 클래스의 수정을 통해 작업</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.jojoldu.book.springboot.domain.posts;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Builder;</span><br><span class="line"><span class="keyword">import</span> lombok.Getter;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.persistence.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1. @Entity</span></span><br><span class="line"><span class="comment">- 테이블과 링크될 클래스</span></span><br><span class="line"><span class="comment">- 기본값으로 클래스의 카멜케이스 이름을 언더스코어 네이밍(_)으로 테이블 이름을 매칭한다.</span></span><br><span class="line"><span class="comment">- ex) SalesManager.java -&gt; sales_manager table</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">아래 3개는 lombok 어노테이션</span></span><br><span class="line"><span class="comment">2. @NoArgsConstructor</span></span><br><span class="line"><span class="comment">- 기본생성자 자동추가</span></span><br><span class="line"><span class="comment">- public Posts() &#123;&#125; 와 같음</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">3. @Getter</span></span><br><span class="line"><span class="comment">- 클래스 내 모든 필드의 Getter 메소드 자동생성</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">4. @Builder</span></span><br><span class="line"><span class="comment">- 해당 클래스의 빌더 패턴 클래스를 생성</span></span><br><span class="line"><span class="comment">- 생성자 상단에 선언 시 생성자에 포함된 필드만 빌더에 포함</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Posts</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    1. @Id</span></span><br><span class="line"><span class="comment">    - PK 필드</span></span><br><span class="line"><span class="comment">    2. @GeneratedValue</span></span><br><span class="line"><span class="comment">    - PK 생성규칙</span></span><br><span class="line"><span class="comment">    - GenerationType.IDENTITY 옵션을 추가해야 auto_increment 된다.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    1. @Column</span></span><br><span class="line"><span class="comment">    - 선언하지 않더라도 해당 클래스의 필드는 모두 컬럼이 된다.</span></span><br><span class="line"><span class="comment">    - 옵션을 추가할 때만 선언해도 된다.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Column(length = 500, nullable = false)</span></span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(columnDefinition = &quot;TEXT&quot;, nullable = false)</span></span><br><span class="line">    <span class="keyword">private</span> String content;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String author;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Builder</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Posts</span><span class="params">(String title, String content, String author)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.title = title;</span><br><span class="line">        <span class="keyword">this</span>.content = content;</span><br><span class="line">        <span class="keyword">this</span>.author = author;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Entity 클래스는 Setter 메소드를 만들지 않고 해당 필드의 값 변경이 필요하면 명확히 그 목적과 의도를 나타낼 수 있는 메소드를 추가해야 한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancelOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.status = <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> 주문서비스의_취소이벤트() &#123;</span><br><span class="line">  order.cancelOrder();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>기본적인 구조는 <strong>생성자를 통해</strong> 최종값을 채운 후 DB에 삽입하는 것이고 값 변경이 필요하면 해당 이벤트에 맞는 public 메소드를 호출하여 변경하는 것을 전제로 한다.</p><p>생성시점에 값을 넣는 방법으로 생성자와 <strong>@Builder</strong>를 통해 제공되는 빌더 클래스를 사용할 수 있는데 차이점이 있다면</p><p>생성자는 new Example(b,a)처럼 파라미터의 위치를 바꾸더라도 실제 실행 전까지 문제를 찾기 어렵다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Example</span><span class="params">(String a, String b)</span></span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.a = a;</span><br><span class="line">  <span class="keyword">this</span>.b = b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>빌더를 사용한다면 어느 필드에 어떤 값을 채워야할 지 명확하게 인지할 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Example.builder()</span><br><span class="line">  .a(a)</span><br><span class="line">  .b(b)</span><br><span class="line">  .build();</span><br></pre></td></tr></table></figure><p>Posts클래스(Entity) 생성이 끝나면 해당 클래스로 Database를 접근하게 해줄 JpaRepository를 생성한다.</p><ul><li>src/main/java/com/jojoldu/book/springboot/domain/posts/PostsRepository<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.data.jpa.repository.JpaRepository;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PostsRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">Posts</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>보통 ibatis나 MyBatis 등에서 Dao라고 불리는 DB Layer 접근자를 JPA에선 Repository 라고 부르며 인터페이스로 생성한다.</li></ul><p>생성 후, <code>JpaRepository&lt;Entity 클래스, PK 타입&gt;</code> 를 상속하면 기본적인 CRUD 메소드가 자동으로 생성된다.</p><p>@Repositry 어노테이션을 추가할 필요는 없지만 Entity 클래스와 기본 Entity Repository는 함께 위치해야 한다.</p><p>생성한 Repository 를 테스트하기 위해 아래 코드를 작성하며 테스트할 기능은 <strong>save</strong>, <strong>findAll</strong> 기능이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.jojoldu.book.springboot.domain.posts;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.AfterEach;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.extension.ExtendWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit.jupiter.SpringExtension;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.assertj.core.api.Assertions.assertThat;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">별다른 설정없이 @SpringBootTest를 사용할 경우 H2 데이터베이스를 자동으로 실행한다.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@ExtendWith(SpringExtension.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PostsRepositoryTest</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    PostsRepository postsRepository;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    1. @AfterEach</span></span><br><span class="line"><span class="comment">    - Junit에서 단위테스트가 끝날 때마다 수행되는 메소드를 지정한다.</span></span><br><span class="line"><span class="comment">    - 보통은 배포 전 전체 테스트를 수행할 때 테스트간 데이터 침범을 막기 위해 사용된다.</span></span><br><span class="line"><span class="comment">    - Junit4 -&gt; 5로 넘어가면서 After -&gt; AfterEach 로 변경되었다.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@AfterEach</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cleanup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        postsRepository.deleteAll();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> 게시글저장_불러오기() &#123;</span><br><span class="line">        <span class="comment">//given</span></span><br><span class="line">        String title = <span class="string">&quot;테스트 게시글&quot;</span>;</span><br><span class="line">        String content = <span class="string">&quot;테스트 본문&quot;</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        2. postsRepository.save</span></span><br><span class="line"><span class="comment">        - 테이블 posts에 insert/update 쿼리를 실행한다.</span></span><br><span class="line"><span class="comment">        - id값이 있으면 update, 없다면 insert 쿼리가 실행된다.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        postsRepository.save(Posts.builder()</span><br><span class="line">                .title(title)</span><br><span class="line">                .content(content)</span><br><span class="line">                .author(<span class="string">&quot;jojoldu@gmail.com&quot;</span>)</span><br><span class="line">                .build());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        3. postsRepository.findAll</span></span><br><span class="line"><span class="comment">        - 테이블 posts에 있는 모든 데이터를 조회해오는 메소드</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//when</span></span><br><span class="line">        List&lt;Posts&gt; postsList = postsRepository.findAll();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//then</span></span><br><span class="line">        Posts posts = postsList.get(<span class="number">0</span>);</span><br><span class="line">        assertThat(posts.getTitle()).isEqualTo(title);</span><br><span class="line">        assertThat(posts.getContent()).isEqualTo(content);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="3-4-등록-수정-조회-API-만들기"><a href="#3-4-등록-수정-조회-API-만들기" class="headerlink" title="3.4 등록/수정/조회 API 만들기"></a>3.4 등록/수정/조회 API 만들기</h2><p>API를 만들기 위해 총 3개의 클래스가 필요하다.</p><ul><li>Request 데이터를 받을 Dto</li><li>API 요청을 받을 Controller</li><li>트랜잭션, 도메인 기능 간의 순서를 보장하는 Service</li></ul><p>여기서 Service는 <strong>비지니스 로직을 처리하는 것이 아니라</strong> 트랜잭션, 도메인 간 순서 보장의 역할만 한다.</p><p><strong>Web, Service, Repository, Dto, Domain</strong> 이 5가지 레이어에서 비지니스 처리를 담당해야 할 곳은 **<code>Domain</code>**이다.</p><p>기존에 서비스로 처리하던 방식을 <strong>트랜잭션 스크립트</strong>라고 한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Order <span class="title">cancelOrder</span><span class="params">(<span class="keyword">int</span> orderId)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//1) 데이터베이스로부터 주문정보, 결제정보, 배송정보 조회</span></span><br><span class="line">  OrdersDto order = ordersDao.selectOrders(orderId);</span><br><span class="line">  BillingDto billing = billingDao.selectBilling(orderId);</span><br><span class="line">  DeliveryDto delivery = deliveryDao.selectDelivery(orderId);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//2) 배송 취소를 해야하는지 상태값 확인</span></span><br><span class="line">  String deliveryStatus = delivery.getStatus();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//3) 만약 배송중이라면 배송취소로 변경</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="string">&quot;IN_PROGRESS&quot;</span>.equals(deliveryStatus))&#123;</span><br><span class="line">    delivery.setStatus(<span class="string">&quot;CANCEL&quot;</span>);</span><br><span class="line">    deliveryDao.update(delivery);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//4) 각 테이블에 취소 상태 Update</span></span><br><span class="line">  order.setStatus(<span class="string">&quot;CANCEL&quot;</span>);</span><br><span class="line">  orderDao.update(order);</span><br><span class="line"></span><br><span class="line">  billing.setStatus(<span class="string">&quot;CANCEL&quot;</span>);</span><br><span class="line">  deliveryDao.update(billing);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> order;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>모든 로직이 서비스 클래스 내부에서 처리된다면 <strong>서비스 계층이 무의미하며, 객체란 단순히 데이터 덩어리</strong> 역할만 하게 된다.</p><p>반면 도메인 모델에서 처리할 경우 아래와 같은 코드가 될 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function">Public Order <span class="title">cancelOrder</span><span class="params">(<span class="keyword">int</span> orderId)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//1)</span></span><br><span class="line">  OrdersDto order = ordersDao.selectOrders(orderId);</span><br><span class="line">  BillingDto billing = billingDao.selectBilling(orderId);</span><br><span class="line">  DeliveryDto delivery = deliveryDao.selectDelivery(orderId);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//2-3)</span></span><br><span class="line">  delivery.cancel();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//4)</span></span><br><span class="line">  order.cancel();</span><br><span class="line">  billing.cancel();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> order;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>order, billing, delivery가 각자 본인의 취소 이벤트 처리를 하며, 서비스 메소드는 트랜잭션과 도메인 간의 순서만 보장해 준다.</p><hr><p>스프링에서 Bean을 주입하는 방식은 다음과 같다.</p><ul><li>@Autowired</li><li>setter</li><li>생성자</li></ul><p>가장 권장하는 방식은 <strong>생성자로 주입</strong>받는 방식이며 @Autowired는 권장하지 않는다.</p><p>아래 Service 코드에서 생성자는 직접 쓰지 않고 <strong>@RequiredArgsConstructor</strong>어노테이션에서 해결해 준다.</p><p>final이 선언된 모든 필드를 인자값으로 하는 생성자를 롬북에서 대신 생성해준다.</p><p>이처럼 어노테이션을 사용하는 이유는 해당 클래스의 의존성 관계가 변경될 때마다 생성자 코드를 변경하는 수고를 덜기 위함이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.jojoldu.book.springboot.domain.posts.PostsRepository;</span><br><span class="line"><span class="keyword">import</span> com.jojoldu.book.springboot.web.dto.PostsSaveRequestDto;</span><br><span class="line"><span class="keyword">import</span> lombok.RequiredArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.annotation.Transactional;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PostsService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PostsRepository postsRepository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">save</span><span class="params">(PostsSaveRequestDto requestDto)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> postsRepository.save(requestDto.toEntity()).getId();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Controller와 Service에서 사용할 Dto 클래스는 언듯 Entity 클래스와 유사한 형태지만 추가로 생성해야한다.</p><p>즉, 절대로 Entity 클래스를 Request/Response 클래스로 사용해선 안된다.</p><p>이유는 Entity 클래스는 데이터베이스와 맞닿은 핵심 클래스로 화면 변경은 사소한 변경인데 이를 건들기 위해 테이블과 연결된 Entity 클래스를 변경하는 것은 너무 큰 변경이다.</p><p>수많은 서비스 클래스나 비즈니스 로직들이 Entity 클래스를 기준으로 동작하며 Entity 클래스가 변경되면 여러 클래스에 영향을 끼지지만</p><p>Request/Response 용 Dto는 View를 위한 클래스라 자주 변경이 필요하다.</p><p>이처럼 View Layer 와 DB Layer 의 역할을 철저히 분리하는게 좋다.</p><p>예를 들어 Controller에서 결과값으로 여러 테이블을 조인해야 하는 경우 Entity 클래스만으로 표현하기 어려운 경우도 있다.</p><p>다음은 JPA를 사용한 게시판의 등록 API 테스트 코드이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.jojoldu.book.springboot.web;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.jojoldu.book.springboot.domain.posts.Posts;</span><br><span class="line"><span class="keyword">import</span> com.jojoldu.book.springboot.domain.posts.PostsRepository;</span><br><span class="line"><span class="keyword">import</span> com.jojoldu.book.springboot.web.dto.PostsSaveRequestDto;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.AfterEach;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.extension.ExtendWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.web.client.TestRestTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.web.server.LocalServerPort;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.HttpStatus;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.ResponseEntity;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit.jupiter.SpringExtension;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.assertj.core.api.Assertions.assertThat;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ExtendWith(SpringExtension.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PostsApiControllerTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@LocalServerPort</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TestRestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> PostsRepository postsRepository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterEach</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tearDown</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        postsRepository.deleteAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> Posts_등록된다() <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//given</span></span><br><span class="line">        String title = <span class="string">&quot;title&quot;</span>;</span><br><span class="line">        String content = <span class="string">&quot;content&quot;</span>;</span><br><span class="line">        PostsSaveRequestDto requestDto = PostsSaveRequestDto.builder().title(title).content(content).author(<span class="string">&quot;author&quot;</span>).build();</span><br><span class="line"></span><br><span class="line">        String url = <span class="string">&quot;http://localhost:&quot;</span> + port + <span class="string">&quot;/api/v1/posts&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//when</span></span><br><span class="line">        ResponseEntity&lt;Long&gt; responseEntity = restTemplate.postForEntity(url, requestDto, Long.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//then</span></span><br><span class="line">        assertThat(responseEntity.getStatusCode()).isEqualTo(HttpStatus.OK);</span><br><span class="line">        assertThat(responseEntity.getBody()).isGreaterThan(<span class="number">0L</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;Posts&gt; all = postsRepository.findAll();</span><br><span class="line">        assertThat(all.get(<span class="number">0</span>).getTitle()).isEqualTo(title);</span><br><span class="line">        assertThat(all.get(<span class="number">0</span>).getContent()).isEqualTo(content);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HelloController와 달리 <code>@WebMvcTest</code>를 사용하지 않는데 @WebMvcTest의 경우 JPA기능이 작동하지 않기 때문인데 Controller와 ControllerAdvice 등 외부 연동과 관련된 부분만 활성화되니</p><p>지금 처럼 JPA 기능까지 한번에 테스트할 때는 @SpringBootTest 와 TestRestTemplate을 사용하면 된다.</p><hr><p>JPA를 사용할 때 update 기능에서 <strong>데이터베이스에 쿼리를 날리는 부분이 없다.</strong><br>이게 가능한 이유는 JPA의 <strong>영속성 컨텍스트</strong> 때문이다.</p><p>영속성 컨텍스트란, <strong>엔티티를 영구 저장하는 환경</strong>으로 일종의 논리적 개념이라고 보면 되며 JPA의 핵심 내용은 엔티티가 영속성 컨텍스트에 포함되어 있냐 아니냐로 갈린다.</p><p>JPA의 엔티티 매니저가 활성화된 상태로(Spring Data Jpa를 쓴다면 기본 옵션) <strong>트랜잭션 안에서 데이터베이스에서 데이터를 가져오면</strong> 이 데이터는 영속성 컨텍스트가 유지된 상태이다.</p><p>이 상태에서 해당 데이터의 값을 변경하면 <strong>트랜잭션이 끝나는 시점에 해당 테이블에 변경분을 반영</strong>한다. 즉, Entity 객체의 값만 변경하면 별도로 Update쿼리를 날릴 필요가 없는데 이를 <code>더티 체킹(dirty checking)</code>이라고 한다.</p><hr><h2 id="3-5-JPA-Auditing으로-생성시간-수정시간-자동화하기"><a href="#3-5-JPA-Auditing으로-생성시간-수정시간-자동화하기" class="headerlink" title="3.5 JPA Auditing으로 생성시간/수정시간 자동화하기"></a>3.5 JPA Auditing으로 생성시간/수정시간 자동화하기</h2><p>보통 엔티티에는 해당 데이터의 생성시간과 수정시간을 포함하는데 반복적인 코드를 모든 테이블과 서비스 메소드에 포함하면 너무 귀찮으니 JPA Auditing를 사용해보자.</p><h3 id="LocalDate-사용"><a href="#LocalDate-사용" class="headerlink" title="LocalDate 사용"></a>LocalDate 사용</h3><p>Java8부터 LocalDate와 LocalDateTime이 등장하여 그간 Java의 기본 날짜 타입인 Date의 문제점을 제대로 고쳤으니 꼭 사용하자.</p><ul><li>BaseTimeEntity.java<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.Getter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.annotation.CreatedDate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.annotation.LastModifiedDate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.jpa.domain.support.AuditingEntityListener;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.persistence.EntityListeners;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.MappedSuperclass;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@MappedSuperclass</span></span><br><span class="line"><span class="meta">@EntityListeners(AuditingEntityListener.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseTimeEntity</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@CreatedDate</span></span><br><span class="line">    <span class="keyword">private</span> LocalDateTime createDate;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@LastModifiedDate</span></span><br><span class="line">    <span class="keyword">private</span> LocalDateTime modifiedDate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>BaseTimeEntity클래스는 모든 Entity의 상위 클래스가 되어 Entity들의 createdDate, modifiedDate를 자동으로 관리하는 역할이다.</li></ul><ol><li>@MappedSuperclass</li></ol><ul><li>JPA Entity 클래스들이 BaseTimeEntity을 상속할 경우 필드들(createdDate, modifiedDate)도 컬럼으로 인식하도록 한다.</li></ul><ol start="2"><li>@EntityListeners(AuditingEntityListener.class)</li></ol><ul><li>BaseTimeEntity 클래스에 Auditing 기능을 포함시킨다.</li></ul><ol start="3"><li>CreatedDate</li></ol><ul><li>Entity가 생성되어 저장될 때 시간이 자동 저장된다.</li></ul><ol start="4"><li>LastModifiedDate</li></ol><ul><li>조회한 Entity의 값을 변경할 때 시간이 자동 저장된다.</li></ul><p>이후 앞서 만든 Posts 클래스가 BaseTimeEntity를 상속받도록 변경한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  ...</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Posts</span> <span class="keyword">extends</span> <span class="title">BaseTimeEntity</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>마지막으로 JPA Auditing 어노테이션들을 모두 활성화할 수 있도록 Application 클래스에 활성화 어노테이션을 추가한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableJpaAuditing</span> <span class="comment">// JPA Auditing 활성화</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://yoo0926.github.io/categories/spring/">spring</category>
      
      <category domain="https://yoo0926.github.io/categories/spring/book/">book</category>
      
      
      <category domain="https://yoo0926.github.io/tags/spring/">spring</category>
      
      
      <comments>https://yoo0926.github.io/2021/04/22/spring/book/%EC%8A%A4%ED%94%84%EB%A7%81-%EB%B6%80%ED%8A%B8%EC%99%80-AWS%EB%A1%9C-%ED%98%BC%EC%9E%90-%EA%B5%AC%ED%98%84%ED%95%98%EB%8A%94-%EC%9B%B9%EC%84%9C%EB%B9%84%EC%8A%A4/3/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>2.테스트코드 작성하기</title>
      <link>https://yoo0926.github.io/2021/04/21/spring/book/%EC%8A%A4%ED%94%84%EB%A7%81-%EB%B6%80%ED%8A%B8%EC%99%80-AWS%EB%A1%9C-%ED%98%BC%EC%9E%90-%EA%B5%AC%ED%98%84%ED%95%98%EB%8A%94-%EC%9B%B9%EC%84%9C%EB%B9%84%EC%8A%A4/2/</link>
      <guid>https://yoo0926.github.io/2021/04/21/spring/book/%EC%8A%A4%ED%94%84%EB%A7%81-%EB%B6%80%ED%8A%B8%EC%99%80-AWS%EB%A1%9C-%ED%98%BC%EC%9E%90-%EA%B5%AC%ED%98%84%ED%95%98%EB%8A%94-%EC%9B%B9%EC%84%9C%EB%B9%84%EC%8A%A4/2/</guid>
      <pubDate>Wed, 21 Apr 2021 09:08:44 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;JUnit4 -&amp;gt; 5 변경점&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;lin</description>
        
      
      
      
      <content:encoded><![CDATA[<p>JUnit4 -&gt; 5 변경점</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">junit4 -&gt; 5</span><br><span class="line"></span><br><span class="line">  1. @Test</span><br><span class="line">  패키지 위치 변경</span><br><span class="line"></span><br><span class="line">org.junit.Test</span><br><span class="line"><span class="meta">-&gt;</span><span class="bash"> org.junit.jupiter.api.Test</span></span><br><span class="line"></span><br><span class="line">  2. @RunWith</span><br><span class="line">  Junit5에서 @ExtendWith 로 변경되서 어노테이션명과 패키지위치 변경</span><br><span class="line"></span><br><span class="line">org.junit.runner.RunWith</span><br><span class="line"><span class="meta">-&gt;</span><span class="bash"> org.junit.jupiter.api.extension.ExtendWith</span></span><br><span class="line"></span><br><span class="line">@RunWith</span><br><span class="line"><span class="meta">-&gt;</span><span class="bash"> @ExtendWith</span></span><br><span class="line"></span><br><span class="line">  3. SpringRunner</span><br><span class="line">  SpringExtension 으로 변경되서 클래스명과 패키지위치 변경</span><br><span class="line"></span><br><span class="line">SpringRunner</span><br><span class="line"><span class="meta">-&gt;</span><span class="bash"> SpringExtension</span></span><br><span class="line"></span><br><span class="line">org.springframework.test.context.junit4.SpringRunner</span><br><span class="line"><span class="meta">-&gt;</span><span class="bash"> org.springframework.test.context.junit.jupiter.SpringExtension</span></span><br><span class="line"></span><br><span class="line">  4. @After</span><br><span class="line">  테스트 메소드가 끝날때마다 수행되는 @After 도 Junit5에서 @AfterEach 로 변경되었기 때문에 어노테이션과 패키지위치 변경</span><br><span class="line"></span><br><span class="line">@After</span><br><span class="line"><span class="meta">-&gt;</span><span class="bash"> @AfterEach</span></span><br><span class="line"></span><br><span class="line">org.junit.After</span><br><span class="line"><span class="meta">-&gt;</span><span class="bash"> org.junit.jupiter.api.AfterEach</span></span><br><span class="line"></span><br><span class="line">  5. @Before</span><br><span class="line">  마찬가지로 @BeforeEach 로 변경되서 어노테이션과 패키지위치 변경</span><br><span class="line"></span><br><span class="line">@Before</span><br><span class="line"><span class="meta">-&gt;</span><span class="bash"> @BeforeEach</span></span><br><span class="line"></span><br><span class="line">org.junit.Before</span><br><span class="line"><span class="meta">-&gt;</span><span class="bash"> org.junit.jupiter.api.BeforeEach</span></span><br></pre></td></tr></table></figure><p>샘플 컨트롤러 코드</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.jojoldu.book.springboot.web;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="comment">//컨트롤러를 JSON을 반환하는 컨트롤러로 만들어준다.</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//HTTP Method인 Get의 요청을 받을 수 있는 API를 만들어 준다.</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>샘플 단위 테스트 코드</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.jojoldu.book.springboot.web;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.extension.ExtendWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit.jupiter.SpringExtension;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.web.servlet.MockMvc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1. @ExtendWith(SpringExtension.class)</span></span><br><span class="line"><span class="comment">- 테스트를 진행할 때 JUnit에 내장된 실행자 외에 다른 실행자를 실행시킨다.</span></span><br><span class="line"><span class="comment">- 여기서는 SpringExtension 이라는 스프링 실행자를 사용한다.</span></span><br><span class="line"><span class="comment">- 스프링 부트 테스트와 JUnit 사이에 연결자 역할</span></span><br><span class="line"><span class="comment">- JUnit4 -&gt; 5로 넘어오면서 사용하는 어노테이션과 클래스가 각각 @RunWith -&gt; @ExtendWith 로 SpringRunner -&gt; SpringExtension 으로 변경되었다.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2. @WebMvcTest</span></span><br><span class="line"><span class="comment">- 여러 스프링 테스트 어노테이션 중, Web(Spring MVC)에 집중할 수 있는 어노테이션</span></span><br><span class="line"><span class="comment">- 선언할 경우 @Controller, @ControllerAdvice 등을 사용할 수 있다.</span></span><br><span class="line"><span class="comment">- 단, @Service, @Component, @Repository 등은 사용할 수 없다.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@ExtendWith(SpringExtension.class)</span><span class="comment">//1</span></span><br><span class="line"><span class="meta">@WebMvcTest(controllers = HelloController.class)</span><span class="comment">//2</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloControllerTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    3. AutoWired</span></span><br><span class="line"><span class="comment">    - 스프링이 관리하는 빈(Bean)을 주입 받는다.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    4. private MockMvc mvc</span></span><br><span class="line"><span class="comment">    - 웹 API를 테스트할 때 사용한다.</span></span><br><span class="line"><span class="comment">    - 스프링 MVC 테스트의 시작점</span></span><br><span class="line"><span class="comment">    - 이 클래스를 통해 HTTP GET, POST 등에 대한 API 테스트를 할 수 있다.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Autowired</span><span class="comment">//3</span></span><br><span class="line">    <span class="keyword">private</span> MockMvc mvc;<span class="comment">//4</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> hello가_리턴된다() <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        String hello = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        5. mvc.perform(get(&quot;/hello&quot;))</span></span><br><span class="line"><span class="comment">        - MockMvc를 통해 /hello 주소로 HTTP GET 요청을 한다.</span></span><br><span class="line"><span class="comment">        - 체이닝이 지원되어 아래와 같이 여러 검증 기능을 이어서 선언할 수 있다.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        6. .andExpect(status().isOk())</span></span><br><span class="line"><span class="comment">        - mvc.perform의 결과를 검증한다.</span></span><br><span class="line"><span class="comment">        - HTTP Header의 Status를 검증한다.</span></span><br><span class="line"><span class="comment">        - 우리가 흔히 알고 있는 200, 404, 500 emddml 상태를 검증한다.</span></span><br><span class="line"><span class="comment">        - 여기선 OK 즉, 200인지 아닌지를 검증한다.</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        7. .andExpect(content().string(hello))</span></span><br><span class="line"><span class="comment">        - mvc.perform의 결과를 검증한다.</span></span><br><span class="line"><span class="comment">        - 응답 본문의 내용을 검증한다.</span></span><br><span class="line"><span class="comment">        - Controller에서 &quot;hello&quot;를 리턴하기 때문에 이 값이 맞는지 검증한다.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        mvc.perform(get(<span class="string">&quot;/hello&quot;</span>))<span class="comment">//5</span></span><br><span class="line">                .andExpect(status().isOk())<span class="comment">//6</span></span><br><span class="line">                .andExpect(content().string(hello));<span class="comment">//7</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="2-3-롬북-Lombok"><a href="#2-3-롬북-Lombok" class="headerlink" title="2.3 롬북(Lombok)"></a>2.3 롬북(Lombok)</h2><p>자바 개발 시 자주 사용하는 코드 Getteer, Setter, 기본생성자, toString 등을 어노테이션으로 자동 생성해준다.</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    <span class="comment">// lombok</span></span><br><span class="line">    implementation(<span class="string">&#x27;org.projectlombok:lombok&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://yoo0926.github.io/categories/spring/">spring</category>
      
      <category domain="https://yoo0926.github.io/categories/spring/book/">book</category>
      
      
      <category domain="https://yoo0926.github.io/tags/spring/">spring</category>
      
      
      <comments>https://yoo0926.github.io/2021/04/21/spring/book/%EC%8A%A4%ED%94%84%EB%A7%81-%EB%B6%80%ED%8A%B8%EC%99%80-AWS%EB%A1%9C-%ED%98%BC%EC%9E%90-%EA%B5%AC%ED%98%84%ED%95%98%EB%8A%94-%EC%9B%B9%EC%84%9C%EB%B9%84%EC%8A%A4/2/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>1.SpringBoot 시작하기</title>
      <link>https://yoo0926.github.io/2021/04/21/spring/book/%EC%8A%A4%ED%94%84%EB%A7%81-%EB%B6%80%ED%8A%B8%EC%99%80-AWS%EB%A1%9C-%ED%98%BC%EC%9E%90-%EA%B5%AC%ED%98%84%ED%95%98%EB%8A%94-%EC%9B%B9%EC%84%9C%EB%B9%84%EC%8A%A4/1/</link>
      <guid>https://yoo0926.github.io/2021/04/21/spring/book/%EC%8A%A4%ED%94%84%EB%A7%81-%EB%B6%80%ED%8A%B8%EC%99%80-AWS%EB%A1%9C-%ED%98%BC%EC%9E%90-%EA%B5%AC%ED%98%84%ED%95%98%EB%8A%94-%EC%9B%B9%EC%84%9C%EB%B9%84%EC%8A%A4/1/</guid>
      <pubDate>Wed, 21 Apr 2021 09:08:27 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;솔루션 회사를 몇년 다니다보니 내가 생각하는 웹서비스 환경의 경험이 적다는 생각이 들어서 &lt;code&gt;A to Z&lt;/code&gt;까지 천천히 따라가면서 조금이나마 경험을 늘릴 수 있는 계기가 되지 않을까 싶어서 서적을 하나 구매해보았다.&lt;/p&gt;
&lt;p&gt;</description>
        
      
      
      
      <content:encoded><![CDATA[<p>솔루션 회사를 몇년 다니다보니 내가 생각하는 웹서비스 환경의 경험이 적다는 생각이 들어서 <code>A to Z</code>까지 천천히 따라가면서 조금이나마 경험을 늘릴 수 있는 계기가 되지 않을까 싶어서 서적을 하나 구매해보았다.</p><p>이하 포스팅할 내용은 모두 <code>스프링 부트와 AWS로 혼자 구현하는 웹 서비스</code>라는 책을 읽고 작성한 내용으로 학습한 내용을 정리하기 위함이다.</p><h2 id=""><a href="#" class="headerlink" title=""></a><img src="../img/programming/spring/spring-2-0.jpg" alt="스프링 부트와 AWS로 혼자 구현하는 웹 서비스"></h2><ul><li>개발환경은 책과 좀 다르다. 시간도 지났고 기존에 사용하던 환경이 있으므로<ul><li>openJDK 11</li><li>Gradle 6.7</li><li>IntelliJ 유료버전</li></ul></li></ul><h1 id="1-인텔리제이로-스프링-부트-시작하기"><a href="#1-인텔리제이로-스프링-부트-시작하기" class="headerlink" title="1. 인텔리제이로 스프링 부트 시작하기"></a>1. 인텔리제이로 스프링 부트 시작하기</h1><p>이미 인텔리제이는 사용하고 있지만 책에서 언급한 이클립스에 비해 인텔리제이가 가진 장점은 다음과 같다.</p><ul><li>강력한 추천 기능(Smart Completion)</li><li>훨씬 더 다양한 리팩토링과 디버깅 기능</li><li>이클립스의 깃(Git)에 비해 훨씬 높은 자유도</li><li>프로젝트 시작할 때 인덱싱을 하여 파일을 비롯한 자원들에 대한 빠른 검색 속도</li><li>HTML과 CSS, JS, XML에 대한 강력한 기능 지원</li><li>자바, 스프링 부트 버전업에 맞춘 빠른 업데이트</li></ul><p>인텔리제이는 무료버전과 유료버전이 모두 존재하지만 <strong>커뮤니티(무료)</strong> 버전만 사용하더라도 개발에 큰 지장은 없다. 자바 개발에 대한 모든 기능 및 <code>Maven</code>, <code>Gradle</code>과 같은 빌드 도구도 모두 지원한다.</p><blockquote><p>여담으로 둘다 써본 경험에서 불편했던 점은 딱 한가지였는데 임베디드 톰캣이 아닌 외부 톰캣과 연동하는 경우 커뮤니티 버전에선 공식적으로 지원하지 않아서 별도의 플러그인을 설치해서 사용했는데 그게 좀 귀찮았던 기억이 있다.</p><p>그리고 이클립스를 쓰다가 인텔리제이로 넘어오면 가장 당황하는 것이 워크스페이스가 없이 프로젝트와 모듈의 개념만 있다는 점이다. 이 말은 인텔리제이는 한번에 하나의 프로젝트만 열린다는 점이다.</p></blockquote><h2 id="Gradle로-프로젝트-생성"><a href="#Gradle로-프로젝트-생성" class="headerlink" title="Gradle로 프로젝트 생성"></a><code>Gradle</code>로 프로젝트 생성</h2><p><img src="../img/programming/spring/spring-2-1.png" alt="인텔리제이로 프로젝트생성1"></p><p><img src="../img/programming/spring/spring-2-2.png" alt="인텔리제이로 프로젝트생성2"></p><p><em><code>ArtifactId</code>는 프로젝트의 이름이 된다</em></p><p><em>그동안 <code>Maven</code>만 사용해봤는데 <code>Gradle</code>이 가진 장점과 단점은 무엇인지 추후에 찾아봐서 포스팅 해봐야겠다.</em></p><p>시간이 지나면서 버전이 바뀐 영향인지 프로젝트 생성부터 책과 약간 다르게 진행이 되긴 하는데 또 그래야 더 찾아보고 공부가 되지 않을까 하는 생각도 들었다.</p><p><img src="../img/programming/spring/spring-2-3.png" alt="인텔리제이로 프로젝트생성3"></p><p><em>Gradle 프로젝트 생성 완료</em></p><h2 id="Gradle-프로젝트를-springBoot-프로젝트로-변경하기"><a href="#Gradle-프로젝트를-springBoot-프로젝트로-변경하기" class="headerlink" title="Gradle 프로젝트를 springBoot 프로젝트로 변경하기"></a><code>Gradle</code> 프로젝트를 <code>springBoot</code> 프로젝트로 변경하기</h2><ul><li>초기 <code>build.gradle</code> 파일</li></ul><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    id <span class="string">&#x27;java&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">group <span class="string">&#x27;com.springboot.service&#x27;</span></span><br><span class="line">version <span class="string">&#x27;1.0-SNAPSHOT&#x27;</span></span><br><span class="line"></span><br><span class="line">repositories &#123;</span><br><span class="line">    mavenCentral()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    testImplementation <span class="string">&#x27;org.junit.jupiter:junit-jupiter-api:5.6.0&#x27;</span></span><br><span class="line">    testRuntimeOnly <span class="string">&#x27;org.junit.jupiter:junit-jupiter-engine&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test &#123;</span><br><span class="line">    useJUnitPlatform()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>음… 여기서부터 책과 벌써 다르다. 아무래도 책의 출판시점에서 2년이나 지났으니 각종 라이브러리, 도구들의 버전업이 일어나면서 여러 내용들이 바뀐듯 하다.</p><p>구글링을 해보니 저자분이 [2020.12.16] 기준으로 최신 라이브러리로 버전업한 내용에 대해 정리해놓은 글이 있어서 해당 내용을 참고하였다.</p><p>참고링크 : <a href="https://jojoldu.tistory.com/539">스프링 부트와 AWS로 혼자 구현하는 웹 서비스 (2020.12.16)</a></p><p>변경된 도구들의 버전은 다음과 같다.</p><table><thead><tr><th>라이브러리,도구명</th><th>출판버전</th><th>웹버전</th></tr></thead><tbody><tr><td>Spring Boot</td><td>2.1.7</td><td>2.4.1</td></tr><tr><td>Gradle</td><td>4.8~4.10</td><td>6.7.1</td></tr><tr><td>JUnit</td><td>4</td><td>5</td></tr></tbody></table>]]></content:encoded>
      
      
      <category domain="https://yoo0926.github.io/categories/spring/">spring</category>
      
      <category domain="https://yoo0926.github.io/categories/spring/book/">book</category>
      
      
      <category domain="https://yoo0926.github.io/tags/spring/">spring</category>
      
      
      <comments>https://yoo0926.github.io/2021/04/21/spring/book/%EC%8A%A4%ED%94%84%EB%A7%81-%EB%B6%80%ED%8A%B8%EC%99%80-AWS%EB%A1%9C-%ED%98%BC%EC%9E%90-%EA%B5%AC%ED%98%84%ED%95%98%EB%8A%94-%EC%9B%B9%EC%84%9C%EB%B9%84%EC%8A%A4/1/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>함수형 프로그래밍 - 재귀</title>
      <link>https://yoo0926.github.io/2020/12/07/functional/%EC%9E%AC%EA%B7%80/</link>
      <guid>https://yoo0926.github.io/2020/12/07/functional/%EC%9E%AC%EA%B7%80/</guid>
      <pubDate>Sun, 06 Dec 2020 15:13:19 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;앞서 확인한 개요에서 언급했는데 함수형 프로그래밍에선 반복을 재귀를 통해서 구현한다고 했는데 재귀와 꼬리재귀에 대해서 간단히 알아보자.&lt;/p&gt;
&lt;h2 id=&quot;재귀&quot;&gt;&lt;a href=&quot;#재귀&quot; class=&quot;headerlink&quot; title=&quot;재귀&quot;&gt;&lt;</description>
        
      
      
      
      <content:encoded><![CDATA[<p>앞서 확인한 개요에서 언급했는데 함수형 프로그래밍에선 반복을 재귀를 통해서 구현한다고 했는데 재귀와 꼬리재귀에 대해서 간단히 알아보자.</p><h2 id="재귀"><a href="#재귀" class="headerlink" title="재귀"></a>재귀</h2><p>함수 본문에서 자기자신을 호출하는 방식을 <code>재귀호출(recursive call)</code>이라고 부른다. 재귀는 다른 명령어가 방지할 때까지 계속된다.</p><h2 id="예제"><a href="#예제" class="headerlink" title="예제"></a>예제</h2><script src="https://gist.github.com/yoo0926/c22f935380ac613ff3a33e5970af0ea3.js"></script><hr><h2 id="꼬리-재귀-최적화-in-python"><a href="#꼬리-재귀-최적화-in-python" class="headerlink" title="꼬리 재귀 최적화 in python"></a>꼬리 재귀 최적화 in python</h2><p>재귀호출의 경우 호출 스택의 깊이가 얕은 경우엔 큰 상관이 없으나 깊이가 깊어지면 오버플로우가 발생하는 문제가 있다.<br><em>여담으로 실행하는 <del>시스템에 따라서 조금씩 다를수 있지만</del> 파이썬에서 호출가능한 스택의 최대 깊이는 보통 1000 정도에서 <code>RecursionError</code>가 발생한다.</em></p><script src="https://gist.github.com/yoo0926/9eab6f85efac2999cd3702c3f08716cc.js"></script><p>이를 해결하기 위한 방법으로 제시되는 해결책 중 하나가 꼬리 재귀<code>Tail recursion</code>이다.</p><p>간단히 말하자면 함수에서 마지막으로 호출하는 함수가 자기 자신이고, 재귀 호출의 값을 반환받은후 추가적인 연산이 필요하지 않는 방식을 말한다.</p><hr><h2 id="꼬리-재귀-적용-예제"><a href="#꼬리-재귀-적용-예제" class="headerlink" title="꼬리 재귀 적용 예제"></a>꼬리 재귀 적용 예제</h2><p>위의 예제에서 사용한 팩토리얼 함수를 보자.</p><p>fact(n)을 호출했을 때 연산이 끝나지 않았는데 fact(n-1)을 호출하기 때문에 리턴 주소를 저장하기 위해서 시스템 콜스택을 사용하게 된다.</p><p>즉, 현재 함수(fact(n))에서 결과값을 반환하기 위해서는 현재 함수의 인자 값(n)을 스택에 가지고 있다가 그 다음 호출될 함수(fact(n-1))의 결과 값과 함께 연산을 해야 한다는 점이다.<br>이러한 방식은 꼬리 재귀를 만족하지 못한다고 본다.</p><p>예제를 꼬리 재귀로 바꾸려면 어떻게 해야할까? 재귀를 호출하는 부분에서 추가적인 연산이 필요없도록 만들면 되는데</p><p>이를 구현하기 위해선</p><blockquote><p>return에서는 <em>(언어 스펙에서 지정한 스택에 메모리를 쌓지 않는 연산자를 제외한)</em> 연산자를 사용하면 안된다.</p></blockquote><p>연산자의 사용없이 재귀 호출의 반환값을 그대로 return 해주면 된다.</p><script src="https://gist.github.com/yoo0926/10a170843e290ce85e22acf0d62e374a.js"></script><p>한가지 주의할 점은 개발자가 꼬리재귀 구조로 코드를 짜더라도 사용하는 언어의 스펙에 따라서 꼬리재귀 최적화 보장여부가 다르기 때문에 확인이 필요하다.<br>요즘 python을 공부하고 싶어서 위 예시를 python으로 들었지만 python은 꼬리재귀 최적화를 보장하지 않는데 python의 창시자 <code>귀도 반 로섬</code>의 의견은 다음과 같다.</p><blockquote><p>귀도 반 로섬의 TRE(Tail Recursion Elimination)에 대한 반론</p><ul><li>콜 스택을 추적하기에 부적합하다(디버깅이 어렵다)</li><li>단순 최적화기 때문에 개별 파이썬 컴파일러 구현체에서 선택하게 둘 것</li><li>재귀가 모든 것의 기반이라는 접근은 이상적인 수학적인 접근일 뿐이다</li><li>파이썬 스타일의 개발자들은 재귀 대신 멋진(?) 문법들을 쓸 수 있다</li><li>not PYTHONIC 하다</li></ul></blockquote><hr><p><em><strong>Reference</strong></em></p><p><a href="https://www.tutorialspoint.com/functional_programming/functional_programming_recursion.htm">tutorialspoint - Learn Functional Programming</a></p><p><a href="https://homoefficio.github.io/2015/07/27/%EC%9E%AC%EA%B7%80-%EB%B0%98%EB%B3%B5-Tail-Recursion/">재귀,반복, Tail Recursion</a></p><p><a href="http://neopythonic.blogspot.com/2009/04/tail-recursion-elimination.html">Tail Recursion Elimination</a></p>]]></content:encoded>
      
      
      <category domain="https://yoo0926.github.io/categories/functional/">functional</category>
      
      
      <category domain="https://yoo0926.github.io/tags/functional/">functional</category>
      
      
      <comments>https://yoo0926.github.io/2020/12/07/functional/%EC%9E%AC%EA%B7%80/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>함수형 프로그래밍 - 개요</title>
      <link>https://yoo0926.github.io/2020/12/07/functional/%EA%B0%9C%EC%9A%94/</link>
      <guid>https://yoo0926.github.io/2020/12/07/functional/%EA%B0%9C%EC%9A%94/</guid>
      <pubDate>Sun, 06 Dec 2020 15:02:48 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;함수형~ 함수형~ 여러 곳에서 이야기는 종종 들었지만 제대로 찾아본 적이 없다보니 기본적인 개념부터 많이 부족해서 간단히 스터디를 시작했다.&lt;/p&gt;
&lt;p&gt;특정 언어를 선정해서 언어적 특성에 종속되기 보단 우선 함수형 프로그래밍의 패러다임에 대해서</description>
        
      
      
      
      <content:encoded><![CDATA[<p>함수형~ 함수형~ 여러 곳에서 이야기는 종종 들었지만 제대로 찾아본 적이 없다보니 기본적인 개념부터 많이 부족해서 간단히 스터디를 시작했다.</p><p>특정 언어를 선정해서 언어적 특성에 종속되기 보단 우선 함수형 프로그래밍의 패러다임에 대해서 먼저 학습 해보자.</p><hr><h2 id="개요"><a href="#개요" class="headerlink" title="개요"></a>개요</h2><p>함수형 프로그래밍은 크게 두 그룹으로 분류된다.</p><table><thead><tr><th>구분</th><th>지원범위</th><th>언어</th></tr></thead><tbody><tr><td>순수 함수형 언어</td><td>오직 함수형 패러다임만 지원</td><td>Haskell</td></tr><tr><td>불순 함수형 언어</td><td>함수형 패러다임과 명령형 프로그래밍을 지원</td><td>LISP</td></tr></tbody></table><p>그럼 여기서 명령형은 뭐고 함수형 패러다임은 뭘 말하는 걸까?</p><p>프로그래밍 패러다임은 크게 보면 2가지로 분류할 수 있다.</p><ol><li>명령형 프로그래밍 : 프로그래밍의 상태와 상태를 변경시키는 구문의 관점에서 연산을 설명하여 기능을 구현하기 위한 알고리즘을 명시하지만 결국 무엇을 해야하는지는 명시하지 않는다.<ul><li>절차지향 프로그래밍 : 수행되어야 할 연속적인 계산 과정을 포함 (C, C++)</li><li>객체지향 프로그래밍 : 객체들의 집합으로 프로그램의 상호작용을 표현 (C++, Java, C#)</li></ul></li><li>선언형 프로그래밍 : How(어떻게) 보단 What(무엇을) 해야하는지 설명하는 방식으로 알고리즘에 대해서 명시하진 않고 목표를 명시한다.<ul><li>함수형 프로그래밍 : 순수 함수를 조합하고 소프트웨어를 만드는 방식 (Clojure, Haskell, LISP)</li></ul></li></ol><p><em><strong>명령형 프로그래밍은 어떻게 할 것이가(How)를 표현하고, 선언형 프로그래밍은 무엇을 할것인가(What)를 표현한다.</strong></em></p><hr><h2 id="특성"><a href="#특성" class="headerlink" title="특성"></a>특성</h2><p>함수형 프로그래밍은 아래와 같은 특징을 같는다.</p><ul><li><p>계산을 수행하기 위해 조건식과 재귀를 사용하는 수학 함수의 개념에 따라 설계되었다.</p></li><li><p>고차함수<code>high order function</code>와 지연연산<code>lazy evaluation</code> 기능을 지원한다.</p><ol><li><h4 id="고차-함수"><a href="#고차-함수" class="headerlink" title="고차 함수"></a>고차 함수</h4><ul><li>람다 계산법에서 만들어진 용어로 아래 조건을 만족하는 함수<ul><li>함수에 함수를 파라미터로 전달할 수 있다.</li><li>함수의 반환값으로 함수를 사용할 수 있다.</li></ul></li><li>고차 함수는 <code>1급 함수</code>의 부분집합이다.</li></ul></li><li><h4 id="지연-연산"><a href="#지연-연산" class="headerlink" title="지연 연산"></a>지연 연산</h4><ul><li>불필요한 연산을 피하기 위해서 결과값이 필요한 시점까지 연산을 늦추는 것을 말한다.<ul><li>값을 미리 계산해서 저장하지 않기 때문에 메모리의 효율적인 사용이 가능</li></ul></li></ul></li></ol></li><li><p>루프문과 같은 흐름제어와 If-Else, Switch문과 같은 조건문을 지원하지 않고 함수와 함수호출을 직접 사용한다.</p></li><li><p>OOP와 마찬가지로 추상화, 캡슐화, 상속, 다형성과 같은 개념을 지원한다.</p></li></ul><hr><h2 id="장점"><a href="#장점" class="headerlink" title="장점"></a>장점</h2><ul><li><strong>Bugs-Free Code</strong> : State를 지원하지 않으므로 부작용이 없어서<code>no side-effect</code> 오류없는 코드작성이 가능하다.<del>(없다기 보단 그냥 적은게 맞을 것 같다.)</del></li><li><strong>효율적인 병렬 프로그래밍</strong> : 상태 변경이 없기 때문에 병렬로 작동하도록 기능에 대해서 프로그래밍할 수 있으며 이는 재사용 및 테스트를 더 쉽게 지원한다.</li><li><strong>효율성</strong> : 독립적인 유닛으로 구성되서 동시에 실행할 수 있다.</li><li><strong>중첩 함수 지원</strong> : 중첩함수를 지원한다.</li><li><strong>지연 연산</strong> : <code>Lazy List</code>, <code>Lazy Map</code> 등과 같은 지연 함수 구조를 지원한다.</li></ul><hr><h2 id="단점"><a href="#단점" class="headerlink" title="단점"></a>단점</h2><ul><li>큰 메모리 공간이 필요하며 상태가 없기 때문에 작업을 수행할 때마다 새 객체를 만들어야한다.</li></ul><hr><h2 id="함수형-vs-객체지향"><a href="#함수형-vs-객체지향" class="headerlink" title="함수형 vs 객체지향"></a>함수형 vs 객체지향</h2><table><thead><tr><th>함수형</th><th>OOP</th></tr></thead><tbody><tr><td>불변 데이터 사용</td><td>가변 데이터 사용</td></tr><tr><td>선언적 프로그래밍 모델</td><td>명령형 프로그래밍 모델</td></tr><tr><td><code>무엇을 하는가</code>에 초점</td><td><code>어떻게 하는가</code> 에 초점</td></tr><tr><td>병렬 프로그래밍 지원</td><td>병렬 프로그래밍에 적합하지 않음</td></tr><tr><td>부작용이 없다</td><td>부작용이 발생할 수 있다.</td></tr><tr><td>함수 호출 및 재귀를 사용하여 흐름 제어</td><td>루프와 조건문을 사용하서 흐름 제어</td></tr><tr><td>재귀를 사용한 반복</td><td>루프를 사용한 반복</td></tr><tr><td>실행순서가 중요하지 않다.</td><td>실행 순서가 매우 중요하다.</td></tr><tr><td>데이터 추상화, 동작 추상화 지원</td><td>데이터 추상화만 지원</td></tr></tbody></table><p>이상으로 함수형 프로그래밍에 대한 대략적인 개요에 대해서만 우선 정리해 보았다.</p><hr><p><em><strong>Reference</strong></em></p><p><a href="https://www.tutorialspoint.com/functional_programming/functional_programming_introduction.htm">tutorialspoint - Lean Functional Programming</a></p><p><a href="https://velog.io/@kyusung/%ED%95%A8%EC%88%98%ED%98%95-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EC%9A%94%EC%95%BD">함수형 프로그래밍 요약</a></p><p><a href="https://engineering.linecorp.com/ko/blog/functional-programing-language-and-line-game-cloud/">함수형 프로그래밍 언어에 대한 고찰</a></p>]]></content:encoded>
      
      
      <category domain="https://yoo0926.github.io/categories/functional/">functional</category>
      
      
      <category domain="https://yoo0926.github.io/tags/functional/">functional</category>
      
      
      <comments>https://yoo0926.github.io/2020/12/07/functional/%EA%B0%9C%EC%9A%94/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>PostgreSQL 테이블 중복데이터 제거</title>
      <link>https://yoo0926.github.io/2020/11/23/sql/postgresql/%EC%A4%91%EB%B3%B5-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%A0%9C%EA%B1%B0/</link>
      <guid>https://yoo0926.github.io/2020/11/23/sql/postgresql/%EC%A4%91%EB%B3%B5-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%A0%9C%EA%B1%B0/</guid>
      <pubDate>Sun, 22 Nov 2020 15:40:41 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;설계, 운영이 잘 되는 DB에선 많이 발생하는 문제는 아닐테지만 테이블의 특정 컬럼값을 기준으로 중복된 데이터를 삭제해야 하는 경우가 있다.&lt;/p&gt;
&lt;p&gt;필자의 경우 PostgreSQL을 사용하던 중 이전 담당자가 테이블을 TEST_01_TB ~</description>
        
      
      
      
      <content:encoded><![CDATA[<p>설계, 운영이 잘 되는 DB에선 많이 발생하는 문제는 아닐테지만 테이블의 특정 컬럼값을 기준으로 중복된 데이터를 삭제해야 하는 경우가 있다.</p><p>필자의 경우 PostgreSQL을 사용하던 중 이전 담당자가 테이블을 TEST_01_TB ~ TEST_10_TB 이런식으로 물리적으로 10개로 나눠서 설계하여 사용하던걸 인수받았는데 감리 검수에서 10개의 테이블을 하나로 합치라는 개선안내를 받았다.</p><p><code>Hash Partition</code>을 적용하여 테이블을 합쳤으나 파티션을 적용하니 기존에 복합키로 사용하던 <code>Unique</code> 조건이나 데이터를 생성 시 Insert쿼리문에서 <code>ON CONFLICT 컬럼 DO NOTHING</code> 옵션도 적용할 수 없어서 빠지게 되었는데 이 때문에 중복데이터가 발생하였다.</p><p>중복된 데이터를 어떻게 찾아서 지우느냐에 따라 수행시간에 큰 차이가 날거라고 생각해서 구글링을 해보니 몇가지 방법을 찾을 수 있었다.</p><p><em><strong>Test Table Schema</strong></em></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> MEMBER_TB (</span><br><span class="line">MEM_ID BIGSERIAL <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">MEM_NAME <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    MEM_PNUM <span class="type">VARCHAR</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    MEM_EMAIL TEXT <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> BLACKLIST_TB (</span><br><span class="line">    MEM_PNUM <span class="type">VARCHAR</span>(<span class="number">11</span>) <span class="keyword">PRIMARY</span> KEY</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><em><strong>ROW_NUMBER()</strong></em></p><p>유저 테이블에의 MEM_PNUM 컬럼을 기준으로 중복된 데이터가 있어서 이를 지우기 위해선 어떻게 해야할까? 구글링을 하고 제일먼저 찾은 방법은 <code>ROW_NUMBER()</code> 를 활용한 방법이었다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> MEMBER_TB</span><br><span class="line"><span class="keyword">WHERE</span> MEM_ID <span class="keyword">IN</span> ( <span class="keyword">SELECT</span> MEM_ID </span><br><span class="line">                 <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> MEM_ID,</span><br><span class="line">                       <span class="built_in">ROW_NUMBER</span>() <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> MEM_PNUM <span class="keyword">ORDER</span> <span class="keyword">BY</span> MEM_ID ) RNUM</span><br><span class="line">                       <span class="keyword">FROM</span> MEMBER_TB )</span><br><span class="line">                <span class="keyword">WHERE</span> RNUM <span class="operator">&gt;</span> <span class="number">1</span> </span><br><span class="line">             );</span><br></pre></td></tr></table></figure><p>바로 적용할까 싶었지만 타겟 테이블의 데이터건수는 수십억개라 좀 더 빠른 방법이 없는지 더 찾아보던 중 <code>Self Join</code>과 <code>Delete Using</code>을 활용한 방법을 찾을 수 있었다.</p><p><em><strong>DELETE USING</strong></em></p><p>특정 테이블을 참조하여 데이터를 삭제할 때 <code>PostgreSQL</code>의 경우 <code>MySQL</code>처럼 <code>DELETE JOIN</code>을 제공하진 않지만 <code>USING</code>을 사용하여 <code>DELETE JOIN</code>과 유사한 기능을 지원한다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> MEMBER_TB T1</span><br><span class="line"><span class="keyword">USING</span> BLACKLIST_TB T2</span><br><span class="line"><span class="keyword">WHERE</span> T1.MEM_PNUM <span class="operator">=</span> T2.MEM_PNUM;</span><br></pre></td></tr></table></figure><p>예를 들면 이 처럼 <code>USING</code> 키워드를 사용하여 특정 테이블을 참조하여 유저테이블에서 블랙리스트 유저정보만 지울 수 있다.</p><p>그럼 여기서 SELF JOIN을 활용하여 MEM_PNUM, MEM_EMAIL 컬럼의 중복데이터를 삭제하고 싶으면 SQL문을 다음과 같은 식으로 작성할 수 있다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> MEMBER_TB T1</span><br><span class="line"><span class="keyword">USING</span> MEMBER_TB T2</span><br><span class="line"><span class="keyword">WHERE</span> T1.CTID <span class="operator">&lt;</span> T2.CTID</span><br><span class="line">  <span class="keyword">AND</span> T1.MEM_PNUM <span class="operator">=</span> T2.MEM_PNUM</span><br><span class="line">  <span class="keyword">AND</span> T1.MEM_EMAIL <span class="operator">=</span> T2.MEM_EMAIL;</span><br></pre></td></tr></table></figure><p>참고한 자료에선 1000만건의 데이터 중 10만건이 중복발생했을 때 약 42초정도 걸렸다고 했고 적용 전 확인해보기 위해 샘플로 Row가 약 800만에 중복데이터가 32만건 정도 들어있는 테이블로 테스트를 해보니 쿼리 실행에 약 1분정도 소요된 것을 확인하고 본래 타겟 테이블에 적용하였다.</p><p>그 후 데이터 생성 로직을 변경하여 중복데이터가 들어올 수 없도록 수정하였고 설계와 테스트를 더 잘 해야겠다는 생각이 절실하게 드는 하루였다.</p><p><em><strong>Reference</strong></em><br><a href="https://www.postgresqltutorial.com/postgresql-delete-join/">PostgreSQL DELETE JOIN</a></p><p><a href="https://rfriend.tistory.com/386">중복된 관측치 제거하기</a></p><p><a href="https://techmango.org/2018/10/08/how-to-delete-duplicate-rows-in-postgresql/">How to delete duplicate rows in postgresql?</a></p>]]></content:encoded>
      
      
      <category domain="https://yoo0926.github.io/categories/sql/">sql</category>
      
      <category domain="https://yoo0926.github.io/categories/sql/postgresql/">postgresql</category>
      
      
      <category domain="https://yoo0926.github.io/tags/sql/">sql</category>
      
      <category domain="https://yoo0926.github.io/tags/postgresql/">postgresql</category>
      
      
      <comments>https://yoo0926.github.io/2020/11/23/sql/postgresql/%EC%A4%91%EB%B3%B5-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%A0%9C%EA%B1%B0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Spring Framework란 무엇인가</title>
      <link>https://yoo0926.github.io/2020/11/03/spring/%EA%B0%9C%EC%9A%94/</link>
      <guid>https://yoo0926.github.io/2020/11/03/spring/%EA%B0%9C%EC%9A%94/</guid>
      <pubDate>Mon, 02 Nov 2020 15:38:04 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;기초가 부족한 관계로 기초부터 다시 정리도 하는 겸사겸사 첫주제는 spring framework로 정했다. &lt;/p&gt;
&lt;h1 id=&quot;Srping-Framework란&quot;&gt;&lt;a href=&quot;#Srping-Framework란&quot; class=&quot;headerlin</description>
        
      
      
      
      <content:encoded><![CDATA[<p>기초가 부족한 관계로 기초부터 다시 정리도 하는 겸사겸사 첫주제는 spring framework로 정했다. </p><h1 id="Srping-Framework란"><a href="#Srping-Framework란" class="headerlink" title="Srping Framework란"></a>Srping Framework란</h1><blockquote><p>스프링 프레임워크(Spring Framework)는 자바 플랫폼을 위한 오픈 소스 애플리케이션 프레임워크로 간단히 스프링(Spring)이라고도 한다. 동적인 웹 사이트를 개발하기 위한 여러 가지 서비스를 제공하고 있다.</p><p>대한민국 공공기관의 웹 서비스 개발 시 사용을 권장하고 있는 전자정부 표준프레임우커의 기반 기술로서 쓰이고 있다.</p></blockquote><h1 id="특징"><a href="#특징" class="headerlink" title="특징"></a>특징</h1><ol><li><h4 id="크기와-부하의-측면에서-경량-컨테이너로서-자바-객체를-직접관리한다"><a href="#크기와-부하의-측면에서-경량-컨테이너로서-자바-객체를-직접관리한다" class="headerlink" title="크기와 부하의 측면에서 경량 컨테이너로서 자바 객체를 직접관리한다."></a>크기와 부하의 측면에서 경량 컨테이너로서 자바 객체를 직접관리한다.</h4><ul><li>객체 생성, 소멸과 같은 라이프 사이클을 관리하며 스프링으로부터 필요한 객체를 얻어올 수 있다</li></ul></li><li><h4 id="제어-반전-혹은-제어-역행-IoC-Inversion-of-Control-을-지원한다"><a href="#제어-반전-혹은-제어-역행-IoC-Inversion-of-Control-을-지원한다" class="headerlink" title="제어 반전 혹은 제어 역행(IoC: Inversion of Control)을 지원한다."></a><strong>제어 반전</strong> 혹은 <strong>제어 역행</strong>(<code>IoC: Inversion of Control</code>)을 지원한다.</h4><ul><li>컨트롤의 제어권이 사용자가 아닌 프레임워크에 있어서 필요에 따라 스프링에서 사용자의 코드를 호출한다.</li><li>IoC는 DI와 DL에 의해 구현된다.<ul><li><strong>DL(Dependency Lookup)</strong> : 의존성 검색<ul><li>컨테이너에서는 객체들을 관리하기 위해 별도의 저장소에 빈을 저장하는데 저장소에 저장되어 있는 개발자들이 컨테이너에서 제공하는 API를 이용하여 사용하고자 하는 빈을 검색하는 방법</li></ul></li><li><strong>DI(Dependency Injection)</strong> : 의존성 주입<ul><li>의존성 주입이란 객체가 서로 의존하는 관계가 되게 의존성을 주입하는 것으로 객체지향 프로그램에서 의존성이란 하나의 객체가 어떠한 다른 객체를 사용하는 것을 의미한다.</li><li>IoC에선 각 클래스 사이에 필요로 하는 의존관계를 빈 설정 정보를 바탕으로 컨테이너가 자동으로 연결해 주는 것을 말한다.</li></ul></li></ul></li></ul></li><li><h4 id="POJO-Plain-Old-Java-Object-방식의-프레임워크이다"><a href="#POJO-Plain-Old-Java-Object-방식의-프레임워크이다" class="headerlink" title="POJO(Plain Old Java Object) 방식의 프레임워크이다."></a><strong>POJO</strong>(<code>Plain Old Java Object</code>) 방식의 프레임워크이다.</h4><ul><li><p>직역하면 <code>오래된 방식의 간단한 자바 오프젝트</code>라는 말이다.</p></li><li><p>일반적인 J2EE 프레임워크에 비해 구현을 위하여 특정한 인터페이스를 구현하거나 상속을 받을 필요가 없어 기존에 존재하는 라이브러리 등을 지원하기에 용이하고 객체가 가볍다.</p></li><li><p>쉽게 이야기하면 getter/setter 메소드로 이루어진 <code>Java Benas</code>를 생각하면 된다.</p></li><li><p>예를 들어 자바 서블릿 코드를 작성할 때는 보통 <code>HttpServlet</code>을 상속받아야 한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TestServlet extends HttpServlet &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이처럼 서블릿 프로그래밍을 하는 것만으로 객체지향 프로그래밍의 가장 핵심적인 기능 중 하나인 상속을 할 수 없고 HttpServlet에서 제공하는 기능을 어떻게 재사용할 것인지 판단해야하는 부분도 생겼다.</p></li><li><p>POJO는 이러한 제약이 없는 일반적인 객체를 말하는데 여기서 상속이나 인터페이스 구현을 사용하지 않는 객체가 아니라 어떠한 라이브러리나 프레임워크 등 자바 언어 사양 외에 어떠한 제한을 강제받지 않는 자바 오브젝트를 뜻하는 것이다.</p></li></ul></li><li><h4 id="관점-지향-프로그래밍-AOP-Aspect-Oriented-Programming-을-지원한다"><a href="#관점-지향-프로그래밍-AOP-Aspect-Oriented-Programming-을-지원한다" class="headerlink" title="관점 지향 프로그래밍(AOP: Aspect Oriented Programming)을 지원한다."></a>관점 지향 프로그래밍(<code>AOP: Aspect Oriented Programming</code>)을 지원한다.</h4><ul><li>기존의 객체지향 프로그래밍(<code>OOP: Object Oriented Programming</code>) 에서는 객체의 재사용으로 인해 반복되는 코드의 양을 줄일 수 있었지만 여전히 많은 부분에서 중복된 코드가 발생한다.</li><li>예를 들어 로그, 권한 체크, 인증, 예외 처리와 같은 소스상에서 반복될 수 밖에 없는 필수적인 요소들로 코드의 가독성이나 유지보수적인 측면에서 좋지 않았다.</li><li>AOP는 OOP를 대체하는 개념이 아닌 <code>OOP를 좀 더 OOP처럼 사용하기 위하여 보완하는 개념</code>으로 공통적으로 반드시 필요하지만 중복해서 작성해야하는 핵심 이외의 코드들을 외부로 분리하여 관리한다.</li><li>이렇게 외부에서 관리하는 공통기능을 핵심 로직에 영향을 끼치지 않게 잘 끼워넣어 개발하면 무분별하게 중복되는 코드를 제거하면서 공통기능의 수정을 통해 모든 핵심 로직의 공통기능을 수정하여 효율적인 유지보수가 가능해지면서 재활용성이 극대화된다.</li><li>즉, 위에서 예를 들었던 트랜잭션이나 로깅, 보안과 같이 여러 모듈에서 공통적으로 사용하는 기능의 경우 분리하여 관리할 수 있다는 것이다.</li></ul></li><li><h4 id="MVC-Model2"><a href="#MVC-Model2" class="headerlink" title="MVC (Model2)"></a>MVC (Model2)</h4><ul><li>MVC는 <code>Model, View, Controller</code> 를 뜻하며 사용자 인터페이스와 비즈니스 로직을 분리하여 개발하는 것으로 웹 프로그래밍 개발에선 거의 표준처럼 사용되고 있으며 일반적으로 Model2를 지칭한다.<ul><li><code>Model</code>은 데이터를 처리하는 영역</li><li><code>View</code>는 렌더링되서 실제로 보이는 화면</li><li><code>Controller</code>는 사용자의 요청을 받고, 응답을 주는 로직을 담당</li></ul></li><li>이처럼 소스를 분리하여 각 소스의 목적을 명확히하면 모듈화를 통해 재사용성을 늘리고 유지보수를 쉽게 할 수 있으며 확정성도 좋은 장점이 있다.</li><li>간단한 흐름을 살펴보면 <code>요청 -&gt; 컨트롤러 -&gt; 모델 -&gt; 컨트롤러 -&gt; 뷰</code> 의 흐름이라고 생각하면 된다.<br>(MVC와 관련된 자세한 내용은 추후 기회가 된다면 별도로 포스트하겠다.)</li></ul></li></ol><p>이상으로 스프링 프레임워크의 특징에 대하여 대략적으로 정리를 해보았다.</p><hr><p><em><strong>Reference</strong></em><br><a href="https://ko.wikipedia.org/">위키백과</a><br><a href="https://m.blog.naver.com/weekamp/186678831">POJO(Plain Old Java Object) 란?</a><br><a href="https://velog.io/@emawlrdl/Spring-%EA%B0%9C%EB%85%90-%EC%A0%95%EB%A6%AC-60k5hr47w2">Spring 개념 정리</a></p><hr>]]></content:encoded>
      
      
      <category domain="https://yoo0926.github.io/categories/spring/">spring</category>
      
      
      <category domain="https://yoo0926.github.io/tags/spring/">spring</category>
      
      
      <comments>https://yoo0926.github.io/2020/11/03/spring/%EA%B0%9C%EC%9A%94/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Git-flow의 활용</title>
      <link>https://yoo0926.github.io/2020/11/02/git/git-flow/</link>
      <guid>https://yoo0926.github.io/2020/11/02/git/git-flow/</guid>
      <pubDate>Mon, 02 Nov 2020 14:40:02 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;회사에서 내부서버에 Gitlab을 활용하여 Git Server를 구축하여 형상관리를 하고 있는데 특별한 관리나 체계없이 브랜치 관리를 하다보니 히스토리 파악하기도 힘들기도 하고 형상관리를 제대로 하고 있다는 느낌이 들지 않아 효율적인 형상관리 시</description>
        
      
      
      
      <content:encoded><![CDATA[<p>회사에서 내부서버에 Gitlab을 활용하여 Git Server를 구축하여 형상관리를 하고 있는데 특별한 관리나 체계없이 브랜치 관리를 하다보니 히스토리 파악하기도 힘들기도 하고 형상관리를 제대로 하고 있다는 느낌이 들지 않아 효율적인 형상관리 시스템의 사용을 위하여 방법을 찾던 중 <a href="https://woowabros.github.io/experience/2017/10/30/baemin-mobile-git-branch-strategy.html">우아한형제들 기술블로그의 “우린 Git-flow를 사용하고 있어요”</a> 라는 글을 보고 해당 전략을 도입하면서 각 브랜치에 대해 간략하게 정리를 해보았다.</p><p><img src="/img/programming/git/git-flow.png" alt="Git-flow"></p><p>Git-flow에는 5가지 종류의 브랜치가 존재한다. 항상 유지되는 메인 브랜치들(<code>master</code>, <code>develop</code>)과 일정 기간 동안만 유지되는 보조 브랜치들(<code>feature</code>, <code>release</code>, <code>hotfix</code>)이 있다.</p><ul><li><code>master</code> : 제품으로 출시될 수 있는 브랜치</li><li><code>develop</code> : 다음 출시 버전을 개발하는 브랜치</li><li><code>feature</code> : 기능을 개발하는 브랜치</li><li><code>release</code> : 이번 출시 버전을 준비하는 브랜치</li><li><code>hotfix</code> : 출시 버전에서 발생한 버그를 수정 하는 브랜치</li></ul><p>가장 중심이 되는 브랜치는 <code>master</code>랑 <code>develop</code> 브랜치이며, 이 두 개 브랜치는 무조건 있어야 한다. 이름은 바뀔 수 있다만 웬만해서는 변경하지 않고 진행하도록 하자. Git도 Production에서 사용하는 브랜치는 <code>master</code>를 사용하게 되니 관련된 부분을 변경하면 새로운 사람이 왔을때 스터디 커브가 존재할 수 있다.</p><p>병합된 <code>feature</code>, <code>release</code>, <code>hotfix</code> 브랜치는 삭제하도록 한다. (클라이언트 툴에서 git flow제공한다면 merge 하면 삭제하는 옵션을 제공한다.)</p><h3 id="Feature-브랜치"><a href="#Feature-브랜치" class="headerlink" title="Feature 브랜치"></a><strong>Feature 브랜치</strong></h3><ul><li>브랜치 나오는 곳 : <code>develop</code></li><li>브랜치가 들어가는 곳 : <code>develop</code></li><li>이름 지정 : <code>master</code>, <code>develop</code>, <code>release-*</code>, <code>hotfix-*</code>를 제외한 어떤 것이든 가능.</li></ul><p>새로운 기능을 추가하는 브랜치이다.<code>feature</code>브랜치는 <code>origin</code>에는 반영하지 않고, 개발자의 reop애만 존재하도록 한다.</p><p>여기서 머지를 할 때, <code>--no-ff</code> 옵션을 이용하여 브랜치에서 머지가 되었음을 git 기록에 남겨두도록 한다.</p><h3 id="Release-브랜치"><a href="#Release-브랜치" class="headerlink" title="Release 브랜치"></a><strong>Release 브랜치</strong></h3><ul><li>브랜치 나오는 곳 : <code>develop</code></li><li>브랜치가 들어가는 곳 : <code>develop</code>, <code>master</code></li><li>이름 지정 : <code>release-*</code></li></ul><p>새로운 Production 릴리즈를 위한 브랜치이다.지금까지 한 기능을 묶어 <code>develop</code> 브랜치에서 <code>release</code> 브랜치를 따내고, <code>develop</code> 브랜치에서는 다음번 릴리즈에서 사용할 기능을 추가한다.<code>release</code> 브랜치에서는 버그 픽스에 대한 부분만 커밋하고, <strong>릴리즈가 준비되었다고 생각하면</strong> <code>master</code>로 머지를 진행한다. (이때도 <code>--no-ff</code> 옵션을 이용하여 머지하였음을 남긴다.)<code>master</code>로 머지 후 <code>tag</code> 명령을 이용하여 릴리즈 버전에 대해 명시를 하고, <code>-s</code> 나 <code>-u &lt;key&gt;</code> 옵션을 이용하여 머지한 사람의 정보를 남겨두도록 한다. 그런 뒤 <code>develop</code> 브랜치로 머지하여, <code>release</code> 브랜치에서 수정된 내용이 <code>develop</code> 브랜치에 반영한다.</p><h3 id="Hotfix-브랜치"><a href="#Hotfix-브랜치" class="headerlink" title="Hotfix 브랜치"></a><strong>Hotfix 브랜치</strong></h3><ul><li>브랜치 나오는 곳 : <code>master</code></li><li>브랜치가 들어가는 곳 : <code>develop</code>, <code>master</code></li><li>이름 지정 : <code>hotfix-*</code></li></ul><p>Production에서 발생한 버그들은 전부 여기로… 수정 끝나면, <code>develop</code>, <code>master</code> 브랜치에 반영하고, <code>master</code>에 다가는 <code>tag</code> 를 추가해준다.만약 <code>release</code> 브랜치가 존재한다면, <code>release</code> 브랜치에 <code>hotfix</code> 브랜치를 머지하여 릴리즈 될 때 반영이 될 수 있도록 한다.</p><hr><p><em><strong>Reference</strong></em><br><a href="https://woowabros.github.io/experience/2017/10/30/baemin-mobile-git-branch-strategy.html">우아한형제들 기술블로그의 “우린 Git-flow를 사용하고 있어요”</a></p><hr>]]></content:encoded>
      
      
      <category domain="https://yoo0926.github.io/categories/git/">git</category>
      
      
      <category domain="https://yoo0926.github.io/tags/git/">git</category>
      
      
      <comments>https://yoo0926.github.io/2020/11/02/git/git-flow/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Github Page와 Hexo를 활용하여 블로그 개설하기</title>
      <link>https://yoo0926.github.io/2020/11/01/blog/start-blog/</link>
      <guid>https://yoo0926.github.io/2020/11/01/blog/start-blog/</guid>
      <pubDate>Sun, 01 Nov 2020 06:34:25 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;블로그를-시작하며&quot;&gt;&lt;a href=&quot;#블로그를-시작하며&quot; class=&quot;headerlink&quot; title=&quot;블로그를 시작하며&quot;&gt;&lt;/a&gt;블로그를 시작하며&lt;/h1&gt;&lt;p&gt;그동안 OneNote, Notion 등 노트프로그램을 사용하여 단편적으로 공</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="블로그를-시작하며"><a href="#블로그를-시작하며" class="headerlink" title="블로그를 시작하며"></a>블로그를 시작하며</h1><p>그동안 OneNote, Notion 등 노트프로그램을 사용하여 단편적으로 공부하던 내용을 블로그를 통해 좀 더 체계적으로 정리하고 다른사람들과 공유하고 싶은 생각에 블로그를 시작하기로 했다.<del>(끈기가 부족한 편이라 얼마나 갈진 모르겠다^^;;)</del></p><p><img src="/img/blog/github-hexo.png" alt="Github + Hexo"></p><p>일반적인 블로그를 생각하면 네이버 블로그, 티스토리, 혹은 미디엄, 브런치 등을 떠올릴 수 있지만 기술블로그를 표방하는만큼 github page를 이용하기로 마음먹었다. github page에서는 <code>username.github.io</code> 도메인을 무료로 제공하여 정적 웹페이지를 무료 호스팅해주고 있다.</p><p><code>github page</code>에서 사용할 정적 웹페이지 생성기는 생각보다 다양한 종류가 있지만 마크다운 문서를 지원하면서 국내에서 가장 많이 사용되는 두가지는 다음과 같다.</p><ol><li>Jekyll<ol><li><code>Ruby</code> 기반</li><li>다양한 테마, 플러그인 지원</li><li>환경설정 및 커스터마이징이 다소 복잡하며(특히 윈도우에서) 글이 많아지면 빌드속도가 느려진다는 이야기가 있다.</li></ol></li><li>Hexo<ol><li><code>Javascript(Node.js)</code> 기반</li><li>마찬가지로 다양한 테마, 플러그인 지원</li><li>npm을 통해 쉽게 설치 가능하며 Github 배포과정도 편하다.</li></ol></li></ol><p>처음엔 <code>Jekyll</code>을 사용하여 초기설정을 해봤는데 윈도우에서 설정이 너무 복잡하고 오류도 많이나서 익숙한 <code>Node.js</code>기반의 <code>Hexo</code>로 시작하기로 했다.</p><h2 id="1-설치"><a href="#1-설치" class="headerlink" title="1. 설치"></a>1. 설치</h2><h3 id="1-1-사전준비"><a href="#1-1-사전준비" class="headerlink" title="1.1 사전준비"></a>1.1 사전준비</h3><ul><li>Node.js 설치</li><li>Git 설치</li><li>Github 가입 후 <strong>신규 Repository 2개 생성</strong></li></ul><p>각 프로그램 설치는 이미 많은 문서들이 있기 때문에  별도로 언급하진 않겠다. Repository를 2개 생성하는 이유는 각각 블로그 운영, hexo 설정을 저장할 목적이며 블로그로 운영할 Repository name은 USERNAME.github.io 의 Public으로 생성한다.</p><h2 id="2-Hexo-설치-및-블로그-생성"><a href="#2-Hexo-설치-및-블로그-생성" class="headerlink" title="2. Hexo 설치 및 블로그 생성"></a>2. Hexo 설치 및 블로그 생성</h2><p>Hexo설정을 저장할 github repository를 clone 한 후 해당 위치에서 작업한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br><span class="line">hexo init $디렉토리명</span><br><span class="line"><span class="built_in">cd</span> $디렉토리명</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><h3 id="2-1-설정파일-수정"><a href="#2-1-설정파일-수정" class="headerlink" title="2.1 설정파일 수정"></a>2.1 설정파일 수정</h3><p>블로그 생성이 정상적으로 완료되었으면 이제 설정파일을 수정해보자.</p><p>root 경로에 <code>_config.yml</code>파일을 확인할 수 있는데 기본적인 블로그 설정은 이곳에서 관리한다.  자세한 내용은 공식문서에서 확인할 수 있다.</p><ul><li>Hexo Docs : <a href="https://hexo.io/docs/">https://hexo.io/docs/</a></li></ul><h4 id="Site-설정"><a href="#Site-설정" class="headerlink" title="Site 설정"></a>Site 설정</h4><p>블로그 이름 및 간략한 소개를 설정한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">title: Hello World</span><br><span class="line">subtitle: No pain, No gain</span><br><span class="line">description:</span><br><span class="line">author: Jaeyong Yoo</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h4 id="URL-설정"><a href="#URL-설정" class="headerlink" title="URL 설정"></a>URL 설정</h4><p>블로그 URL 정보를 설정한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">url: https:&#x2F;&#x2F;USERNAME.github.io</span><br><span class="line">root: &#x2F;</span><br><span class="line">permalink: :year&#x2F;:month&#x2F;:day&#x2F;:title&#x2F;</span><br><span class="line">permalink_defaults:</span><br></pre></td></tr></table></figure><h4 id="Github-설정"><a href="#Github-설정" class="headerlink" title="Github 설정"></a>Github 설정</h4><p>배포할 Github Page의 Repository 정보를 입력한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https:&#x2F;&#x2F;github.com&#x2F;yoo0926&#x2F;yoo0926.github.io</span><br></pre></td></tr></table></figure><p>정상적으로 설치와 설정이 끝났다면 아래 명령어로 서버를 실행시켜 웹브라우저에서 <a href="http://localhost:4000/">http://localhost:4000</a> 으로 접속하여 확인할 수 있다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo server <span class="comment">#or hexo s</span></span><br></pre></td></tr></table></figure><ul><li>만약 로컬에서 실행 시 permission denied 가 발생하는 경우가 있다면 그냥 port를 변경해서 테스트하자</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo server -p 8088</span><br></pre></td></tr></table></figure><h2 id="3-Github에-배포하기"><a href="#3-Github에-배포하기" class="headerlink" title="3. Github에 배포하기"></a>3. Github에 배포하기</h2><p>로컬에서 테스트가 완료되었다면 이제 앞서 언급한 Github Page의 정적 웹페이즈 호스팅을 사용해보자.</p><h4 id="Hexo-Generate-and-Deploy"><a href="#Hexo-Generate-and-Deploy" class="headerlink" title="Hexo Generate and Deploy"></a>Hexo Generate and Deploy</h4><p>github에 배포하기 위해선 <code>hexo-deployer-git</code> 이라는 플러그인을 설치해야 한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git</span><br></pre></td></tr></table></figure><p>플러그인 설치가 완료되면 배포할 리소스를 생성하여 앞서 <code>_config.yml</code> 파일에서 설정한 배포설정의 저장소로 배포하게 된다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo generate <span class="comment">#hexo g</span></span><br><span class="line">hexo deploy <span class="comment">#hexo d</span></span><br><span class="line"><span class="comment">#동시에 하고 싶으면</span></span><br><span class="line">hexo deploy --generate <span class="comment">#hexo d -g</span></span><br></pre></td></tr></table></figure><p>생성된 리소스는 USERNAME.github.io 저장소에 배포되며 <a href="https://username.github.io로/">https://USERNAME.github.io로</a> 접속하게되면 블로그를 확인할 수 있다.</p><h5 id="주의"><a href="#주의" class="headerlink" title="주의"></a>주의</h5><p>간혹 deploy가 정상적으로 되지 않는다면 아래 명령어로 clean 후 다시 배포를 해보자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo d -g</span><br></pre></td></tr></table></figure><p>이상으로 기본적인 블로그 생성과 관련된 내용을 마무리 한다.</p><hr><ul><li>추가메모</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo new 포스트명 //기본설정값 draft 로 바꿔놓음</span><br><span class="line">hexo publish 포스트명 //draft -&gt; posts 로 이동</span><br></pre></td></tr></table></figure><hr><p><em><strong>Reference</strong></em><br><a href="https://theserverside.tistory.com/282">Hexo로 github 블로그 만들기 (Hueman 테마)</a><br><a href="https://www.holaxprogramming.com/2017/04/16/github-page-and-hexo/">Github Page와 Hexo를 통해 30분만에 기술 블로그 만들기</a><br><a href="https://hexo.io/docs/">Hexo 공식문서</a></p><hr>]]></content:encoded>
      
      
      <category domain="https://yoo0926.github.io/categories/blog/">blog</category>
      
      
      <category domain="https://yoo0926.github.io/tags/blog/">blog</category>
      
      <category domain="https://yoo0926.github.io/tags/hexo/">hexo</category>
      
      
      <comments>https://yoo0926.github.io/2020/11/01/blog/start-blog/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
