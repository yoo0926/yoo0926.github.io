<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>하루하루 끄적끄적</title>
    <link>https://yoo0926.github.io/</link>
    
    <atom:link href="https://yoo0926.github.io/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>티끌모아 태산이라 티끌부터 모아본다.</description>
    <pubDate>Sun, 30 Jan 2022 07:23:40 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>Docker Desktop for window 경로 변경</title>
      <link>https://yoo0926.github.io/2022/01/08/docker/installation-directory/</link>
      <guid>https://yoo0926.github.io/2022/01/08/docker/installation-directory/</guid>
      <pubDate>Sat, 08 Jan 2022 07:19:32 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;회사pc에서 docker를 사용할 일이 있어서 설치를 하려는데 보안 프로그램 때문에 C드라이브에 제대로 설치가 안되는걸 확인했다.&lt;/p&gt;
&lt;p&gt;D드라이브에 설치를 하고 싶었는데 Docker Desktop for window 설치파일에서 설치경로를</description>
        
      
      
      
      <content:encoded><![CDATA[<p>회사pc에서 docker를 사용할 일이 있어서 설치를 하려는데 보안 프로그램 때문에 C드라이브에 제대로 설치가 안되는걸 확인했다.</p><p>D드라이브에 설치를 하고 싶었는데 Docker Desktop for window 설치파일에서 설치경로를 바꾸는 옵션을 제공하지 않고 있는데</p><p>🔗 <a href="https://github.com/docker/roadmap/issues/94">https://github.com/docker/roadmap/issues/94</a><br>(최근까지도 기다리는 사람이 많은듯?)</p><p>도커포럼에서 해당 이슈에 대한 임시 해결책으로 링크를 생성해서 설치경로를 바꾸는 방법이 있었다.</p><p>🔗 <a href="https://forums.docker.com/t/docker-installation-directory/32773/11">https://forums.docker.com/t/docker-installation-directory/32773/11</a></p><p>docker 설치 전 cmd를 관리자모드로 실행하고 아래 명령어를 실행한다.(xxx = 본인 계정)</p><p>만약 이미 한번 설치를 해서 각 위치에 폴더가 이미 생성된 상태라 C드라이브 경로에 생성된 폴더들 다 지우고 명령어 실행하면 된다. (타겟 경로의 폴더들은 나중에 만들어줘도 됨)</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mklink /j <span class="string">&quot;C:\ProgramData\Docker&quot;</span> <span class="string">&quot;D:\ProgramData\Docker&quot;</span></span><br><span class="line">mklink /j <span class="string">&quot;C:\ProgramData\DockerDesktop&quot;</span> <span class="string">&quot;D:\ProgramData\DockerDesktop&quot;</span></span><br><span class="line">mklink /j <span class="string">&quot;C:\Program Files\Docker&quot;</span> <span class="string">&quot;D:\Program Files\Docker&quot;</span></span><br><span class="line">mklink /j <span class="string">&quot;C:\Users\xxx\AppData\Local\Docker&quot;</span> <span class="string">&quot;D:\Users\xxx\AppData\Local\Docker&quot;</span></span><br></pre></td></tr></table></figure><p>이후 installer를 실행해보면 로그에는 C드라이브에 설치하는거로 나오지만 실제 파일은 링크를 걸어놓은 D드라이브에 생성되는 모습을 볼 수 있다.</p>]]></content:encoded>
      
      
      <category domain="https://yoo0926.github.io/categories/docker/">docker</category>
      
      
      <category domain="https://yoo0926.github.io/tags/docker/">docker</category>
      
      
      <comments>https://yoo0926.github.io/2022/01/08/docker/installation-directory/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Google Tag Manager 간단 정리</title>
      <link>https://yoo0926.github.io/2021/12/13/web/gtm-1/</link>
      <guid>https://yoo0926.github.io/2021/12/13/web/gtm-1/</guid>
      <pubDate>Mon, 13 Dec 2021 14:07:12 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;웹사이트 또는 모바일 앱에서 &lt;code&gt;태그&lt;/code&gt;라고 통칭되는 &lt;strong&gt;추적 코드 및 관련 코드 조각&lt;/strong&gt;을 쉽고 빠르게 업데이트할 수 있는 태그 관리 시스템&lt;/p&gt;
&lt;p&gt;여기서 태그는 웹페이지의 HTML 태그를 말하는게 </description>
        
      
      
      
      <content:encoded><![CDATA[<p>웹사이트 또는 모바일 앱에서 <code>태그</code>라고 통칭되는 <strong>추적 코드 및 관련 코드 조각</strong>을 쉽고 빠르게 업데이트할 수 있는 태그 관리 시스템</p><p>여기서 태그는 웹페이지의 HTML 태그를 말하는게 아니고 마케팅 업계에서 <strong>자바스크립트로 데이터를 수집해서 웹 분석 및 광고 성과 추적용도로 사용하기 위해 서비스 제공업체(구글,네이버,페이스북 등)로 전달하는 역할을 수행하는 기능</strong>을 말한다.</p><p><code>컨테이너 코드 스니펫</code>(컨테이너 생성 시 헤더, 바디에 심으라고 하는 코드)이라는 기본 스크립트를 소스코드에 한번 추가하면 이후 개발자가 관여하지 않더라도 GTM에서 제공하는 UI를 통해 태그를 효율적으로 추가,삭제,변경 등 관리하기 위해 사용한다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Google Tag Manager --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript">(<span class="function"><span class="keyword">function</span>(<span class="params">w,d,s,l,i</span>)</span>&#123;w[l]=w[l]||[];w[l].push(&#123;<span class="string">&#x27;gtm.start&#x27;</span>:</span></span><br><span class="line"><span class="javascript"><span class="keyword">new</span> <span class="built_in">Date</span>().getTime(),<span class="attr">event</span>:<span class="string">&#x27;gtm.js&#x27;</span>&#125;);<span class="keyword">var</span> f=d.getElementsByTagName(s)[<span class="number">0</span>],</span></span><br><span class="line"><span class="javascript">j=d.createElement(s),dl=l!=<span class="string">&#x27;dataLayer&#x27;</span>?<span class="string">&#x27;&amp;l=&#x27;</span>+l:<span class="string">&#x27;&#x27;</span>;j.async=<span class="literal">true</span>;j.src=</span></span><br><span class="line"><span class="javascript"><span class="string">&#x27;https://www.googletagmanager.com/gtm.js?id=&#x27;</span>+i+dl;f.parentNode.insertBefore(j,f);</span></span><br><span class="line"><span class="javascript">&#125;)(<span class="built_in">window</span>,<span class="built_in">document</span>,<span class="string">&#x27;script&#x27;</span>,<span class="string">&#x27;dataLayer&#x27;</span>,<span class="string">&#x27;GTM-A123456&#x27;</span>);</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- End Google Tag Manager --&gt;</span></span><br></pre></td></tr></table></figure><h2 id="컨테이너"><a href="#컨테이너" class="headerlink" title="컨테이너"></a>컨테이너</h2><p>태그를 관리하는 프로젝트 단위로 일반적으로 도메인별로 생성하며 <code>태그</code>,<code>트리거</code>,<code>변수</code> 3가지 요소를 사용해서 데이터를 추적</p><h2 id="변수-How"><a href="#변수-How" class="headerlink" title="변수(How)"></a>변수(How)</h2><p>특정 값을 담아두는 가상의 메모리 영역으로 어떠한 데이터를 수집할 지 지정하고 여러 이벤트에서 재사용하여 효율증가</p><blockquote><p>ex) 특정 페이지에 접속할때, 클릭할때 데이터를 수집할 경우 사전 정의된 url이라는 변수는 현재 로드중인 페이지의 URL을 변수로 사용할 수 있다.</p></blockquote><ul><li>트리거 : <strong>태그 실행 조건을 지정하는 필터를 정의하는 용도</strong> (ex: url 변수가 ‘example.com/index.html’일 때 페이지뷰 트리거를 실행하는 용도)</li><li>태그 : <strong>동적 값을 포착하여 전송</strong>하는 데 변수가 사용 (ex: 거래 금액과 구매 제품을 전환추적 태그에 전달하는 용도)</li></ul><p>기본 제공하는 변수로 처리할 수 없는 특정 요구사항에 맞추고 싶다면 <strong>사용자 정의 변수</strong>를 생성할 수 있다.</p><h2 id="트리거-When"><a href="#트리거-When" class="headerlink" title="트리거(When)"></a>트리거(When)</h2><p>태그(명령어)가 실행되는 조건을 정의하여 조건 충족 시 연결된 태그가 실행</p><blockquote><p>ex) 페이지뷰, 클릭할때 등 이벤트 실행 조건</p></blockquote><h2 id="태그-What"><a href="#태그-What" class="headerlink" title="태그(What)"></a>태그(What)</h2><p>데이터를 추적하여 수집하기 위해 명령하는 명령어의 역할로 트리거의 조건이 충족되면 태그가 인식하여 데이터를 추적하여 Google Analytics 등의 툴에서 데이터를 수집</p><p>쉽게 생각해서 트리거가 실행 조건을 담고 있고 태그는 실행 내용을 담고 있다고 생각하면 된다.</p><h2 id="데이터-영역-dataLayer"><a href="#데이터-영역-dataLayer" class="headerlink" title="데이터 영역(dataLayer)"></a>데이터 영역(dataLayer)</h2><p>웹사이트에서 태그 관리자 컨테이너로 정보를 전달할 때 사용되는 자바스크립트 객체</p><blockquote><p>웹사이트 –&gt; dataLayer &lt;–&gt; GTM –&gt; 구글 애널리틱스, 네이버광고 등</p></blockquote><p>구글 애널리틱스 사용 시 전자상거래 구매 데이터, 맞춤 측정기준에서 사용하는 데이터 등은 기본 추적코드만으로는 수집할 수 없어 추가적인 설정이 필요하다.</p><p>이때 주로 웹페이지 내 별도의 추적 코드를 소스코드에 삽입하여 이들 정보를 GA서버로 직접 보내는 방식을 사용하는데 GTM에선 이런 정보를 수집할 때 데이터 영역을 주로 사용한다.</p><p>코드 스니펫을 header에 추가하고</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.dataLayer = <span class="built_in">window</span>.dataLayer || [];</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>dataLayer.push()</code> 명령어를 사용하면 데이터 영역에 정보를 추가할 수 있다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;dataLayer.push(&#123;</span></span></span><br><span class="line"><span class="tag"><span class="string">    &#x27;bookCategory&#x27;: &#x27;fiction&#x27;,</span></span></span><br><span class="line"><span class="tag"><span class="string">    &#x27;bookTitle&#x27;: &#x27;Cien años de soledad&#x27;,</span></span></span><br><span class="line"><span class="tag"><span class="string">    &#x27;bookAuthor&#x27;: &#x27;Gabriel García Márquez&#x27;</span></span></span><br><span class="line"><span class="tag"><span class="string">&#125;);&quot;</span>&gt;</span>도서 세부정보<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>주의사항으로 GTM은 <code>컨테이너 스니펫</code> 실행 시 자동으로 데이터영역을 생성하며 이미 있는 경우 그 안의 변수를 가져다 사용하기 때문에 데이터영역은 GTM 컨테이너 스니펫보다 앞에 위치해야 한다고 한다.</p><hr><ul><li><p>그 외 태그,트리커,변수 생성 과정에 대한 자세한 방법은 아래 링크 참고</p><p>  <a href="https://marketology.co.kr/all-category/tag-manager/%EA%B5%AC%EA%B8%80-%ED%83%9C%EA%B7%B8-%EA%B4%80%EB%A6%AC%EC%9E%90-%EC%84%A4%EC%B9%98-%EB%B0%8F-%EC%82%AC%EC%9A%A9%EB%B2%95/">구글-태그-관리자-설치-및-사용법</a></p></li><li><p>태그, 트리거, 변수에서 설정가능한 유형에 대해선 태그 관리자 고객센터에서 각 항목 참고</p><ul><li><a href="https://support.google.com/tagmanager/?hl=ko#topic=3441647">태그 관리자 고객센터</a></li></ul></li></ul>]]></content:encoded>
      
      
      <category domain="https://yoo0926.github.io/categories/web/">web</category>
      
      
      <category domain="https://yoo0926.github.io/tags/web/">web</category>
      
      <category domain="https://yoo0926.github.io/tags/GTM/">GTM</category>
      
      
      <comments>https://yoo0926.github.io/2021/12/13/web/gtm-1/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>4-2. 리액터 프로젝트 심화학습</title>
      <link>https://yoo0926.github.io/2021/12/03/book/%EC%8B%A4%EC%A0%84-%EC%8A%A4%ED%94%84%EB%A7%815%EB%A5%BC-%ED%99%9C%EC%9A%A9%ED%95%9C-%EB%A6%AC%EC%95%A1%ED%8B%B0%EB%B8%8C-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/4-2/</link>
      <guid>https://yoo0926.github.io/2021/12/03/book/%EC%8B%A4%EC%A0%84-%EC%8A%A4%ED%94%84%EB%A7%815%EB%A5%BC-%ED%99%9C%EC%9A%A9%ED%95%9C-%EB%A6%AC%EC%95%A1%ED%8B%B0%EB%B8%8C-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/4-2/</guid>
      <pubDate>Fri, 03 Dec 2021 13:20:10 GMT</pubDate>
      
        
        
      <description>&lt;p align=&quot;center&quot;&gt;
  &lt;img src=&quot;/img/book/스프링5를-활용한-리액티브-프로그래밍/book-cover.jpg&quot; width=&quot;50%&quot;&gt;
&lt;/p&gt;

&lt;h2 id=&quot;리액티브-스트림의-수명-주기&quot;&gt;&lt;a href=&quot;#리액티브-스트림</description>
        
      
      
      
      <content:encoded><![CDATA[<p align="center">  <img src="/img/book/스프링5를-활용한-리액티브-프로그래밍/book-cover.jpg" width="50%"></p><h2 id="리액티브-스트림의-수명-주기"><a href="#리액티브-스트림의-수명-주기" class="headerlink" title="리액티브 스트림의 수명 주기"></a>리액티브 스트림의 수명 주기</h2><h3 id="조립-assembling-단계"><a href="#조립-assembling-단계" class="headerlink" title="조립(assembling) 단계"></a>조립(assembling) 단계</h3><ul><li>처리 흐름에서 사용하는 연산자를 조합한 빌더 API처럼 보이지만 일반적인 빌더 패턴과 달리 리액터 API는 불변성(Immutability)을 제공한다.(적용된 각각의 연산자가 새로운 객체를 생성한다.)</li><li>스트림 구성을 조작하고 더나은 스트림 전달을 위한 다양한 기술을 적용할 수 있는 단계</li></ul><h3 id="구독-단계"><a href="#구독-단계" class="headerlink" title="구독 단계"></a>구독 단계</h3><ul><li>특정 Publisher를 구독할 때 발생</li><li>조립 단계에서 일련의 Publisher 체인이 연결되었고 최상위 래퍼를 구독하면 해당 체인에 대한 구독 프로세스가 시작된다.</li><li>조립단계와 동일한 최적화를 수행할 수 있다.</li><li>리액터에서 멀티 스레딩을 지원하는 일부 연산자는 구독이 발생하는 작업자를 변경할 수 있다.</li></ul><h3 id="런타임-단계"><a href="#런타임-단계" class="headerlink" title="런타임 단계"></a>런타임 단계</h3><ul><li>게시자와 구독자 간에 실제 신호가 교환되는 단계</li><li>교환하는 처음 두 신호는 <code>onSubscribe</code>, <code>request</code><ul><li>onSubscribe 메서드는 최상위 소스에서 호출</li><li>구독이 모든 구독자 체인을 통과하여 마지막 구독자가 구독 체인에 대한 정보를 수신하고 메시지 수신을 시작하려면 Subscription#request 메서드를 호출해 전송을 시작해야 한다.</li></ul></li><li>런타임 중에도 request를 줄이기 위한 최적화를 적용할 수 있다.</li></ul><h2 id="리액터에서-스레드-스케줄링-모델"><a href="#리액터에서-스레드-스케줄링-모델" class="headerlink" title="리액터에서 스레드 스케줄링 모델"></a>리액터에서 스레드 스케줄링 모델</h2><p>멀티스레딩 실행을 위해 제공하는 연산자 사이의 차이점에 대해서 확인</p><p>다른 워커로 실행을 전환할 수 있는 네 가지 연산자</p><h3 id="publishOn-연산자"><a href="#publishOn-연산자" class="headerlink" title="publishOn 연산자"></a>publishOn 연산자</h3><ul><li>런타임 실행의 일부를 지정된 워커로 이동</li><li>Scheduler 인터페이스를 사용하여 현재 스트림에 대한 특정 워커를 선택할 수 있다.</li><li>내부적으로 전용 워커가 메시지를 하나씩 처리할 수 있도록 새로운 원소를 제공하는 큐를 가지고 있다.</li><li>리액티브 스트림의 모든 원소는 하나씩(동시에는 아니지만) 처리되므로 항상 모든 이벤트에 순서를 엄격하게 정의할 수 있다.(이 속성을 **직렬성(serializability)**라고 한다.)</li><li>병렬 처리를 할 수 없다는 말처럼 들리지만 병렬 처리도 가능한데 예를 들어 처리 단계 사이에 비동기 영역을 추가해서 독립적으로 작업해 비동기 처리를 할 수 있다.</li></ul><h3 id="subscribeOn-연산자"><a href="#subscribeOn-연산자" class="headerlink" title="subscribeOn 연산자"></a>subscribeOn 연산자</h3><ul><li>구독체인에서 워커의 작업 위치를 변경</li><li>보통 호출 시점에서 상위 스트림에 해당하는 부분의 스레드를 설정</li></ul><h3 id="parallel-연산자"><a href="#parallel-연산자" class="headerlink" title="parallel 연산자"></a>parallel 연산자</h3><ul><li>하위 스트림에 대한 플로 분할과 분할된 플로 간 균형 조정 역할<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Flux.range(<span class="number">0</span>, <span class="number">10000</span>)</span><br><span class="line">  .parallel()</span><br><span class="line">  .runOn(Schedulers.parallel())</span><br><span class="line">  .map()</span><br><span class="line">  .filter()</span><br><span class="line">  .subscribe()</span><br></pre></td></tr></table></figure></li><li>parallel연산자를 사용하면 <strong>ParallelFlux</strong>를 동작시킨다.<ul><li>다수의 Flux를 추상화하여 Flux간에 데이터의 크기 균형을 이룬다.</li></ul></li></ul><h3 id="Scheduler"><a href="#Scheduler" class="headerlink" title="Scheduler"></a>Scheduler</h3><ul><li><code>Scheduler.schedule</code> : Runnable 작업을 예약가능</li><li><code>Scheduler.createWorker</code> : 동일한 방법으로 Runnable 작업 예약이 가능한 Worker 인터페이스의 인스턴스를 제공</li><li>Scheduler인터페이스 / Workder인터페이스의 차이점 : 워커 풀 / Thread 또는 리소스를 추상화한 것</li><li>리액터에서 제공하는 스케줄러 인터페이스의 3가지 주요 구현체<ul><li><code>SingleScheduler</code> : 모든 작업을 한 개의 전용 워커에 예약가능, 시간에 의존적</li><li><code>ParallelScheduler</code> : 고정된 크기의 작업자 풀에서 작동(CPU 코어 수로 기본크기 제한)</li><li><code>ElasticScheduler</code> : 동적으로 작업자를 만들고 스레드 풀을 캐시, 생성된 스레드 풀의 최대 개수는 제한되지 않음</li></ul></li></ul><h3 id="리액터-컨텍스트"><a href="#리액터-컨텍스트" class="headerlink" title="리액터 컨텍스트"></a>리액터 컨텍스트</h3><ul><li>Context는 스트림을 따라 전달되는 인터페이스</li><li>런타임 단계에서 필요한 컨텍스트 정보에 엑세스할 수 있도록 하는 것</li><li>멀티스레드 환경의 비동기 처리방식에서 ThreadLocal가 가지는 한계를 해결할 수 있다.<ul><li>변수에 데이터를 넣은 후 publishOn 등을 통해 다른 워커에서 작업 플로를 수행하면 데이터를 쌓은 스레드와 작업 스레드가 달라서 데이터에 접근할 수 없다.</li></ul></li></ul>]]></content:encoded>
      
      
      <category domain="https://yoo0926.github.io/categories/book/">book</category>
      
      <category domain="https://yoo0926.github.io/categories/book/%EC%8B%A4%EC%A0%84-%EC%8A%A4%ED%94%84%EB%A7%815%EB%A5%BC-%ED%99%9C%EC%9A%A9%ED%95%9C-%EB%A6%AC%EC%95%A1%ED%8B%B0%EB%B8%8C-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/">실전! 스프링5를 활용한 리액티브 프로그래밍</category>
      
      
      <category domain="https://yoo0926.github.io/tags/spring/">spring</category>
      
      <category domain="https://yoo0926.github.io/tags/book/">book</category>
      
      
      <comments>https://yoo0926.github.io/2021/12/03/book/%EC%8B%A4%EC%A0%84-%EC%8A%A4%ED%94%84%EB%A7%815%EB%A5%BC-%ED%99%9C%EC%9A%A9%ED%95%9C-%EB%A6%AC%EC%95%A1%ED%8B%B0%EB%B8%8C-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/4-2/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>4. 리액터 프로젝트 - 리액티브 앱의 기초</title>
      <link>https://yoo0926.github.io/2021/12/03/book/%EC%8B%A4%EC%A0%84-%EC%8A%A4%ED%94%84%EB%A7%815%EB%A5%BC-%ED%99%9C%EC%9A%A9%ED%95%9C-%EB%A6%AC%EC%95%A1%ED%8B%B0%EB%B8%8C-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/4/</link>
      <guid>https://yoo0926.github.io/2021/12/03/book/%EC%8B%A4%EC%A0%84-%EC%8A%A4%ED%94%84%EB%A7%815%EB%A5%BC-%ED%99%9C%EC%9A%A9%ED%95%9C-%EB%A6%AC%EC%95%A1%ED%8B%B0%EB%B8%8C-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/4/</guid>
      <pubDate>Fri, 03 Dec 2021 12:15:32 GMT</pubDate>
      
        
        
      <description>&lt;p align=&quot;center&quot;&gt;
  &lt;img src=&quot;/img/book/스프링5를-활용한-리액티브-프로그래밍/book-cover.jpg&quot; width=&quot;50%&quot;&gt;
&lt;/p&gt;

&lt;p&gt;리액티브 스트림 스펙은 리액티브 라이브러리가 서로 호환할 수 있게 해주며</description>
        
      
      
      
      <content:encoded><![CDATA[<p align="center">  <img src="/img/book/스프링5를-활용한-리액티브-프로그래밍/book-cover.jpg" width="50%"></p><p>리액티브 스트림 스펙은 리액티브 라이브러리가 서로 호환할 수 있게 해주며 여러 중요한 개선 사항이 많았지만 API 및 규칙만 정의하고 일상적인 사용을 위한 라이브러리는 제공하지 않았다.</p><p>리액티브 프레임워크중에서 가장 유명한 라이브러리 중 하나인 <code>리액터 프로젝트(Project Reactor)</code>는 1.x 버전에서 리액터 패턴, 함수형 프로그래밍 및 리액티브 프로그래밍과 같은 메시지 처리에 대한 모범 사례를 통합하여 비동기 논블로킹 처리를 지원하도록 설계하였다.</p><p>이후 여러 부족한 부분들을 보완하면서 2.x를 거쳐 현재는 3.x 버전으로 릴리즈되어있다.</p><h2 id="리액터-프로젝트-필수-요소"><a href="#리액터-프로젝트-필수-요소" class="headerlink" title="리액터 프로젝트 필수 요소"></a>리액터 프로젝트 필수 요소</h2><ul><li>비동기 파이프라인을 구축할 때 <strong>콜백 지옥</strong>과 <strong>깊게 중첩된 코드</strong>를 생략</li><li>코드 <strong>가독성</strong>을 높이고 리액터 라이브러리에 의해 정의된 워크플로에 **조합성(composability)**을 추가</li><li>리액터 API는 연산자를 연결해서 사용하는 것을 권장하며 이를 통해 복잡하고 재사용 가능한 실행 그래프(execution graph)를 작성할 수 있다.<ul><li>그래프는 실행 흐름만 정의하며 구독자가 <strong>실제 구독을 했을 때만 데이터 플로가 기동</strong>된다.</li></ul></li><li>오류 발생 가능성이 있는 비동기 요청의 결과를 <strong>효율적으로 처리</strong>하여 유연하지만 <strong>복원력</strong> 있는 코드를 작성할 수 있다.</li></ul><p>배압은 리액티브 스트림 스펙의 핵심 속성으로 리액터 역시 동일하다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(데이터 플로)--▶️          --▶️         --▶️</span><br><span class="line">  게시자           연산자        연산자        구독자</span><br><span class="line">            ◀️--          ◀️--         ◀️--(요청)</span><br></pre></td></tr></table></figure><p>배압 전파의 일반적인 모드를 모두 지원</p><ul><li>푸시 전용 : subscription.request(Long.MAX_VALUE)</li><li>풀 전용 : subscription.request(1)</li><li>풀-푸시(혼합형) : 구독자가 수요를 실시간으로 제어할 수 있고 게시자가 데이터 소비 속도에 적응할 수 있는 경우</li><li>풀-푸시 모델을 지원하지 않는 이전 API를 적용할 때는 예전 스타일의 배압 메커니즘을 제공한다.</li></ul><h2 id="Flux와-Mono"><a href="#Flux와-Mono" class="headerlink" title="Flux와 Mono"></a>Flux와 Mono</h2><p>데이터를 기반으로 리액티브 스트림을 생성하는 팩토리 메서드를 제공</p><p>Mono는 Flux와 비슷하지만 하나의 요소를 대상으로 사용되는데 HTTP 요청이나 DB 쿼리와 같은 비동기 작업을 래핑하는데 매우 유용</p><p>Flux와 Mono는 구독 루틴을 단순화하는 <code>subscribe()</code> 메서드를 람다 기반으로 재정의한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Flux.just(<span class="string">&quot;A&quot;</span>,<span class="string">&quot;B&quot;</span>,<span class="string">&quot;C&quot;</span>)</span><br><span class="line">  .subscribe(</span><br><span class="line">    data -&gt; log.info(<span class="string">&quot;onNext: &#123;&#125;&quot;</span>, data),</span><br><span class="line">    err -&gt; &#123; <span class="comment">/* ignored */</span> &#125;,</span><br><span class="line">    () -&gt; log.info(<span class="string">&quot;onComplete&quot;</span>)</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">onNext: A</span></span><br><span class="line"><span class="comment">onNext: B</span></span><br><span class="line"><span class="comment">onNext: C</span></span><br><span class="line"><span class="comment">onComplete</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>또한 subscription으로 구독을 직접 제어하거나 직접 Subscriber 인터페이스를 구현하여 스트림을 구독할 수 있다.</p><h2 id="연산자를-이용해-리액티브-시퀀스-변환하기"><a href="#연산자를-이용해-리액티브-시퀀스-변환하기" class="headerlink" title="연산자를 이용해 리액티브 시퀀스 변환하기"></a>연산자를 이용해 리액티브 시퀀스 변환하기</h2><p>연산자의 종류가 너무 많아서 적절한 연산자를 선택하는 가이드를 포함한 아래 링크를 참조</p><p><a href="https://projectreactor.io/docs/core/release/reference/#which-operator">Which operator do I need?</a></p><ul><li>원소 매핑 : map(1:1) …</li><li>필터링 : filter …</li><li>시퀀스 수집? 합치기? : collectList() …</li><li>원소 줄이기 : reduce, scan …</li><li>스트림 조합 : concat, merge, zip …</li><li>스트림 내의 원소 일괄 처리<ul><li>buffer : List와 같은 컨테이너를 이용한 Buffering, <code>Flux&lt;List&lt;T&gt;&gt;</code></li><li>window : <code>Flux&lt;Flux&lt;T&gt;&gt;</code>와 같은 형태로 스트림을 스트림으로 Windowing</li><li>groupBy : <code>Flux&lt;GroupedFlux&lt;K, T&gt;&gt;</code> 유형의 스트림으로 Grouping</li></ul></li><li>flatmap : 논리적으로 map과 flatten의 2가지 작업으로 구성<ul><li>map파트는 들어오는 각 원소를 리액티브 스트림(<code>T -&gt; Flux&lt;R&gt;</code>)으로 변환</li><li>flatten파트는 생성된 모든 리액티브 시퀀스를 R 타입의 원소를 통과시키는 새로운 리액티브 시퀀스로 병합</li></ul></li><li>샘플링 : sample 연산자를 사용하여 특정 기간 내 최근에 관찰된 값을 주기적으로 출력할 수 있다.</li><li>블로킹 구조로 전환<ul><li>리액티브 애플리케이션에서 블로킹 처리를 해선 안되지만, 상위 API에서 필요로 하는 경우도 있음</li><li>blockFirst, blockLast, toIterable, toStream …</li><li><code>Mono#toFuture</code> 를 제외한 모든 메서드는 “non-blocking only”로 표시된 스케줄러에서 호출되면 UnsupportedOperatorException을 발생시킨다.</li></ul></li><li>시퀀스 엿보기<ul><li><code>doOnNext(Consumer &lt;T&gt;)</code>, <code>doOnComplete()</code>, <code>doOnError(Throwable)</code>…</li><li>최종 시퀀스를 수정하지 않고 프로세스 파이프라인의 중간에 있는 각 원소나 특정 시그널을 처리해야 하는 경우</li></ul></li></ul><h2 id="Hot-스트림과-cold-스트림"><a href="#Hot-스트림과-cold-스트림" class="headerlink" title="Hot 스트림과 cold 스트림"></a>Hot 스트림과 cold 스트림</h2><h3 id="1-콜드-퍼블리셔-cold-publisher"><a href="#1-콜드-퍼블리셔-cold-publisher" class="headerlink" title="1. 콜드 퍼블리셔(cold publisher)"></a>1. 콜드 퍼블리셔(cold publisher)</h3><ul><li>구독자가 나타날 때마다 시퀀스 데이터가 생성되는 방식</li><li>구독자 없이는 데이터 생성 X</li><li>대표적으로 HTTP 요청이 이런식으로 동작한다.<h3 id="2-핫-퍼블리셔-hot-publisher"><a href="#2-핫-퍼블리셔-hot-publisher" class="headerlink" title="2. 핫 퍼블리셔(hot publisher)"></a>2. 핫 퍼블리셔(hot publisher)</h3></li><li>데이터 생성 시 구독자의 존재 여부에 의존하지 않는 방식</li><li>첫 구독자가 없더라도 원소를 만들어 낼 수 있다.</li><li>이때 구독자가 나타나면 이전 생성값 말고 새로운 값만 보낼 수도 있다.</li><li>리액터 라이브러리에 포함된 대부분은 <code>Processor</code> 인터페이스를 상속한다.</li></ul><p>콜드 퍼블리셔를 리액티브 변환을 통해 핫 퍼블리셔로 전환할 수 있다.</p>]]></content:encoded>
      
      
      <category domain="https://yoo0926.github.io/categories/book/">book</category>
      
      <category domain="https://yoo0926.github.io/categories/book/%EC%8B%A4%EC%A0%84-%EC%8A%A4%ED%94%84%EB%A7%815%EB%A5%BC-%ED%99%9C%EC%9A%A9%ED%95%9C-%EB%A6%AC%EC%95%A1%ED%8B%B0%EB%B8%8C-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/">실전! 스프링5를 활용한 리액티브 프로그래밍</category>
      
      
      <category domain="https://yoo0926.github.io/tags/spring/">spring</category>
      
      <category domain="https://yoo0926.github.io/tags/book/">book</category>
      
      
      <comments>https://yoo0926.github.io/2021/12/03/book/%EC%8B%A4%EC%A0%84-%EC%8A%A4%ED%94%84%EB%A7%815%EB%A5%BC-%ED%99%9C%EC%9A%A9%ED%95%9C-%EB%A6%AC%EC%95%A1%ED%8B%B0%EB%B8%8C-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/4/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>3. 스트림의 새로운 표준 - 리액티브 스트림</title>
      <link>https://yoo0926.github.io/2021/11/28/book/%EC%8B%A4%EC%A0%84-%EC%8A%A4%ED%94%84%EB%A7%815%EB%A5%BC-%ED%99%9C%EC%9A%A9%ED%95%9C-%EB%A6%AC%EC%95%A1%ED%8B%B0%EB%B8%8C-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/3/</link>
      <guid>https://yoo0926.github.io/2021/11/28/book/%EC%8B%A4%EC%A0%84-%EC%8A%A4%ED%94%84%EB%A7%815%EB%A5%BC-%ED%99%9C%EC%9A%A9%ED%95%9C-%EB%A6%AC%EC%95%A1%ED%8B%B0%EB%B8%8C-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/3/</guid>
      <pubDate>Sun, 28 Nov 2021 11:13:34 GMT</pubDate>
      
        
        
      <description>&lt;p align=&quot;center&quot;&gt;
  &lt;img src=&quot;/img/book/스프링5를-활용한-리액티브-프로그래밍/book-cover.jpg&quot; width=&quot;50%&quot;&gt;
&lt;/p&gt;

&lt;h2 id=&quot;API-불일치-문제&quot;&gt;&lt;a href=&quot;#API-불일치-문제&quot; c</description>
        
      
      
      
      <content:encoded><![CDATA[<p align="center">  <img src="/img/book/스프링5를-활용한-리액티브-프로그래밍/book-cover.jpg" width="50%"></p><h2 id="API-불일치-문제"><a href="#API-불일치-문제" class="headerlink" title="API 불일치 문제"></a>API 불일치 문제</h2><p>CompletableStage를 이용하는 자바 코어 라이브러리와 RxJava 같은 다양한 라이브러리가 있어서, 코드를 작성할 때 다양한 선택을 할 수 있지만 과도하게 많은 선택지는 시스템을 지나치게 복잡하게 만들 수 있다.</p><p>핵심적인 문제는 라이브러리 공급자가 일관된 API를 만들어낼 수 있는 표준화된 방법이 없다는 사실이다.</p><h2 id="풀-방식과-푸시-방식"><a href="#풀-방식과-푸시-방식" class="headerlink" title="풀 방식과 푸시 방식"></a>풀 방식과 푸시 방식</h2><p>리액티브 초기 단계에서 모든 라이브러리의 데이터 흐름은 소스에서 구독자에게 푸시되는 방식이었다.</p><ul><li><p>풀 방식으로 요소를 하나씩 요청할 경우 비동기 논블로킹 방식을 사용하더라도 각 요소에 대한 요청을 처리 하면서 대기시간이 발생하여 전체 처리시간 중 많은 시간을 유휴 상태로 있게 된다.</p></li><li><p>푸시 방식을 도입하면서 요청하는 횟수를 최소화하여 전체 처리 시간을 최적화할 수 있었다.</p></li></ul><p><strong>하지만</strong> 푸시 모델만 사용하는 것은 기술적 한계가 있는데</p><ul><li>메시지 기반 통신의 본질은 <code>요청에 응답하는 것</code>인데</li><li>프로듀서가 컨슈머의 처리 능력을 무시하면 전반적인 시스템 안정성에 영향을 미칠 수 있기 때문이다.</li></ul><h2 id="흐름제어"><a href="#흐름제어" class="headerlink" title="흐름제어"></a>흐름제어</h2><ul><li><h3 id="느린-프로듀서와-빠른-컨슈머"><a href="#느린-프로듀서와-빠른-컨슈머" class="headerlink" title="느린 프로듀서와 빠른 컨슈머"></a>느린 프로듀서와 빠른 컨슈머</h3><p>  순수한 푸시 모델은 동적으로 시스템의 처리량을 증가시키는 것이 불가능하다.</p></li><li><h3 id="빠른-프로듀서와-느린-컨슈머"><a href="#빠른-프로듀서와-느린-컨슈머" class="headerlink" title="빠른 프로듀서와 느린 컨슈머"></a>빠른 프로듀서와 느린 컨슈머</h3><p>  프로듀서는 컨슈머가 처리할 수 있는 것보다 더 많은 데이터를 전송할 수 있으며 이로 인해 부하를 받는 컴포넌트에 치명적인 오류가 발생할 수 있다.</p></li></ul><p>이를 해결하기 위한 직관적인 방법은 <strong>큐에 수집하는 것</strong>인데 3가지 유형으로 구분할 수 있다.</p><ol><li>무제한 큐: 메모리 한도에 도달하면 전체 시스템이 손상될 가능성이 있다.(복원력이 떨어짐)</li><li>크기가 제한된 드롭 큐: 메시지의 중요성이 낮을 때 사용되는 방법으로 큐가 가득 차면 메시지를 무시하는데 중요한건 데이터 세트가 변경된다는 점이다.</li><li>크기가 제한된 블로킹 큐: 가장 느린 컨슈머의 처리량에 의해 시스템의 전체 처리량이 제한된다. 시스템의 비동기 동작을 모두 무효화하여 절대 받아들일 수 없는 시나리오다.</li></ol><p>이런 시스템 부하에 적절하게 대응하는 방법으로 <code>배압 제어 메커니즘</code>이 있다.</p><h2 id="리액티브-스트림의-기본-스펙"><a href="#리액티브-스트림의-기본-스펙" class="headerlink" title="리액티브 스트림의 기본 스펙"></a>리액티브 스트림의 기본 스펙</h2><p>리액티브 스트림 스펙에는 <code>Publisher</code>, <code>Subscriber</code>, <code>Subscription</code>, <code>Processor</code>의 네 가지 기본 인터페이스가 정의돼 있다.</p><ul><li><p>Publisher : Observable과 비교하면 Publisher와 Subscriber를 연결하기 위한 표준화된 진입점을 의미</p></li><li><p>Subscriber : Observer와 비슷한데 onSubscribe라는 추가 메서드를 제공하는데 Subscriber에게 구독이 성공했음을 알리는 API 메서드</p></li><li><p>Subscription : 원소 생성을 제어하기 위해 기본적인 사항을 제공</p><ul><li><p>cancel() : 스트림에서 구독을 취소하거나 발행을 완전히 취소 가능</p></li><li><p>request(long n) : 요청하는 Publisher가 보내줘야 하는 데이터 크기를 알려줄 수 있음 ▶️ Publisher에서 유입되는 원소의 개수가 처리할 수 있는 제한을 초과하지 않을 것을 확신할 수 있다.</p><p>리액티브 스트림은 순수 푸시 모델과는 달리 배압을 적절하게 제어할 수 있는 하이브리드 푸시-풀 모델을 제공한다.</p><ul><li>순수 푸시 모델을 사용하고 싶으면 최대 개수 요청 request(Long.MAX_VALUE)</li><li>순수 풀 모델을 사용하고 싶으면 onNext()가 호출될 때마다 요청</li></ul></li></ul></li><li><p>Processor : Publisher와 Subscriber의 혼합 형태로 Publisher와 Subscriber 사이에 몇가지 처리 단계를 추가하도록 설계됐다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Processor</span>&lt;<span class="title">T</span>, <span class="title">R</span>&gt; <span class="keyword">extends</span> <span class="title">Subscriber</span>&lt;<span class="title">T</span>&gt;, <span class="title">Publisher</span>&lt;<span class="title">R</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="리액티브-스트림-기술-호환성-키트-TCK"><a href="#리액티브-스트림-기술-호환성-키트-TCK" class="headerlink" title="리액티브 스트림 기술 호환성 키트(TCK)"></a>리액티브 스트림 기술 호환성 키트(TCK)</h2><p>모든 동작을 검증하고 반응 라이브러리를 표준화하여 서로 호환하는지 확인하는 공통 도구로 모든 리액티브 스트림 코드를 방어하고 지정된 규칙에 따라 구현을 테스트 한다.</p><p><a href="https://github.com/reactive-streams/reactive-streams-jvm/tree/master/tck">TCK github : https://github.com/reactive-streams/reactive-streams-jvm/tree/master/tck</a></p><hr><h2 id="리액티브-스트림을-활용한-비동기-및-병렬"><a href="#리액티브-스트림을-활용한-비동기-및-병렬" class="headerlink" title="리액티브 스트림을 활용한 비동기 및 병렬"></a>리액티브 스트림을 활용한 비동기 및 병렬</h2><ul><li><p>리액티브 스트림 API는 Publisher가 생성하고 Subscriber가 소비한 <strong>모든 신호는 처리 중에 논블로킹</strong>이어야 하며 방해받지 않아야 한다고 규칙에 명시되어 있다.</p></li><li><p>모든 프로세서나 코어를 효율적으로 사용하려면 <strong>병렬처리</strong>가 필요하고 이는 일반적으로 onNext 메서드를 병렬로 호출하는 것을 뜻하지만 on*** 메서드의 호출은 <strong>스레드 안전성을 보장하는 방식</strong>으로 신호를 보내야 하며 다중 스레드에서 수행되는 경우 <strong>외부적인 동기화를 사용</strong>해야 한다. <strong>즉, 스트림의 요소를 병렬 처리할 수 없다.</strong></p></li><li><p>자원을 효율적으로 활용하기 위해 스트림 처리 파이프의 각 단계에 메시지를 비동기적으로 전달하는 것이다.</p><ul><li>상황에 따라서 처리단계를 각각 별도의 스레드로 처리하고 각 스레드 사이에 큐와 같은 데이터 구조를 적용하여 메시지를 독립적으로 제공하고 사용하도록 할수 있다.</li></ul></li></ul>]]></content:encoded>
      
      
      <category domain="https://yoo0926.github.io/categories/book/">book</category>
      
      <category domain="https://yoo0926.github.io/categories/book/%EC%8B%A4%EC%A0%84-%EC%8A%A4%ED%94%84%EB%A7%815%EB%A5%BC-%ED%99%9C%EC%9A%A9%ED%95%9C-%EB%A6%AC%EC%95%A1%ED%8B%B0%EB%B8%8C-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/">실전! 스프링5를 활용한 리액티브 프로그래밍</category>
      
      
      <category domain="https://yoo0926.github.io/tags/spring/">spring</category>
      
      <category domain="https://yoo0926.github.io/tags/book/">book</category>
      
      
      <comments>https://yoo0926.github.io/2021/11/28/book/%EC%8B%A4%EC%A0%84-%EC%8A%A4%ED%94%84%EB%A7%815%EB%A5%BC-%ED%99%9C%EC%9A%A9%ED%95%9C-%EB%A6%AC%EC%95%A1%ED%8B%B0%EB%B8%8C-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/3/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>2. 스프링을 이용한 리액티브 프로그래밍 - 기본 개념</title>
      <link>https://yoo0926.github.io/2021/11/28/book/%EC%8B%A4%EC%A0%84-%EC%8A%A4%ED%94%84%EB%A7%815%EB%A5%BC-%ED%99%9C%EC%9A%A9%ED%95%9C-%EB%A6%AC%EC%95%A1%ED%8B%B0%EB%B8%8C-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/2/</link>
      <guid>https://yoo0926.github.io/2021/11/28/book/%EC%8B%A4%EC%A0%84-%EC%8A%A4%ED%94%84%EB%A7%815%EB%A5%BC-%ED%99%9C%EC%9A%A9%ED%95%9C-%EB%A6%AC%EC%95%A1%ED%8B%B0%EB%B8%8C-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/2/</guid>
      <pubDate>Sun, 28 Nov 2021 10:38:12 GMT</pubDate>
      
        
        
      <description>&lt;p align=&quot;center&quot;&gt;
  &lt;img src=&quot;/img/book/스프링5를-활용한-리액티브-프로그래밍/book-cover.jpg&quot; width=&quot;50%&quot;&gt;
&lt;/p&gt;

&lt;h2 id=&quot;관찰자-Observer-패턴&quot;&gt;&lt;a href=&quot;#관찰자-Obse</description>
        
      
      
      
      <content:encoded><![CDATA[<p align="center">  <img src="/img/book/스프링5를-활용한-리액티브-프로그래밍/book-cover.jpg" width="50%"></p><h2 id="관찰자-Observer-패턴"><a href="#관찰자-Observer-패턴" class="headerlink" title="관찰자(Observer) 패턴"></a>관찰자(Observer) 패턴</h2><ul><li>이벤트를 발생시키는 역할(주체<em>Subject</em>), 이벤트를 수신하는 역할(객체, 즉 관찰자<em>Observer</em>)의 두가지 핵심 요소가 존재</li><li><strong>Observer</strong>는 <strong>Subject</strong>에 등록되고 Subject로부터 알림을 수신</li></ul><p>Java의 내장 클래스인 Observable, Observer는 <strong>java9 부터 deprecated</strong> 되었다.</p><ul><li>interface가 아니라 class로 구현되어 있어서 이미 다른 클래스를 상속받은 클래스가 Observable을 상속할 수 없어서 재사용성에 제약이 생긴다.</li><li>Observable의 핵심 메소드 중 하나인 setChanged() 메소드가 protected로 정의되어 있어서 사용하려면 상속받은 서브클래스만 해당 메소드를 호출할 수 있다.</li><li>Observable의 알림은 순서를 보장할 수 없고 상태 변경 역시 1:1로 일치하지 않아서 멀티 스레드 환경에서 thread-safe 하지 않다.</li><li>Serializable을 구현하지 않기 때문에 Observable을 상속받은 서브클래스도 직렬화할 수 없다.</li></ul><h2 id="발행-구독-패턴"><a href="#발행-구독-패턴" class="headerlink" title="발행-구독 패턴"></a>발행-구독 패턴</h2><p>스프링 프레임워크는 이벤트처리를 위해 <code>@EventListener</code>어노테이션과 이벤트 발행을 위한 <code>ApplicationEventPublisher</code>클래스를 제공한다.</p><p>관찰자 패턴과의 차이점은 게시자와 구독자 사이에 간접적인 <code>이벤트 채널(=메시지 브로커 or 이벤트 버스)</code>을 제공하여 구독자는 이벤트 채널은 알고 있지만 게시자가 누구인지는 신경쓰지 않는다.</p><p><code>SseEmitter</code>를 사용하면 스프링 프레임워크를 브로커를 사용하여 발행-구독 패턴을 구현할 수 있다.<br>다만 로직을 구현함에 있어 스프링의 내부 메커니즘을 사용했고 이는 프레임워크의 변경으로 인해 프로그램의 안정성을 보장할 수 없는 단점이 있다.</p><h2 id="리액티브-프레임워크-RxJava"><a href="#리액티브-프레임워크-RxJava" class="headerlink" title="리액티브 프레임워크 RxJava"></a>리액티브 프레임워크 RxJava</h2><p>자바 플랫폼에서 리액티브 프로그래밍을 위한 표준 라이브러리는 RxJava 1.x 였고 현재(2021 기준)는 2.x를 지나 3.x까지 출시되었다.</p><p><code>RxJava</code> 라이브러리는 **Reactive Extensions(혹은 ReactiveX)**의 자바 구현체로 종종 관찰자 패턴, 반복자 패턴 및 함수형 프로그래밍의 조합으로 정의된다.</p><p>RxJava의 기본적인 Observer 인터페이스는 아래와 같이 설계할 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RxObserver</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onNext</span><span class="params">(T next)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onError</span><span class="params">(Exception e)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RxJava에서 아래와 같이 주기적으로 비동기 이벤트 시퀀스를 생성할 경우 이벤트가 생성되는 것과 별개의 스레드에서 사용되기 때문에 메인 스레드가 종료되지 않도록 sleep()을 쓰거나 다른<br>방법으로 종료를 지연시킬 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Observable.interval(<span class="number">1</span>, TimeUnit.SECONDS)</span><br><span class="line">    .subscribe(e -&gt; System.out.println(<span class="string">&quot;Received: &quot;</span> +e));</span><br><span class="line">    Thread.sleep(<span class="number">5000</span>);</span><br></pre></td></tr></table></figure><h2 id="마블-다이어그램"><a href="#마블-다이어그램" class="headerlink" title="마블 다이어그램"></a>마블 다이어그램</h2><p>RxJava는 연산자를 통해 스트림의 원소를 조정하거나 구조 자체를 변경할 수 있다. 연산자가 복잡한 변환을 수행할 경우 이를 시각적으로 표현하여 그 동작을 효과적으로 설명하기 위한 목적으로 <code>마블 다이어그램(marble diagram)</code>이 발명됐다.</p><p align="center">    <img src="/img/book/스프링5를-활용한-리액티브-프로그래밍/marble-1.png" width="70%"></p><ul><li>위아래 실선(ㅡ&gt;) : Observable의 시간흐름(Timeline)을 의미한다.</li><li>각 도형(○,□) : Observable에서 발행하는 데이터로 발행될때마다 <code>onNext</code> 메서드가 호출된다.</li><li>파이프(<code>|</code>) : 데이터 발행을 모두 완료했다는 의미로 <code>onCompleted</code> 메서드가 호출된다.</li><li>위에서 아래로 점선(—&gt;) : 함수의 입력,출력을 의미한다.</li><li>가운데 박스 : 함수를 의미하며 입력된 값에 어떤 변환작업을 하는지 나타내고 있다.</li><li>엑스(<code>X</code>) : 함수에서 입력된 값을 처리하는 중 에러가 발생하거나 비정상적으로 종료되었음을 의미하며 <code>onError</code> 메서드가 호출된다.</li></ul><p>RxJava와 관련된 모든 연산자는 이러한 마블다이어그램으로 표현되고 있으니 익숙해질 필요가 있다.</p>]]></content:encoded>
      
      
      <category domain="https://yoo0926.github.io/categories/book/">book</category>
      
      <category domain="https://yoo0926.github.io/categories/book/%EC%8B%A4%EC%A0%84-%EC%8A%A4%ED%94%84%EB%A7%815%EB%A5%BC-%ED%99%9C%EC%9A%A9%ED%95%9C-%EB%A6%AC%EC%95%A1%ED%8B%B0%EB%B8%8C-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/">실전! 스프링5를 활용한 리액티브 프로그래밍</category>
      
      
      <category domain="https://yoo0926.github.io/tags/spring/">spring</category>
      
      <category domain="https://yoo0926.github.io/tags/book/">book</category>
      
      
      <comments>https://yoo0926.github.io/2021/11/28/book/%EC%8B%A4%EC%A0%84-%EC%8A%A4%ED%94%84%EB%A7%815%EB%A5%BC-%ED%99%9C%EC%9A%A9%ED%95%9C-%EB%A6%AC%EC%95%A1%ED%8B%B0%EB%B8%8C-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/2/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>1. 왜 리액티브 스프링인가?</title>
      <link>https://yoo0926.github.io/2021/11/28/book/%EC%8B%A4%EC%A0%84-%EC%8A%A4%ED%94%84%EB%A7%815%EB%A5%BC-%ED%99%9C%EC%9A%A9%ED%95%9C-%EB%A6%AC%EC%95%A1%ED%8B%B0%EB%B8%8C-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/1/</link>
      <guid>https://yoo0926.github.io/2021/11/28/book/%EC%8B%A4%EC%A0%84-%EC%8A%A4%ED%94%84%EB%A7%815%EB%A5%BC-%ED%99%9C%EC%9A%A9%ED%95%9C-%EB%A6%AC%EC%95%A1%ED%8B%B0%EB%B8%8C-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/1/</guid>
      <pubDate>Sun, 28 Nov 2021 09:08:27 GMT</pubDate>
      
        
        
      <description>&lt;p align=&quot;center&quot;&gt;
  &lt;img src=&quot;/img/book/스프링5를-활용한-리액티브-프로그래밍/book-cover.jpg&quot; width=&quot;50%&quot;&gt;
&lt;/p&gt;

&lt;h2 id=&quot;리액티브-반응형-이-필요한-이유&quot;&gt;&lt;a href=&quot;#리액티브-반</description>
        
      
      
      
      <content:encoded><![CDATA[<p align="center">  <img src="/img/book/스프링5를-활용한-리액티브-프로그래밍/book-cover.jpg" width="50%"></p><h2 id="리액티브-반응형-이-필요한-이유"><a href="#리액티브-반응형-이-필요한-이유" class="headerlink" title="리액티브(반응형)이 필요한 이유"></a>리액티브(반응형)이 필요한 이유</h2><ul><li>증가하는 요청, 부하에 대해서 높은 응답성을 유지해야 한다.</li><li><strong>메시지 기반 통신</strong>을 바탕으로 <strong>탄력성</strong>과 <strong>복원력</strong>을 확보하하여 높은 응답성을 추구한다.</li></ul><h2 id="탄력성"><a href="#탄력성" class="headerlink" title="탄력성"></a>탄력성</h2><ul><li>자원을 비례적으로 추가하거나 제거하여 시스템의 처리량의 자동으로 증감 하는 것</li></ul><h2 id="복원력"><a href="#복원력" class="headerlink" title="복원력"></a>복원력</h2><ul><li>시스템의 실패에도 반응성을 유지하는 것</li><li>시스템의 기능 요소를 격리해 모든 내부 장애를 격리하고 독립성을 확보함으로써 달성</li></ul><h2 id="메시지-기반-통신-Message-driven"><a href="#메시지-기반-통신-Message-driven" class="headerlink" title="메시지 기반 통신(Message-driven)"></a>메시지 기반 통신(Message-driven)</h2><ul><li>제한된 리소스의 활용도를 높이기 위해서 비동기 논블로킹 모델을 사용해야 한다.</li><li>메시지 브로커를 사용하면 대기열을 모니터링하여 시스템의 부하관리 및 탄력성을 제어할 수 있다.</li></ul><p><a href="https://www.reactivemanifesto.org/ko/glossary">리액티브 선언문(https://www.reactivemanifesto.org/ko/glossary)</a></p>]]></content:encoded>
      
      
      <category domain="https://yoo0926.github.io/categories/book/">book</category>
      
      <category domain="https://yoo0926.github.io/categories/book/%EC%8B%A4%EC%A0%84-%EC%8A%A4%ED%94%84%EB%A7%815%EB%A5%BC-%ED%99%9C%EC%9A%A9%ED%95%9C-%EB%A6%AC%EC%95%A1%ED%8B%B0%EB%B8%8C-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/">실전! 스프링5를 활용한 리액티브 프로그래밍</category>
      
      
      <category domain="https://yoo0926.github.io/tags/spring/">spring</category>
      
      <category domain="https://yoo0926.github.io/tags/book/">book</category>
      
      
      <comments>https://yoo0926.github.io/2021/11/28/book/%EC%8B%A4%EC%A0%84-%EC%8A%A4%ED%94%84%EB%A7%815%EB%A5%BC-%ED%99%9C%EC%9A%A9%ED%95%9C-%EB%A6%AC%EC%95%A1%ED%8B%B0%EB%B8%8C-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/1/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>카카오톡 오픈그래프 캐시 삭제 방법</title>
      <link>https://yoo0926.github.io/2021/11/21/blog/ogimage-reset/</link>
      <guid>https://yoo0926.github.io/2021/11/21/blog/ogimage-reset/</guid>
      <pubDate>Sun, 21 Nov 2021 11:11:48 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;블로그 대표 이미지를 변경했음에도 카카오톡에 공유 시 기존 이미지가 계속 나오는 문제가 있었다.&lt;/p&gt;
&lt;p style=&quot;text-align:center&quot;&gt;
  &lt;img src=&quot;/img/blog/ogimage-reset/link_image1.p</description>
        
      
      
      
      <content:encoded><![CDATA[<p>블로그 대표 이미지를 변경했음에도 카카오톡에 공유 시 기존 이미지가 계속 나오는 문제가 있었다.</p><p style="text-align:center">  <img src="/img/blog/ogimage-reset/link_image1.png" alt="블로그 링크 이미지 변경 전"></p><p>사이트의 소스코드의 태그를 확인해봐도, 오픈그래프 적용을 확인해볼수 있는 페이스북의 <a href="https://developers.facebook.com/tools/debug/">Sharing Debugger</a> 사이트에서도 확인했을 때 문제가 없었으니</p><p>카카오에서 이미지 캐시가 문제라고 생각되서 구글링을 해봤고 역시 삭제하는 방법을 찾을 수 있었다.</p><h2 id="삭제방법"><a href="#삭제방법" class="headerlink" title="삭제방법"></a>삭제방법</h2><ol><li><p>카카오 개발자 사이트의 초기화 도구에서 <a href="https://developers.kakao.com/tool/clear/og">OG(Open Graph) 캐시</a>로 들어간다.</p></li><li><p>개발자 계정이 없다면 카카오 계정으로 간단하게 가입하고 있으면 로그인</p></li><li><p>삭제하려는 URL을 입력하고 초기화 한다.</p></li></ol><p style="text-align:center">  <img src="/img/blog/ogimage-reset/kakao_og_cache.png" alt="og 캐시 초기화"></p><p>이제 다시 카카오톡에 링크를 공유해보면 바뀐 이미지가 나오는걸 확인할 수 있다.</p><p style="text-align:center">  <img src="/img/blog/ogimage-reset/link_image2.png" alt="블로그 링크 이미지 변경 후"></p><hr><p>참고로 open graph 라는건 html 메타 태그의 종류 중 하나로 사용자가 링크를 sns의 입력창에 입력하면 크롤러가 미리 그 웹사이트를 방문해서 HTML head의 오픈그래프 메타 데이터를 긁어온다.</p><p>og:title, og:description, og:image 등 태그의 데이터를 바탕으로 미리보기 이미지와 설명을 만들어서 보여주게 된다.</p>]]></content:encoded>
      
      
      <category domain="https://yoo0926.github.io/categories/blog/">blog</category>
      
      
      <category domain="https://yoo0926.github.io/tags/blog/">blog</category>
      
      <category domain="https://yoo0926.github.io/tags/open-graph/">open graph</category>
      
      <category domain="https://yoo0926.github.io/tags/kakaotalk/">kakaotalk</category>
      
      
      <comments>https://yoo0926.github.io/2021/11/21/blog/ogimage-reset/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Angular 개요</title>
      <link>https://yoo0926.github.io/2021/11/13/angular/%EA%B0%9C%EC%9A%94/</link>
      <guid>https://yoo0926.github.io/2021/11/13/angular/%EA%B0%9C%EC%9A%94/</guid>
      <pubDate>Sat, 13 Nov 2021 09:12:57 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;회사 프론트엔드가 Angular로 되어있는데 이쪽을 메인잡으로 일하진 않지만 프론트 개발자를 많이 채용해서 완전히 업무를 분리하기 전까지 이쪽도 어느정도 할줄 알아야 할거같아서 Angular에 대해서 공부하면서 간단히 정리해보자&lt;/p&gt;
&lt;h2 i</description>
        
      
      
      
      <content:encoded><![CDATA[<p>회사 프론트엔드가 Angular로 되어있는데 이쪽을 메인잡으로 일하진 않지만 프론트 개발자를 많이 채용해서 완전히 업무를 분리하기 전까지 이쪽도 어느정도 할줄 알아야 할거같아서 Angular에 대해서 공부하면서 간단히 정리해보자</p><h2 id="Angular❓"><a href="#Angular❓" class="headerlink" title="Angular❓"></a>Angular❓</h2><p><strong>Angular</strong>는 Google에서 만든 **SPA(Single Page Application)**방식의 프론트엔드 개발을 위한 <strong>자바스크립트 프레임워크</strong> 이다.</p><p>개발언어로 es6, Dart 등을 지원하기도 하지만 공식적으로 <code>TypeScript</code>를 권장하고 있다.</p><p>Angular 1.x 버전을 AngularJS, Angular 2 이상 버전을 Angular 라고 부른다.</p><p>AngularJS와 Angular는 하위 호환성이 없는 브레이킹 체인지를 다수 포함하여 큰 차이점이 많은데 몇가지 정리를 하자면</p><ul><li><strong>Controller</strong>와 <strong>$scope</strong> 기반에서 <code>컴포넌트 기반 개발(CBD, Component Based Development)</code>로 전환되었다.</li><li>이전보다 향상된 모듈 시스템과 DOM 제어 기능을 제공하며 API가 단순화 되었다.</li><li>주력 개발언어로 <code>TypeScript</code>를 도입하여 대규모 개발에 적합한 정적타입과 인터페이스, 제네릭 등 타입체크지원 기능을 제공한다.</li><li>ECMAScript6에서 새롭게 도입된 모듈, 클래스, ECMAScript7의 데코레이터를 지원한다.</li><li>간단한 명령어로 개발환경을 지원하여 프로젝트 스케폴딩을 생성, 실행, 빌드할 수 있는 <code>Angular CLI</code>를 제공한다.</li></ul><h2 id="Angular-장점👍"><a href="#Angular-장점👍" class="headerlink" title="Angular 장점👍"></a>Angular 장점👍</h2><ol><li><strong>컴포넌트 기반</strong>의 기능에 따라 코드분리와 재사용성이 쉬운 장점이 있다.</li><li>SPA방식으로 다른 페이지로의 <strong>전환 속도</strong>가 빠르다.</li><li><strong>프레임워크</strong>로서 개발에 필요한 대부분의 기능을 탑재하고 있다.</li></ol><h2 id="Angular-단점👎"><a href="#Angular-단점👎" class="headerlink" title="Angular 단점👎"></a>Angular 단점👎</h2><ol><li>TypeScript를 주언어로 사용하여 이에 대한 학습이 필요하고 추가로 Angular의 여러 개념들과 기능들을 익혀야 하는만큼 <strong>학습량이 높은 편</strong>이다.</li><li>웹페이지가 모두 로딩된 이후 전환은 빠른편이지만 <strong>초기 로딩 시 느린 편</strong>이다.</li><li><strong>검색엔진 최적화</strong>가 잘 되지 않아서 구글을 제외한 다른 사이트들에서 제대로 수집되지 않는 경우가 있다고 한다.</li></ol>]]></content:encoded>
      
      
      
      
      <comments>https://yoo0926.github.io/2021/11/13/angular/%EA%B0%9C%EC%9A%94/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>유클리드 호제법</title>
      <link>https://yoo0926.github.io/2021/09/02/algo/%EC%9C%A0%ED%81%B4%EB%A6%AC%EB%93%9C-%ED%98%B8%EC%A0%9C%EB%B2%95/</link>
      <guid>https://yoo0926.github.io/2021/09/02/algo/%EC%9C%A0%ED%81%B4%EB%A6%AC%EB%93%9C-%ED%98%B8%EC%A0%9C%EB%B2%95/</guid>
      <pubDate>Thu, 02 Sep 2021 06:55:17 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;유클리드 호제법(Euclidean algorithm)은 최대공약수, 최소공배수를 구하는 가장 대중적인 알고리즘으로&lt;/p&gt;
&lt;p&gt;호제법이란 두 수가 서로 상대방 수를 나누어서 결국 원하는 수를 얻는 알고리즘을 말한다.&lt;/p&gt;
&lt;blockquote&gt;</description>
        
      
      
      
      <content:encoded><![CDATA[<p>유클리드 호제법(Euclidean algorithm)은 최대공약수, 최소공배수를 구하는 가장 대중적인 알고리즘으로</p><p>호제법이란 두 수가 서로 상대방 수를 나누어서 결국 원하는 수를 얻는 알고리즘을 말한다.</p><blockquote><p>2개의 자연수 a,b에 대해서 a를 b로 나눈 나머지를 r이라고 한다면 (단, a&gt;b)<br>a와 b의 최대공야수는 b와 r의 최대공약수와 같다.</p><p>이 성질에 따라, b를 r로 나눈 나머지 r’를 구하고, 다시 r을 r’로 나눈 나머지를 구하는 과정을 반복하여 나머지가 0이 되었을 때 나누는 수가 a와 b의 최대공약수이다.</p></blockquote><p>이해하기 쉽게 예를 들어 108과 78의 최대공약수를 구해보면 아래와 같은 연산을 할 수 있다.</p><blockquote><p>108 % 78 = 30 // 큰수를 작은수로 나누고 나머지를 구하기<br>78 % 30 = 18 // 위에서 나눈수(78)를 가져와 위의 나머지로 다시 나눠서 나머지 구하기<br>30 % 18 = 12 // 반복<br>18 % 12 = 6<br>12 % 6 = 0 // 나머지가 0이 되면 이때 나눈 수가 최대공약수(=6)</p></blockquote><p>그렇다면 최소공배수는 어떻게 구할까?</p><p>최소공배수의 규칙에서 두 수 a,b가 있을 때 <code>a * b = 최대공약수 * 최소공배수</code> 라는 공식이 성립한다.</p><p>따라서 주어진 두수를 곱하고 최대공약수로 나눠준다면 그 수가 최소공배수가 될 것이다.</p><blockquote><p>108 * 78 / 6 = 1404</p></blockquote><p>이를 간단하게 코드로 구현해보면 다음과 같다.</p><script src="https://gist.github.com/yoo0926/253e8a250ea26cb1689edb8f2f58c4ac.js"></script>]]></content:encoded>
      
      
      <category domain="https://yoo0926.github.io/categories/algorithm/">algorithm</category>
      
      
      <category domain="https://yoo0926.github.io/tags/algorithm/">algorithm</category>
      
      
      <comments>https://yoo0926.github.io/2021/09/02/algo/%EC%9C%A0%ED%81%B4%EB%A6%AC%EB%93%9C-%ED%98%B8%EC%A0%9C%EB%B2%95/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>기술면접 준비(Java)</title>
      <link>https://yoo0926.github.io/2021/08/21/interview/technical-1/</link>
      <guid>https://yoo0926.github.io/2021/08/21/interview/technical-1/</guid>
      <pubDate>Sat, 21 Aug 2021 08:25:36 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;내용은 기초적인 부분이지만 막상 면접 전에 한번이라도 정리하지 않으면 용어가 바로바로 안나오는 경우도 많기 때문에 간단하게나마 정리해 보았다.&lt;/p&gt;
&lt;h2 id=&quot;OOP란&quot;&gt;&lt;a href=&quot;#OOP란&quot; class=&quot;headerlink&quot; titl</description>
        
      
      
      
      <content:encoded><![CDATA[<p>내용은 기초적인 부분이지만 막상 면접 전에 한번이라도 정리하지 않으면 용어가 바로바로 안나오는 경우도 많기 때문에 간단하게나마 정리해 보았다.</p><h2 id="OOP란"><a href="#OOP란" class="headerlink" title="OOP란"></a>OOP란</h2><p><code>객체지향 프로그래밍(Object-Oriented Programming, OOP)</code>은 컴퓨터 프로그램을 명령어의 목록으로 보는 시각에서 벗어나 여러 개의 독립된 단위, 즉 “객체”들의 모임으로 파악하고자 하는 것 입니다. 각각의 객체는 메시지를 주고받고, 데이터를 처리할 수 있으며 대표적인 특징으로 추상화, 상속, 캡슐화, 다형성이 있습니다.</p><h2 id="직렬화-serialization-란"><a href="#직렬화-serialization-란" class="headerlink" title="직렬화(serialization)란?"></a>직렬화(serialization)란?</h2><p>객체 또는 데이터를 스트림을 통해 입출력하려면 <code>바이트(byte)형태로 변환</code>하는 것이 필요한데, 이를 <code>직렬화</code> 라고 합니다. 반대로 스트림을 통해 받은 직렬화된 객체를 원래 모양으로 만드는 과정을 <code>역직렬화</code>라고 합니다.</p><h2 id="박싱과-언박싱이란"><a href="#박싱과-언박싱이란" class="headerlink" title="박싱과 언박싱이란?"></a>박싱과 언박싱이란?</h2><p><strong>기본 자료형(Primitive data type)을 Wrapper class</strong>로 바꾸어 주는 것을 <code>박싱</code>, **Wrapper class를 기본 자료형(Primitive data type)**으로 바꿔주는 것을 <code>언박싱</code> 이라고 합니다.</p><h2 id="Static에-대해서"><a href="#Static에-대해서" class="headerlink" title="Static에 대해서"></a>Static에 대해서</h2><ul><li><code>static</code> 키워드를 쓰면 객체를 생성하지 않아도 static 변수나 static 함수를 사용할 수 있습니다.</li><li>인스턴스를 생성하면 각 인스턴스는 서로 독립적이기 때문에 서로 다른 값을 유지합니다.</li><li>각 인스턴스들이 공통적으로 같은 값이 유지되어야 하는 경우 static을 붙입니다.</li><li>static 이 붙은 메서드 에서는 인스턴스 변수를 사용할 수 없습니다.</li><li>메서드 내에서 인스턴스 변수를 쓰지 않는다면 가능하면 static을 붙이는게 호출 시간이 짧아지기 때문에 효율이 높아집니다.</li><li>클래스 설계시 static 사용 지침<ul><li>클래스의 멤버변수 중 모든 인스턴스에 공통된 값을 유지해야 하는 것이 있으면 static 을 사용합니다.</li><li>메서드 중에서 인스턴스 변수를 사용하지 않는 메서드는 static 을 사용하는 것을 고려합니다.</li></ul></li></ul><h2 id="접근-제어자에-대해서"><a href="#접근-제어자에-대해서" class="headerlink" title="접근 제어자에 대해서"></a>접근 제어자에 대해서</h2><ul><li>public : 어디서든 접근 가능</li><li>protected : 동일 패키지 혹은 상속받은 외부 패키지 클래스에서 사용</li><li>(default) : 동일 패키지 내에서만 접근 가능</li><li>private : 해당 클래스 내에서만 접근 가능</li></ul><h2 id="String-vs-StringBuffer-vs-StringBuilder"><a href="#String-vs-StringBuffer-vs-StringBuilder" class="headerlink" title="String vs StringBuffer vs StringBuilder"></a>String vs StringBuffer vs StringBuilder</h2><ul><li>String<ul><li><code>immutable(불변)</code></li><li>객체를 한 번 할당할시 <strong>메모리 공간에 변동이 없습니다</strong>.</li><li>동기화를 신경쓰지 않아도 됩니다.</li><li>엄청나게 많은 문자열을 선언 및 연산할 시 성능저하를 고려해야합니다.</li></ul></li><li>StringBuffer<ul><li><code>mutable(가변)</code></li><li>멀티스레드 환경에서도 <strong>동기화를 지원(Thread-safe)</strong></li></ul></li><li>StringBuilder<ul><li><code>mutable(가변)</code></li><li>동기화를 지원하지 <strong>않습니다</strong>.</li></ul></li><li>정리하면 적은 양의 문자열의 선언 후 연산이 필요없다면 String을 사용하고 문자열의 선언이 많이 필요하거나 연산이 필요한데 싱글스레드 환경이라면 StringBuilder를, 멀티스레드 환경이라면 StringBuffer를 사용합니다.</li></ul><h2 id="Java8-특징은"><a href="#Java8-특징은" class="headerlink" title="Java8 특징은?"></a>Java8 특징은?</h2><p>java에 <code>함수형 프로그래밍</code>이 처음으로 도입된 버전으로 새로 도입된 주요 기능으론<code>Lamda 표현식</code>, <code>Stream API</code>, <code>Optional Class</code> 같은 게 있습니다.</p><ul><li><p><strong>람다(Lamda) 표현식</strong></p><ul><li>익명함수로 이름과 식별자가 없는 함수를 말합니다. 불필요한 코드를 줄이고 가독성을 향상시키기 위함입니다.</li></ul>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list.forEach(num -&gt; System.out.println(<span class="string">&quot;number : &quot;</span> + num));</span><br></pre></td></tr></table></figure></li><li><p><strong>StreamAPI</strong></p><ul><li>람다식을 적용해서 컬렉션같은 데이터 처리연산을 하기 위한 api로 멀티 스레드를 활용해서 병렬로 연산을 수행할 수 있고, 원본 데이터를 변경하지 않는 특징이 있고 코드가 매우 간단해진다는 것을 알 수 있습니다.</li></ul></li><li><p><strong>Optional Class</strong></p><ul><li>util 패키지에 속하며 <code>NullPointException</code>을 관리하기 위해 null이 될 수 있는 객체를 감싸고 있는 래퍼 클래스입니다.</li><li>명시적으로 해당 변수가 null일 수 있음을 표현하면서 null 체크를 직접하지 않아도 됩니다.</li><li>아래는 일반적으로 많이 사용되는 optional 예제코드</li></ul>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">UserEntity</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">Optional&lt;UserEntity&gt; <span class="title">findByName</span><span class="params">(String Name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String name = <span class="string">&quot;jay&quot;</span>;</span><br><span class="line">UserEntity optUserEntity = userRepository.findByName(name)</span><br><span class="line">          .orElseThrow(() -&gt; <span class="keyword">new</span> EmptyDataException(<span class="string">&quot;해당 이름을 가진 유저가 없습니다.&quot;</span>));</span><br></pre></td></tr></table></figure></li></ul><h2 id="try-with-resource란"><a href="#try-with-resource란" class="headerlink" title="try-with-resource란?"></a>try-with-resource란?</h2><p>try-with-resources는 java7 이후 추가되었으며 <code>자동으로 자원을 해제해주는 기능</code>입니다.<br>try 구문에 <code>AutoCloseable 인터페이스</code>를 구현하는 객체를 리소스로 선언하고 사용이 끝나면 자동으로 close 해주는 기능입니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (Scanner scanner = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> File(<span class="string">&quot;newFile.txt&quot;</span>)))</span><br><span class="line">&#123;</span><br><span class="line">  System.out.println(scanner.nextLine());</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">  e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="오버로딩-오버라이딩-차이점은"><a href="#오버로딩-오버라이딩-차이점은" class="headerlink" title="오버로딩 오버라이딩 차이점은?"></a>오버로딩 오버라이딩 차이점은?</h2><p>자바에서 다형성을 지원하는 방법으로 오버로딩과 오버라이딩이 있습니다.</p><p>(다형성(polymorphism) : 하나의 객체가 여러타입을 가지는 것)</p><ul><li>오버로딩(Overloading)은 <code>같은 이름</code>의 메소드를 여러 개 가지면서 <code>매개변수의 유형과 개수가 다르도록</code> 작성하여 다양한 유형의 호출에 응답하도록 하는 것입니다.<ul><li>프로그램의 가독성 ⬆</li></ul></li><li>오버라이딩(Overriding)은 상위클래스가 가진 메소드를 <code>자식클래스에서 재정의</code> 하여 사용하는 것을 말합니다.<ul><li>하나의 코드로 여러 객체를 처리할 수 있는 장점이 있어서 사용</li></ul></li></ul><table><thead><tr><th>명칭</th><th>메소드명</th><th>매개변수</th><th>리턴타입</th></tr></thead><tbody><tr><td>오버로딩</td><td>같음</td><td>다름</td><td>같아도되고 달라도됨</td></tr><tr><td>오버라이딩</td><td>같음</td><td>같음</td><td>같아야함</td></tr></tbody></table><h2 id="HashMap-LinkedHashMap-TreeMap-비교"><a href="#HashMap-LinkedHashMap-TreeMap-비교" class="headerlink" title="HashMap, LinkedHashMap, TreeMap 비교"></a>HashMap, LinkedHashMap, TreeMap 비교</h2><ol><li>HashMap<ul><li>내부적으로 Entry의 array로 되어있고 해당 array에 index는 내부 해쉬 함수를 통해 계산합니다.</li><li>hashing을 사용하기 때문에 많은 양의 데이터를 검색하는데 뛰어난 성능을 가지고 있지만 내부 해시값에 따라서 키순서가 정해져서 특정 순서나 규칙없이 출력됩니다.</li></ul></li><li>LinkedHashMap<ul><li>내부적으로 LinkedList 형태로 저장되며 입력된 데이터의 순서를 유지할 수 있습니다.</li><li>HashMap과 기본적으로 기능은 동일하지만 순서를 유지하는 기능이 추가되면서 메모리 사용량이 더 높습니다.</li></ul></li><li>TreeMap<ul><li>Key값에 따라서 자동으로 Sort가 되는 방식이며 동기화(synchronized) 처리가 되어있어 Thread-safe 합니다.</li><li>HashMap과 다르게 키값으로 null을 허용하지 않고 내부적으로 red black tree 구조로 데이터를 저장합니다.<ul><li>red black tree 는 기존의 이진트리의 각 노드에 색깔을 저장하는 공간을 추가해서 색깔을 기준으로 균형을 맞추는 트리입니다.</li></ul></li><li>키값에 대한 Compartor(콤퍼레이터) 구현으로 정렬 순서를 변경할 수 있습니다.</li></ul></li></ol><p>정리하자면</p><ul><li>특별한 사유가 없다면 검색성능이 가장 좋은 HashMap 사용</li><li>순서를 보장하고 싶다면 LinkedHashMap 사용</li><li>키값을 일정하게 iterate 하고자한다면 TreeMap 사용</li></ul><h2 id="interface-vs-abstract"><a href="#interface-vs-abstract" class="headerlink" title="interface vs abstract"></a>interface vs abstract</h2><ul><li><p>공통점</p><ul><li>선언만 있고 구현 내용이 없습니다.</li><li>스스로 객체를 생성할 수 없지만 추상클래스를 <code>extends</code> 받거나, interface를 <code>implements</code>한 자식들만 객체를 생성할 수 있습니다.</li></ul></li><li><p><code>interface(인터페이스)</code></p><ul><li>다중 상속 가능</li><li>추상 메서드, 상수만 선언 가능(java8부터 default메서드 사용 가능)</li><li>생성자, 일반 변수를 가질 수 없음</li><li>서로 관련성이 없는 클래스들이 인터페이스를 구현하게 되는 경우</li><li>특정 데이터 타입의 행동을 명시하고 싶은데, 어디서 구현되든지 상관없을 때</li><li>다중상속을 허용하고 싶을 때</li></ul></li><li><p><code>abstract(추상 클래스)</code></p><ul><li>다중 상속 불가</li><li>추상 메서드 1개 이상, 일반 변수, 일반 메서드 선언 가능</li><li>생성자, 일반 변수 가질 수 있음</li><li>관련성이 높은 클래스간에 코드를 공유하고 싶은 경우</li><li>상속받은 클래스들이 공통적으로 가지는 메서드와 필드가 많거나, public 이외의 접근제어자 사용이 필요한 경우 사용할 수 있습니다.</li></ul></li></ul><h2 id="자바-메모리-구조"><a href="#자바-메모리-구조" class="headerlink" title="자바 메모리 구조"></a>자바 메모리 구조</h2><ul><li>메서드(Method) 영역<br>클래스 변수의 이름, 타입, 접근 제어자 등과 같은 <code>클래스와 관련된 정보를 저장</code>하며 static 변수, 전역변수 등이 저장된다.<br>코드에서 사용되는 클래스들을 로더가 읽고 클래스 별로 분류해서 저장합니다.</li><li>스택(Stack) 영역<br><code>메서드가 실행되면</code> 스택 영역에 메소드에 대한 영역이 1개 생기며 여기에 지역변수, 매개변수, 리턴값 등이 저장된다. LIFO(Last In First Out) 방식의 메모리입니다.</li><li>힙(Heap) 영역<br>new 연산자를 통해 생성된 객체와 배열의 인스턴스를 저장되고, 메모리는 가비지 컬렉터에 의해 관리됩니다.</li></ul>]]></content:encoded>
      
      
      <category domain="https://yoo0926.github.io/categories/interview/">interview</category>
      
      
      <category domain="https://yoo0926.github.io/tags/interview/">interview</category>
      
      
      <comments>https://yoo0926.github.io/2021/08/21/interview/technical-1/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[프로그래머스] 약수의 개수와 덧셈</title>
      <link>https://yoo0926.github.io/2021/06/10/algo/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EC%95%BD%EC%88%98%EC%9D%98-%EA%B0%9C%EC%88%98%EC%99%80-%EB%8D%A7%EC%85%88/</link>
      <guid>https://yoo0926.github.io/2021/06/10/algo/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EC%95%BD%EC%88%98%EC%9D%98-%EA%B0%9C%EC%88%98%EC%99%80-%EB%8D%A7%EC%85%88/</guid>
      <pubDate>Thu, 10 Jun 2021 09:39:40 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;🔗-출처&quot;&gt;&lt;a href=&quot;#🔗-출처&quot; class=&quot;headerlink&quot; title=&quot;🔗 출처&quot;&gt;&lt;/a&gt;🔗 출처&lt;/h3&gt;&lt;p&gt;약수의 개수와 덧셈 : &lt;a href=&quot;https://programmers.co.kr/learn/cour</description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="🔗-출처"><a href="#🔗-출처" class="headerlink" title="🔗 출처"></a>🔗 출처</h3><p>약수의 개수와 덧셈 : <a href="https://programmers.co.kr/learn/courses/30/lessons/77884">https://programmers.co.kr/learn/courses/30/lessons/77884</a></p><h2 id="📔-문제설명"><a href="#📔-문제설명" class="headerlink" title="📔 문제설명"></a>📔 문제설명</h2><p>두 정수 <code>left</code>와 <code>right</code>가 매개변수로 주어집니다. <code>left</code>부터 <code>right</code>까지의 모든 수들 중에서, 약수의 개수가 짝수인 수는 더하고, 약수의 개수가 홀수인 수는 뺀 수를 return 하도록 solution 함수를 완성해주세요.</p><h2 id="✅-제한사항"><a href="#✅-제한사항" class="headerlink" title="✅ 제한사항"></a>✅ 제한사항</h2><blockquote><p>1 ≤ left ≤ right ≤ 1,000</p></blockquote><h2 id="🔍-입출력-예"><a href="#🔍-입출력-예" class="headerlink" title="🔍 입출력 예"></a>🔍 입출력 예</h2><table><thead><tr><th>left</th><th>right</th><th>result</th></tr></thead><tbody><tr><td>13</td><td>17</td><td>43</td></tr><tr><td>24</td><td>27</td><td>52</td></tr></tbody></table><h2 id="📝-풀이"><a href="#📝-풀이" class="headerlink" title="📝 풀이"></a>📝 풀이</h2><p>어떤 자연수의 약수를 구하는 가장 쉬운 방법은 자연수 N을 <code>i = 1 ~ N</code> 까지 나눠서 나머지가 0으로 나오는 i의 개수를 찾으면 된다.</p><p>이러한 경우 최소값 1 ~ 자기자신 N까지 확인하므로 <code>시간복잡도는 O(n)</code> 이 나온다.</p><h3 id="더-빠르게"><a href="#더-빠르게" class="headerlink" title="더 빠르게"></a><em>더 빠르게</em></h3><p>여기서 약수의 특성에 대해서 조금 더 생각해 본다면 항상 약수는 그 짝이 되는 수가 존재한다. (ex. 15 = 3 * 5)</p><p>즉, N의 약수들 중 두 약수의 곱이 N이 되는 약수 a,b는 반드시 존재하므로 N의 제곱근까지 약수를 구하면 그 짝이 되는 약수는 자동으로 구했다고 볼 수 있다.</p><p>이 방법을 사용하여 약수를 구하면 <code>시간복잡도는 O(n^(1/2))</code> 이 나온다.</p><script src="https://gist.github.com/yoo0926/89b73775bb6cf38cb7c355f505c7b30a.js"></script><h3 id="➕-추가"><a href="#➕-추가" class="headerlink" title="➕ 추가"></a>➕ 추가</h3><p>프로그래머스에서 올린 해설을 찾아보니 애초에 문제에서 요구하는건 모든 약수를 구하는게 아니라 <em>약수의 개수가 짝수인건 더하고 홀수인건 빼는 것</em>이라서 약수가 홀수인지 짝수인지만 구하면 된다.</p><p>약수를 구해보면 약수가 홀수라면 그 수는 약수의 제곱수로 나오므로 매개변수 left ~ right 의 제곱수만 구하면 문제를 풀 수 있다.</p>]]></content:encoded>
      
      
      <category domain="https://yoo0926.github.io/categories/algorithm/">algorithm</category>
      
      <category domain="https://yoo0926.github.io/categories/algorithm/programmers/">programmers</category>
      
      
      <category domain="https://yoo0926.github.io/tags/algorithm/">algorithm</category>
      
      <category domain="https://yoo0926.github.io/tags/programmers/">programmers</category>
      
      <category domain="https://yoo0926.github.io/tags/java/">java</category>
      
      <category domain="https://yoo0926.github.io/tags/%EC%9B%94%EA%B0%84%EC%BD%94%EB%93%9C%EC%B1%8C%EB%A6%B0%EC%A7%80/">월간코드챌린지</category>
      
      
      <comments>https://yoo0926.github.io/2021/06/10/algo/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EC%95%BD%EC%88%98%EC%9D%98-%EA%B0%9C%EC%88%98%EC%99%80-%EB%8D%A7%EC%85%88/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[프로그래머스] 신규 아이디 추천</title>
      <link>https://yoo0926.github.io/2021/05/09/algo/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EC%8B%A0%EA%B7%9C-%EC%95%84%EC%9D%B4%EB%94%94-%EC%B6%94%EC%B2%9C/</link>
      <guid>https://yoo0926.github.io/2021/05/09/algo/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EC%8B%A0%EA%B7%9C-%EC%95%84%EC%9D%B4%EB%94%94-%EC%B6%94%EC%B2%9C/</guid>
      <pubDate>Sun, 09 May 2021 05:11:19 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;🔗-출처&quot;&gt;&lt;a href=&quot;#🔗-출처&quot; class=&quot;headerlink&quot; title=&quot;🔗 출처&quot;&gt;&lt;/a&gt;🔗 출처&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;신규 아이디 추천 : &lt;a href=&quot;https://programmers.co.k</description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="🔗-출처"><a href="#🔗-출처" class="headerlink" title="🔗 출처"></a>🔗 출처</h3><blockquote><p>신규 아이디 추천 : <a href="https://programmers.co.kr/learn/courses/30/lessons/72410">https://programmers.co.kr/learn/courses/30/lessons/72410</a></p></blockquote><h2 id="📔-문제-설명"><a href="#📔-문제-설명" class="headerlink" title="📔 문제 설명"></a>📔 문제 설명</h2><p>카카오에 입사한 신입 개발자 네오는 “카카오계정개발팀”에 배치되어, 카카오 서비스에 가입하는 유저들의 아이디를 생성하는 업무를 담당하게 되었습니다. “네오”에게 주어진 첫 업무는 새로 가입하는 유저들이 카카오 아이디 규칙에 맞지 않는 아이디를 입력했을 때, 입력된 아이디와 유사하면서 규칙에 맞는 아이디를 추천해주는 프로그램을 개발하는 것입니다.<br>다음은 카카오 아이디의 규칙입니다.</p><p>아이디의 길이는 3자 이상 15자 이하여야 합니다.<br>아이디는 알파벳 소문자, 숫자, 빼기(-), 밑줄(_), 마침표(.) 문자만 사용할 수 있습니다.<br>단, 마침표(.)는 처음과 끝에 사용할 수 없으며 또한 연속으로 사용할 수 없습니다.<br>“네오”는 다음과 같이 7단계의 순차적인 처리 과정을 통해 신규 유저가 입력한 아이디가 카카오 아이디 규칙에 맞는 지 검사하고 규칙에 맞지 않은 경우 규칙에 맞는 새로운 아이디를 추천해 주려고 합니다.<br>신규 유저가 입력한 아이디가 new_id 라고 한다면,</p><blockquote><p>1단계 new_id의 모든 대문자를 대응되는 소문자로 치환합니다.<br>2단계 new_id에서 알파벳 소문자, 숫자, 빼기(-), 밑줄(_), 마침표(.)를 제외한 모든 문자를 제거합니다.<br>3단계 new_id에서 마침표(.)가 2번 이상 연속된 부분을 하나의 마침표(.)로 치환합니다.<br>4단계 new_id에서 마침표(.)가 처음이나 끝에 위치한다면 제거합니다.<br>5단계 new_id가 빈 문자열이라면, new_id에 “a”를 대입합니다.<br>6단계 new_id의 길이가 16자 이상이면, new_id의 첫 15개의 문자를 제외한 나머지 문자들을 모두 제거합니다.<br>    만약 제거 후 마침표(.)가 new_id의 끝에 위치한다면 끝에 위치한 마침표(.) 문자를 제거합니다.<br>7단계 new_id의 길이가 2자 이하라면, new_id의 마지막 문자를 new_id의 길이가 3이 될 때까지 반복해서 끝에 붙입니다.</p></blockquote><p>신규 유저가 입력한 아이디를 나타내는 new_id가 매개변수로 주어질 때, “네오”가 설계한 7단계의 처리 과정을 거친 후의 추천 아이디를 return 하도록 solution 함수를 완성해 주세요.</p><h2 id="✅-제한사항"><a href="#✅-제한사항" class="headerlink" title="✅ 제한사항"></a>✅ 제한사항</h2><blockquote><p>new_id는 길이 1 이상 1,000 이하인 문자열입니다.<br>new_id는 알파벳 대문자, 알파벳 소문자, 숫자, 특수문자로 구성되어 있습니다.<br>new_id에 나타날 수 있는 특수문자는 -_.~!@#$%^&amp;*()=+[{]}:?,&lt;&gt;/ 로 한정됩니다.</p></blockquote><h2 id="🔍-입출력-예"><a href="#🔍-입출력-예" class="headerlink" title="🔍 입출력 예"></a>🔍 입출력 예</h2><table style="width:100%">  <thead style="background-color:#a1a1a1">    <tr>      <th style="color:white">no</th>      <th style="color:white">new_id</th>      <th style="color:white">result</th>    </tr>  </thead>  <tbody>    <tr>      <td>예1</td>      <td>"...!@BaT#*..y.abcdefghijklm"</td>      <td>"bat.y.abcdefghi"</td>    </tr>    <tr>      <td>예2</td>      <td>"z-+.^."</td>      <td>"z--"</td>    </tr>    <tr>      <td>예3</td>      <td>"=.="</td>      <td>"aaa"</td>    </tr>    <tr>      <td>예4</td>      <td>"123_.def"</td>      <td>"123_.def"</td>    </tr>    <tr>      <td>예4</td>      <td>"abcdefghijklmn.p"</td>      <td>"abcdefghijklmn"</td>    </tr>  </tbody></table><h2 id="📝-풀이"><a href="#📝-풀이" class="headerlink" title="📝 풀이"></a>📝 풀이</h2><p>정규식을 사용하면 어렵지 않게 풀 수있는데 정규식을 자주 쓰진 않아서 자세한 규칙들은 블로그를 검색해보고 정규식 검증은 <a href="https://regexr.com/">https://regexr.com</a>에서 진행했다.</p><script src="https://gist.github.com/yoo0926/9131c666c3fcd1d601b1fc92f291a8b0.js"></script>]]></content:encoded>
      
      
      <category domain="https://yoo0926.github.io/categories/algorithm/">algorithm</category>
      
      <category domain="https://yoo0926.github.io/categories/algorithm/programmers/">programmers</category>
      
      
      <category domain="https://yoo0926.github.io/tags/algorithm/">algorithm</category>
      
      <category domain="https://yoo0926.github.io/tags/programmers/">programmers</category>
      
      <category domain="https://yoo0926.github.io/tags/java/">java</category>
      
      <category domain="https://yoo0926.github.io/tags/kakao/">kakao</category>
      
      
      <comments>https://yoo0926.github.io/2021/05/09/algo/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EC%8B%A0%EA%B7%9C-%EC%95%84%EC%9D%B4%EB%94%94-%EC%B6%94%EC%B2%9C/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>5.중간메모</title>
      <link>https://yoo0926.github.io/2021/04/25/book/%EC%8A%A4%ED%94%84%EB%A7%81-%EB%B6%80%ED%8A%B8%EC%99%80-AWS%EB%A1%9C-%ED%98%BC%EC%9E%90-%EA%B5%AC%ED%98%84%ED%95%98%EB%8A%94-%EC%9B%B9%EC%84%9C%EB%B9%84%EC%8A%A4/5/</link>
      <guid>https://yoo0926.github.io/2021/04/25/book/%EC%8A%A4%ED%94%84%EB%A7%81-%EB%B6%80%ED%8A%B8%EC%99%80-AWS%EB%A1%9C-%ED%98%BC%EC%9E%90-%EA%B5%AC%ED%98%84%ED%95%98%EB%8A%94-%EC%9B%B9%EC%84%9C%EB%B9%84%EC%8A%A4/5/</guid>
      <pubDate>Sun, 25 Apr 2021 09:08:54 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;복습 겸 다시 프로젝트 생성해서 만들어보다가 몇가지 간략히 정리&lt;/p&gt;
&lt;h2 id=&quot;1-springboot에서-html파일을-templates에서-읽도록-하기&quot;&gt;&lt;a href=&quot;#1-springboot에서-html파일을-templates에서-읽</description>
        
      
      
      
      <content:encoded><![CDATA[<p>복습 겸 다시 프로젝트 생성해서 만들어보다가 몇가지 간략히 정리</p><h2 id="1-springboot에서-html파일을-templates에서-읽도록-하기"><a href="#1-springboot에서-html파일을-templates에서-읽도록-하기" class="headerlink" title="1. springboot에서 html파일을 templates에서 읽도록 하기"></a>1. springboot에서 html파일을 templates에서 읽도록 하기</h2><p>템플릿 엔진과 관련된 의존성을 추가하면 자동으로 <code>/recourses/templates</code> 아래에서 템플릿 파일을 찾도록 하는거 같은데 원래 기본 경로는 <code>/recourses/static</code> 이다.</p><p>따라서 별다른 설정을 하지 않고 html 파일을 templates 폴더 밑에 놓고 찾으려고 하면 당연히 404 에러를 볼수 밖에 없다.</p><p>html 파일을 templates 아래에 관리하고 싶다면 몇가지 작업을 해야하는데</p><p>우선 스프링부트에서 WebMVC 설정을 유지하면서 기능을 확장하기 위해 <code>WebMvcConfigurer</code>를 <code>implements</code> 하고 <code>addResourceHandlers</code> 를 오버라이드하여 아래와 같이 작성한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addResourceHandler(<span class="string">&quot;/**&quot;</span>)</span><br><span class="line">                .addResourceLocations(<span class="string">&quot;classpath:/templates/&quot;</span>)</span><br><span class="line">                .setCacheControl(CacheControl.maxAge(<span class="number">10</span>, TimeUnit.MINUTES));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="2-application-properties-gt-application-yml-변환"><a href="#2-application-properties-gt-application-yml-변환" class="headerlink" title="2. application.properties -&gt; application.yml 변환"></a>2. application.properties -&gt; application.yml 변환</h2><p>가독성 측면에서 yaml 파일이 더 좋아보여서 기존 내용을 변환해서 쓰려다보니 naver oauth2 설정을 하면 오류가 발생한다.</p><p><code>redirect-uri: &#39;&#123;baseUrl&#125;/&#123;action&#125;/oauth2/code/&#123;registrationId&#125;&#39;</code></p><p>yaml 에서는 / (슬러시)를 그대로 쓰면 파싱 에러가 난다. 따옴표나 작은 따옴표로 감싸주면 된다.</p>]]></content:encoded>
      
      
      <category domain="https://yoo0926.github.io/categories/book/">book</category>
      
      <category domain="https://yoo0926.github.io/categories/book/%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8%EC%99%80-AWS%EB%A1%9C-%ED%98%BC%EC%9E%90-%EA%B5%AC%ED%98%84%ED%95%98%EB%8A%94-%EC%9B%B9%EC%84%9C%EB%B9%84%EC%8A%A4/">스프링부트와 AWS로 혼자 구현하는 웹서비스</category>
      
      
      <category domain="https://yoo0926.github.io/tags/spring/">spring</category>
      
      <category domain="https://yoo0926.github.io/tags/book/">book</category>
      
      
      <comments>https://yoo0926.github.io/2021/04/25/book/%EC%8A%A4%ED%94%84%EB%A7%81-%EB%B6%80%ED%8A%B8%EC%99%80-AWS%EB%A1%9C-%ED%98%BC%EC%9E%90-%EA%B5%AC%ED%98%84%ED%95%98%EB%8A%94-%EC%9B%B9%EC%84%9C%EB%B9%84%EC%8A%A4/5/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>JWT 개요 간단 정리</title>
      <link>https://yoo0926.github.io/2021/04/23/web/jwt-1/</link>
      <guid>https://yoo0926.github.io/2021/04/23/web/jwt-1/</guid>
      <pubDate>Thu, 22 Apr 2021 15:07:49 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;1-JWT-Json-Web-Token-란&quot;&gt;&lt;a href=&quot;#1-JWT-Json-Web-Token-란&quot; class=&quot;headerlink&quot; title=&quot;1. JWT(Json Web Token)란&quot;&gt;&lt;/a&gt;1. JWT(Json Web Tok</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="1-JWT-Json-Web-Token-란"><a href="#1-JWT-Json-Web-Token-란" class="headerlink" title="1. JWT(Json Web Token)란"></a>1. JWT(Json Web Token)란</h1><p>JSON 객체를 사용해서 토큰 자체에 정보들을 저장하고 있는 Web Token 으로 가벼운 인증으로 사용이 쉽다. 일반적으로 클라이언트와 서버, 서비스와 서비스 사이 통신을 할 때 권한 인가(Authorization)을 위해서 사용된다.</p><h1 id="2-구조"><a href="#2-구조" class="headerlink" title="2. 구조"></a>2. 구조</h1><ul><li>Header : Signature를 해싱하기 위한 알고리즘 정보</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;alg&quot;</span> : <span class="string">&quot;HS256&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;typ&quot;</span> : <span class="string">&quot;JWT&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Payload : 서버와 클라이언트가 주고받는, 시스템에서 실제로 사용될 정보에 대한 내용들</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;name&quot;</span> : <span class="string">&quot;jy&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;iat&quot;</span> : <span class="number">1422779638</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Signature : 토큰의 유효성 검증을 위한 문자열로 헤더와 페이로드를 합친 문자열을 서명한 값이다. 헤더의 alg에 정의된 알고리즘과 secret을 이용해 해싱하고 이 값을 다시 base64 인코딩하여 생성한다.</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HMAC-SHA256(</span><br><span class="line"> secret,</span><br><span class="line"> base64urlEncoding(header) + &#x27;.&#x27; +</span><br><span class="line"> base64urlEncoding(payload)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>이 세 부분은 각각 Base64 인코딩을 사용하여 점을 사용해서 연결되면 JWT가 완성되며 주로 HTTP 통신 시 <code>Authorization</code> key의 value 로 사용된다.</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">                            <span class="comment">//Header                             Payload                                  Signature</span></span><br><span class="line">  <span class="attr">&quot;Authorization&quot;</span>: <span class="string">&quot;Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJuYW1lIjoiankiLCJpYXQiOjE0MjI3Nzk2Mzh9.SNKm-Pcut8DUMBmeQXdIJlM_wFkh4jYd5YtRT369JdI&quot;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-장점과-단점"><a href="#3-장점과-단점" class="headerlink" title="3. 장점과 단점"></a>3. 장점과 단점</h1><ul><li><p>장점</p><ul><li>중앙의 인증서버, 데이터 스토어에 대한 의존성이 없어서 시스템의 수평확장에 유리하다.</li><li>Base64 URL Safe Encoding을 사용하여 URL, Cookie, Header 어디에서든 모두 사용 가능하다.</li></ul></li><li><p>단점</p><ul><li>Payload의 정보가 많아지면 네트워크 사용량이 증가하여 데이터 설계 고려 필요</li><li>토큰이 클라이언트에 저장되서 서버에서 클라이언트의 토큰을 조작할 수 없다.</li></ul></li></ul>]]></content:encoded>
      
      
      <category domain="https://yoo0926.github.io/categories/web/">web</category>
      
      
      <category domain="https://yoo0926.github.io/tags/JWT/">JWT</category>
      
      <category domain="https://yoo0926.github.io/tags/web/">web</category>
      
      
      <comments>https://yoo0926.github.io/2021/04/23/web/jwt-1/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>4.머스테치로 화면 구성하기</title>
      <link>https://yoo0926.github.io/2021/04/22/book/%EC%8A%A4%ED%94%84%EB%A7%81-%EB%B6%80%ED%8A%B8%EC%99%80-AWS%EB%A1%9C-%ED%98%BC%EC%9E%90-%EA%B5%AC%ED%98%84%ED%95%98%EB%8A%94-%EC%9B%B9%EC%84%9C%EB%B9%84%EC%8A%A4/4/</link>
      <guid>https://yoo0926.github.io/2021/04/22/book/%EC%8A%A4%ED%94%84%EB%A7%81-%EB%B6%80%ED%8A%B8%EC%99%80-AWS%EB%A1%9C-%ED%98%BC%EC%9E%90-%EA%B5%AC%ED%98%84%ED%95%98%EB%8A%94-%EC%9B%B9%EC%84%9C%EB%B9%84%EC%8A%A4/4/</guid>
      <pubDate>Thu, 22 Apr 2021 09:08:51 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;4-머스테치로-화면-구성하기&quot;&gt;&lt;a href=&quot;#4-머스테치로-화면-구성하기&quot; class=&quot;headerlink&quot; title=&quot;4. 머스테치로 화면 구성하기&quot;&gt;&lt;/a&gt;4. 머스테치로 화면 구성하기&lt;/h1&gt;&lt;h2 id=&quot;4-1-서버-템플릿-</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="4-머스테치로-화면-구성하기"><a href="#4-머스테치로-화면-구성하기" class="headerlink" title="4. 머스테치로 화면 구성하기"></a>4. 머스테치로 화면 구성하기</h1><h2 id="4-1-서버-템플릿-엔진"><a href="#4-1-서버-템플릿-엔진" class="headerlink" title="4.1 서버 템플릿 엔진"></a>4.1 서버 템플릿 엔진</h2><p>템플릿 엔진이란, <strong>지정된 템플릿 양식과 데이터</strong>가 합쳐져 HTML문서를 출력하는 소프트웨어를 이야기한다.</p><p>서버 템플릿 엔진을 이용한 화면 생성은 서버에서 Java 코드로 문자열을 만든 뒤 이 문자열을 HTML로 변환하여 브라우저로 전달한다.</p><p>반면 클라이언트 템플릿 엔진(Vue, React 등)을 이용한 SPA(Single Page Application)은 브라우저에서 화면을 생성한다. 즉, 서버에서 이미 코드가 벗어난 경우라서</p><p>서버에서는 Json 혹은 Xml 형식의 데이터만 전달하고 클라이언트에서 조립한다.</p><p>최근엔 리액트나 뷰와 같은 자바스크립트 프레임워크에서 서버사이드렌더링을 지원하는 모습을 볼 수 있지만 그건 나중에 생각하자.</p><hr><h3 id="머스테치"><a href="#머스테치" class="headerlink" title="머스테치"></a>머스테치</h3><p>머스테치는 많은 언어를 지원하는 심플한 템플릿 엔진이다.</p><p>스프링 부트에서 공식 지원하는 템플릿 엔진으로 gradle에 의존성 한줄 추가하면 바로 사용할 수 있다.</p><p>파일위치는 기본적으로 <code>src/main/resources/templates</code>이며 이 위치에 머스테치 파일을 두면 스프링 부트에서 자동으로 로딩한다.</p><p>해당 위치에 index.mustache를 생성한 후 이 머스테치에 URL을 매핑하는데 이는 Controller에서 진행한다.</p><ul><li>IndexController</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>머스테치 스타터 의존성을 추가했기 때문에 컨트롤러에서 문자열을 반환할 때 <strong>앞의 경로와 뒤의 파일 확장자는 자동으로 지정</strong>된다.</p><p>즉, 여기선 “index”를 반환하므로 <code>src/main/resources/templates/index.mustache</code>로 전환되어 <strong>View Resolver</strong>가 처리하게 된다.</p><p>(View Resolver는 URL 요청의 결과를 전달할 타입과 값을 지정하는 관리자 격으로 볼 수 있다.)</p><hr><p>화면 구성 시 bootstrap을 사용하는데 공통된 부분에 대해선 layout을 따로 둬서 header와 footer 파일을 각각 만들어서 공통된 코드는 해당 위치에 생성한다.</p><p>여기서 <strong>페이지 로딩속도를 높이기 위해</strong> css는 header에, js는 footer에 두는데 HTML은 위에서부터 코드가 실행되기 때문에 head가 다 실행되고서야 body가 실행된다.</p><p>즉, head가 다 불러지지 않으면 사용자 쪽에선 백지 화면만 노출되며 특히 js의 용량이 크면 클수록 body 부분의 실행이 늦어지기 때문에 js는 body 하단에 두어 화면이 다 그려진 뒤에 호출하는 것이 좋다.</p><p>header와 footer를 index에 추가하는건 아래와 같다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;&gt;layout/header&#125;&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>스프링 부트로 시작하는 웹 서비스<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col-md-12&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;row&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col-md-6&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/posts/save&quot;</span> <span class="attr">role</span>=<span class="string">&quot;button&quot;</span> <span class="attr">clas</span>=<span class="string">&quot;btn btn-primary&quot;</span>&gt;</span>글 등록<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">&#123;&#123;&gt;layout/footer&#125;&#125;</span><br></pre></td></tr></table></figure><p><code>&#123;&#123;> &#125;&#125;</code> 는 현재 머스테치 파일을 기준으로 다른 파일을 가져온다.</p><p>화면의 버튼에 API를 호출하는 js파일을 작성하여 footer.mustache에 추가한다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://code.jquery.com/jquery-3.3.1.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--index.js 추가--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;/js/app/index.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>index.js 호출 코드는 절대경로(/)로 바로 시작하는데 스프링 부트는 기본적으로 <code>src/main/resources/static</code>에 위치한 자바스크립트, CSS, 이미지 등 정적 파일들은 URL에서 / 로 설정된다.</p><hr><ul><li>PostsRepository 인터페이스</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PostsRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">Posts</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Query(&quot;SELECT p FROM Posts p ORDER BY p.id DESC&quot;)</span></span><br><span class="line">    <span class="function">List&lt;Posts&gt; <span class="title">findAllDesc</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>@Query 어노테이션을 사용하면 SpringDataJpa에서 제공하지 않는 메소드를 쿼리로 직접 작성할 수 있다.</p><p>보통 규모가 있는 프로젝트에선 데이터 조회는 FK의 조인, 복잡한 조건 등으로 인해 Entity 클래스만으로 처리가 어려워 조회용 프레임워크를 추가로 사용한다.</p><p>대표적 예로 <code>querydsl</code>, jooq, MyBatis 등이 있는데 해당 프레임워크 중 하나로 조회를 하고 그 외 등록/수정/삭제 등은 SpringDataJpa를 통해 진행한다.</p><ul><li>PostsService</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="meta">@Transactional(readOnly = true)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;PostsListResponseDto&gt; <span class="title">findAllDesc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> postsRepository.findAllDesc().stream().map(PostsListResponseDto::<span class="keyword">new</span>).collect(Collectors.toList());</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>@Transactional 어노테이션에 추가된 readOnly 옵션을 true로 주면 <strong>트랜잭션 범위는 유지</strong>하되, 조회기능만 남겨두어 조회 속도가 개선되기 때문에 등록, 수정, 삭제 기능이 전혀 없는 서비스 메소드에서 사용하는 것을 추천한다.</p><hr><ul><li>IndexController</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PostsService postsService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">(Model model)</span> </span>&#123;</span><br><span class="line">        model.addAttribute(<span class="string">&quot;posts&quot;</span>, postsService.findAllDesc());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Model</p><ul><li>서버 템플릿 엔진에서 사용할 수 있는 객체를 저장할 수 있다.</li><li>여기서는 postsService.findAllDesc()로 가져온 결과를 posts로 index.mustache에 전달한다.</li></ul><hr><p>REST에서 CURD는 다음과 같이 HTTP Method에 매핑된다.</p><ul><li>생성(Create) : POST</li><li>읽기(Read) : GET</li><li>수정(Update) : PUT</li><li>삭제(Delete) : DELETE</li></ul>]]></content:encoded>
      
      
      <category domain="https://yoo0926.github.io/categories/book/">book</category>
      
      <category domain="https://yoo0926.github.io/categories/book/%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8%EC%99%80-AWS%EB%A1%9C-%ED%98%BC%EC%9E%90-%EA%B5%AC%ED%98%84%ED%95%98%EB%8A%94-%EC%9B%B9%EC%84%9C%EB%B9%84%EC%8A%A4/">스프링부트와 AWS로 혼자 구현하는 웹서비스</category>
      
      
      <category domain="https://yoo0926.github.io/tags/spring/">spring</category>
      
      <category domain="https://yoo0926.github.io/tags/book/">book</category>
      
      
      <comments>https://yoo0926.github.io/2021/04/22/book/%EC%8A%A4%ED%94%84%EB%A7%81-%EB%B6%80%ED%8A%B8%EC%99%80-AWS%EB%A1%9C-%ED%98%BC%EC%9E%90-%EA%B5%AC%ED%98%84%ED%95%98%EB%8A%94-%EC%9B%B9%EC%84%9C%EB%B9%84%EC%8A%A4/4/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>3.JPA로 데이터베이스 다루기</title>
      <link>https://yoo0926.github.io/2021/04/22/book/%EC%8A%A4%ED%94%84%EB%A7%81-%EB%B6%80%ED%8A%B8%EC%99%80-AWS%EB%A1%9C-%ED%98%BC%EC%9E%90-%EA%B5%AC%ED%98%84%ED%95%98%EB%8A%94-%EC%9B%B9%EC%84%9C%EB%B9%84%EC%8A%A4/3/</link>
      <guid>https://yoo0926.github.io/2021/04/22/book/%EC%8A%A4%ED%94%84%EB%A7%81-%EB%B6%80%ED%8A%B8%EC%99%80-AWS%EB%A1%9C-%ED%98%BC%EC%9E%90-%EA%B5%AC%ED%98%84%ED%95%98%EB%8A%94-%EC%9B%B9%EC%84%9C%EB%B9%84%EC%8A%A4/3/</guid>
      <pubDate>Thu, 22 Apr 2021 09:08:48 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;3-JPA&quot;&gt;&lt;a href=&quot;#3-JPA&quot; class=&quot;headerlink&quot; title=&quot;3 JPA&quot;&gt;&lt;/a&gt;3 JPA&lt;/h2&gt;&lt;p&gt;Posts 클래스는 실제 DB의 테이블과 매칭될 클래스로 &lt;code&gt;Entity 클래스&lt;/code&gt;라고 </description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="3-JPA"><a href="#3-JPA" class="headerlink" title="3 JPA"></a>3 JPA</h2><p>Posts 클래스는 실제 DB의 테이블과 매칭될 클래스로 <code>Entity 클래스</code>라고 부른다.</p><p>DB데이터에 작업할 경우 실제 쿼리를 날리기 보단 이 Entity 클래스의 수정을 통해 작업</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.jojoldu.book.springboot.domain.posts;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Builder;</span><br><span class="line"><span class="keyword">import</span> lombok.Getter;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.persistence.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1. @Entity</span></span><br><span class="line"><span class="comment">- 테이블과 링크될 클래스</span></span><br><span class="line"><span class="comment">- 기본값으로 클래스의 카멜케이스 이름을 언더스코어 네이밍(_)으로 테이블 이름을 매칭한다.</span></span><br><span class="line"><span class="comment">- ex) SalesManager.java -&gt; sales_manager table</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">아래 3개는 lombok 어노테이션</span></span><br><span class="line"><span class="comment">2. @NoArgsConstructor</span></span><br><span class="line"><span class="comment">- 기본생성자 자동추가</span></span><br><span class="line"><span class="comment">- public Posts() &#123;&#125; 와 같음</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">3. @Getter</span></span><br><span class="line"><span class="comment">- 클래스 내 모든 필드의 Getter 메소드 자동생성</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">4. @Builder</span></span><br><span class="line"><span class="comment">- 해당 클래스의 빌더 패턴 클래스를 생성</span></span><br><span class="line"><span class="comment">- 생성자 상단에 선언 시 생성자에 포함된 필드만 빌더에 포함</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Posts</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    1. @Id</span></span><br><span class="line"><span class="comment">    - PK 필드</span></span><br><span class="line"><span class="comment">    2. @GeneratedValue</span></span><br><span class="line"><span class="comment">    - PK 생성규칙</span></span><br><span class="line"><span class="comment">    - GenerationType.IDENTITY 옵션을 추가해야 auto_increment 된다.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    1. @Column</span></span><br><span class="line"><span class="comment">    - 선언하지 않더라도 해당 클래스의 필드는 모두 컬럼이 된다.</span></span><br><span class="line"><span class="comment">    - 옵션을 추가할 때만 선언해도 된다.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Column(length = 500, nullable = false)</span></span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(columnDefinition = &quot;TEXT&quot;, nullable = false)</span></span><br><span class="line">    <span class="keyword">private</span> String content;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String author;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Builder</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Posts</span><span class="params">(String title, String content, String author)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.title = title;</span><br><span class="line">        <span class="keyword">this</span>.content = content;</span><br><span class="line">        <span class="keyword">this</span>.author = author;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Entity 클래스는 Setter 메소드를 만들지 않고 해당 필드의 값 변경이 필요하면 명확히 그 목적과 의도를 나타낼 수 있는 메소드를 추가해야 한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancelOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.status = <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> 주문서비스의_취소이벤트() &#123;</span><br><span class="line">  order.cancelOrder();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>기본적인 구조는 <strong>생성자를 통해</strong> 최종값을 채운 후 DB에 삽입하는 것이고 값 변경이 필요하면 해당 이벤트에 맞는 public 메소드를 호출하여 변경하는 것을 전제로 한다.</p><p>생성시점에 값을 넣는 방법으로 생성자와 <strong>@Builder</strong>를 통해 제공되는 빌더 클래스를 사용할 수 있는데 차이점이 있다면</p><p>생성자는 new Example(b,a)처럼 파라미터의 위치를 바꾸더라도 실제 실행 전까지 문제를 찾기 어렵다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Example</span><span class="params">(String a, String b)</span></span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.a = a;</span><br><span class="line">  <span class="keyword">this</span>.b = b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>빌더를 사용한다면 어느 필드에 어떤 값을 채워야할 지 명확하게 인지할 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Example.builder()</span><br><span class="line">  .a(a)</span><br><span class="line">  .b(b)</span><br><span class="line">  .build();</span><br></pre></td></tr></table></figure><p>Posts클래스(Entity) 생성이 끝나면 해당 클래스로 Database를 접근하게 해줄 JpaRepository를 생성한다.</p><ul><li>src/main/java/com/jojoldu/book/springboot/domain/posts/PostsRepository<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.data.jpa.repository.JpaRepository;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PostsRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">Posts</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>보통 ibatis나 MyBatis 등에서 Dao라고 불리는 DB Layer 접근자를 JPA에선 Repository 라고 부르며 인터페이스로 생성한다.</li></ul><p>생성 후, <code>JpaRepository&lt;Entity 클래스, PK 타입&gt;</code> 를 상속하면 기본적인 CRUD 메소드가 자동으로 생성된다.</p><p>@Repositry 어노테이션을 추가할 필요는 없지만 Entity 클래스와 기본 Entity Repository는 함께 위치해야 한다.</p><p>생성한 Repository 를 테스트하기 위해 아래 코드를 작성하며 테스트할 기능은 <strong>save</strong>, <strong>findAll</strong> 기능이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.jojoldu.book.springboot.domain.posts;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.AfterEach;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.extension.ExtendWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit.jupiter.SpringExtension;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.assertj.core.api.Assertions.assertThat;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">별다른 설정없이 @SpringBootTest를 사용할 경우 H2 데이터베이스를 자동으로 실행한다.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@ExtendWith(SpringExtension.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PostsRepositoryTest</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    PostsRepository postsRepository;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    1. @AfterEach</span></span><br><span class="line"><span class="comment">    - Junit에서 단위테스트가 끝날 때마다 수행되는 메소드를 지정한다.</span></span><br><span class="line"><span class="comment">    - 보통은 배포 전 전체 테스트를 수행할 때 테스트간 데이터 침범을 막기 위해 사용된다.</span></span><br><span class="line"><span class="comment">    - Junit4 -&gt; 5로 넘어가면서 After -&gt; AfterEach 로 변경되었다.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@AfterEach</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cleanup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        postsRepository.deleteAll();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> 게시글저장_불러오기() &#123;</span><br><span class="line">        <span class="comment">//given</span></span><br><span class="line">        String title = <span class="string">&quot;테스트 게시글&quot;</span>;</span><br><span class="line">        String content = <span class="string">&quot;테스트 본문&quot;</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        2. postsRepository.save</span></span><br><span class="line"><span class="comment">        - 테이블 posts에 insert/update 쿼리를 실행한다.</span></span><br><span class="line"><span class="comment">        - id값이 있으면 update, 없다면 insert 쿼리가 실행된다.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        postsRepository.save(Posts.builder()</span><br><span class="line">                .title(title)</span><br><span class="line">                .content(content)</span><br><span class="line">                .author(<span class="string">&quot;jojoldu@gmail.com&quot;</span>)</span><br><span class="line">                .build());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        3. postsRepository.findAll</span></span><br><span class="line"><span class="comment">        - 테이블 posts에 있는 모든 데이터를 조회해오는 메소드</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//when</span></span><br><span class="line">        List&lt;Posts&gt; postsList = postsRepository.findAll();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//then</span></span><br><span class="line">        Posts posts = postsList.get(<span class="number">0</span>);</span><br><span class="line">        assertThat(posts.getTitle()).isEqualTo(title);</span><br><span class="line">        assertThat(posts.getContent()).isEqualTo(content);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="3-4-등록-수정-조회-API-만들기"><a href="#3-4-등록-수정-조회-API-만들기" class="headerlink" title="3.4 등록/수정/조회 API 만들기"></a>3.4 등록/수정/조회 API 만들기</h2><p>API를 만들기 위해 총 3개의 클래스가 필요하다.</p><ul><li>Request 데이터를 받을 Dto</li><li>API 요청을 받을 Controller</li><li>트랜잭션, 도메인 기능 간의 순서를 보장하는 Service</li></ul><p>여기서 Service는 <strong>비지니스 로직을 처리하는 것이 아니라</strong> 트랜잭션, 도메인 간 순서 보장의 역할만 한다.</p><p><strong>Web, Service, Repository, Dto, Domain</strong> 이 5가지 레이어에서 비지니스 처리를 담당해야 할 곳은 **<code>Domain</code>**이다.</p><p>기존에 서비스로 처리하던 방식을 <strong>트랜잭션 스크립트</strong>라고 한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Order <span class="title">cancelOrder</span><span class="params">(<span class="keyword">int</span> orderId)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//1) 데이터베이스로부터 주문정보, 결제정보, 배송정보 조회</span></span><br><span class="line">  OrdersDto order = ordersDao.selectOrders(orderId);</span><br><span class="line">  BillingDto billing = billingDao.selectBilling(orderId);</span><br><span class="line">  DeliveryDto delivery = deliveryDao.selectDelivery(orderId);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//2) 배송 취소를 해야하는지 상태값 확인</span></span><br><span class="line">  String deliveryStatus = delivery.getStatus();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//3) 만약 배송중이라면 배송취소로 변경</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="string">&quot;IN_PROGRESS&quot;</span>.equals(deliveryStatus))&#123;</span><br><span class="line">    delivery.setStatus(<span class="string">&quot;CANCEL&quot;</span>);</span><br><span class="line">    deliveryDao.update(delivery);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//4) 각 테이블에 취소 상태 Update</span></span><br><span class="line">  order.setStatus(<span class="string">&quot;CANCEL&quot;</span>);</span><br><span class="line">  orderDao.update(order);</span><br><span class="line"></span><br><span class="line">  billing.setStatus(<span class="string">&quot;CANCEL&quot;</span>);</span><br><span class="line">  deliveryDao.update(billing);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> order;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>모든 로직이 서비스 클래스 내부에서 처리된다면 <strong>서비스 계층이 무의미하며, 객체란 단순히 데이터 덩어리</strong> 역할만 하게 된다.</p><p>반면 도메인 모델에서 처리할 경우 아래와 같은 코드가 될 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function">Public Order <span class="title">cancelOrder</span><span class="params">(<span class="keyword">int</span> orderId)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//1)</span></span><br><span class="line">  OrdersDto order = ordersDao.selectOrders(orderId);</span><br><span class="line">  BillingDto billing = billingDao.selectBilling(orderId);</span><br><span class="line">  DeliveryDto delivery = deliveryDao.selectDelivery(orderId);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//2-3)</span></span><br><span class="line">  delivery.cancel();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//4)</span></span><br><span class="line">  order.cancel();</span><br><span class="line">  billing.cancel();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> order;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>order, billing, delivery가 각자 본인의 취소 이벤트 처리를 하며, 서비스 메소드는 트랜잭션과 도메인 간의 순서만 보장해 준다.</p><hr><p>스프링에서 Bean을 주입하는 방식은 다음과 같다.</p><ul><li>@Autowired</li><li>setter</li><li>생성자</li></ul><p>가장 권장하는 방식은 <strong>생성자로 주입</strong>받는 방식이며 @Autowired는 권장하지 않는다.</p><p>아래 Service 코드에서 생성자는 직접 쓰지 않고 <strong>@RequiredArgsConstructor</strong>어노테이션에서 해결해 준다.</p><p>final이 선언된 모든 필드를 인자값으로 하는 생성자를 롬북에서 대신 생성해준다.</p><p>이처럼 어노테이션을 사용하는 이유는 해당 클래스의 의존성 관계가 변경될 때마다 생성자 코드를 변경하는 수고를 덜기 위함이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.jojoldu.book.springboot.domain.posts.PostsRepository;</span><br><span class="line"><span class="keyword">import</span> com.jojoldu.book.springboot.web.dto.PostsSaveRequestDto;</span><br><span class="line"><span class="keyword">import</span> lombok.RequiredArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.annotation.Transactional;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PostsService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PostsRepository postsRepository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">save</span><span class="params">(PostsSaveRequestDto requestDto)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> postsRepository.save(requestDto.toEntity()).getId();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Controller와 Service에서 사용할 Dto 클래스는 언듯 Entity 클래스와 유사한 형태지만 추가로 생성해야한다.</p><p>즉, 절대로 Entity 클래스를 Request/Response 클래스로 사용해선 안된다.</p><p>이유는 Entity 클래스는 데이터베이스와 맞닿은 핵심 클래스로 화면 변경은 사소한 변경인데 이를 건들기 위해 테이블과 연결된 Entity 클래스를 변경하는 것은 너무 큰 변경이다.</p><p>수많은 서비스 클래스나 비즈니스 로직들이 Entity 클래스를 기준으로 동작하며 Entity 클래스가 변경되면 여러 클래스에 영향을 끼지지만</p><p>Request/Response 용 Dto는 View를 위한 클래스라 자주 변경이 필요하다.</p><p>이처럼 View Layer 와 DB Layer 의 역할을 철저히 분리하는게 좋다.</p><p>예를 들어 Controller에서 결과값으로 여러 테이블을 조인해야 하는 경우 Entity 클래스만으로 표현하기 어려운 경우도 있다.</p><p>다음은 JPA를 사용한 게시판의 등록 API 테스트 코드이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.jojoldu.book.springboot.web;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.jojoldu.book.springboot.domain.posts.Posts;</span><br><span class="line"><span class="keyword">import</span> com.jojoldu.book.springboot.domain.posts.PostsRepository;</span><br><span class="line"><span class="keyword">import</span> com.jojoldu.book.springboot.web.dto.PostsSaveRequestDto;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.AfterEach;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.extension.ExtendWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.web.client.TestRestTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.web.server.LocalServerPort;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.HttpStatus;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.ResponseEntity;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit.jupiter.SpringExtension;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.assertj.core.api.Assertions.assertThat;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ExtendWith(SpringExtension.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PostsApiControllerTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@LocalServerPort</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TestRestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> PostsRepository postsRepository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterEach</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tearDown</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        postsRepository.deleteAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> Posts_등록된다() <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//given</span></span><br><span class="line">        String title = <span class="string">&quot;title&quot;</span>;</span><br><span class="line">        String content = <span class="string">&quot;content&quot;</span>;</span><br><span class="line">        PostsSaveRequestDto requestDto = PostsSaveRequestDto.builder().title(title).content(content).author(<span class="string">&quot;author&quot;</span>).build();</span><br><span class="line"></span><br><span class="line">        String url = <span class="string">&quot;http://localhost:&quot;</span> + port + <span class="string">&quot;/api/v1/posts&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//when</span></span><br><span class="line">        ResponseEntity&lt;Long&gt; responseEntity = restTemplate.postForEntity(url, requestDto, Long.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//then</span></span><br><span class="line">        assertThat(responseEntity.getStatusCode()).isEqualTo(HttpStatus.OK);</span><br><span class="line">        assertThat(responseEntity.getBody()).isGreaterThan(<span class="number">0L</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;Posts&gt; all = postsRepository.findAll();</span><br><span class="line">        assertThat(all.get(<span class="number">0</span>).getTitle()).isEqualTo(title);</span><br><span class="line">        assertThat(all.get(<span class="number">0</span>).getContent()).isEqualTo(content);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HelloController와 달리 <code>@WebMvcTest</code>를 사용하지 않는데 @WebMvcTest의 경우 JPA기능이 작동하지 않기 때문인데 Controller와 ControllerAdvice 등 외부 연동과 관련된 부분만 활성화되니</p><p>지금 처럼 JPA 기능까지 한번에 테스트할 때는 @SpringBootTest 와 TestRestTemplate을 사용하면 된다.</p><hr><p>JPA를 사용할 때 update 기능에서 <strong>데이터베이스에 쿼리를 날리는 부분이 없다.</strong><br>이게 가능한 이유는 JPA의 <strong>영속성 컨텍스트</strong> 때문이다.</p><p>영속성 컨텍스트란, <strong>엔티티를 영구 저장하는 환경</strong>으로 일종의 논리적 개념이라고 보면 되며 JPA의 핵심 내용은 엔티티가 영속성 컨텍스트에 포함되어 있냐 아니냐로 갈린다.</p><p>JPA의 엔티티 매니저가 활성화된 상태로(Spring Data Jpa를 쓴다면 기본 옵션) <strong>트랜잭션 안에서 데이터베이스에서 데이터를 가져오면</strong> 이 데이터는 영속성 컨텍스트가 유지된 상태이다.</p><p>이 상태에서 해당 데이터의 값을 변경하면 <strong>트랜잭션이 끝나는 시점에 해당 테이블에 변경분을 반영</strong>한다. 즉, Entity 객체의 값만 변경하면 별도로 Update쿼리를 날릴 필요가 없는데 이를 <code>더티 체킹(dirty checking)</code>이라고 한다.</p><hr><h2 id="3-5-JPA-Auditing으로-생성시간-수정시간-자동화하기"><a href="#3-5-JPA-Auditing으로-생성시간-수정시간-자동화하기" class="headerlink" title="3.5 JPA Auditing으로 생성시간/수정시간 자동화하기"></a>3.5 JPA Auditing으로 생성시간/수정시간 자동화하기</h2><p>보통 엔티티에는 해당 데이터의 생성시간과 수정시간을 포함하는데 반복적인 코드를 모든 테이블과 서비스 메소드에 포함하면 너무 귀찮으니 JPA Auditing를 사용해보자.</p><h3 id="LocalDate-사용"><a href="#LocalDate-사용" class="headerlink" title="LocalDate 사용"></a>LocalDate 사용</h3><p>Java8부터 LocalDate와 LocalDateTime이 등장하여 그간 Java의 기본 날짜 타입인 Date의 문제점을 제대로 고쳤으니 꼭 사용하자.</p><ul><li>BaseTimeEntity.java<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.Getter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.annotation.CreatedDate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.annotation.LastModifiedDate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.jpa.domain.support.AuditingEntityListener;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.persistence.EntityListeners;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.MappedSuperclass;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@MappedSuperclass</span></span><br><span class="line"><span class="meta">@EntityListeners(AuditingEntityListener.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseTimeEntity</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@CreatedDate</span></span><br><span class="line">    <span class="keyword">private</span> LocalDateTime createDate;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@LastModifiedDate</span></span><br><span class="line">    <span class="keyword">private</span> LocalDateTime modifiedDate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>BaseTimeEntity클래스는 모든 Entity의 상위 클래스가 되어 Entity들의 createdDate, modifiedDate를 자동으로 관리하는 역할이다.</li></ul><ol><li>@MappedSuperclass</li></ol><ul><li>JPA Entity 클래스들이 BaseTimeEntity을 상속할 경우 필드들(createdDate, modifiedDate)도 컬럼으로 인식하도록 한다.</li></ul><ol start="2"><li>@EntityListeners(AuditingEntityListener.class)</li></ol><ul><li>BaseTimeEntity 클래스에 Auditing 기능을 포함시킨다.</li></ul><ol start="3"><li>CreatedDate</li></ol><ul><li>Entity가 생성되어 저장될 때 시간이 자동 저장된다.</li></ul><ol start="4"><li>LastModifiedDate</li></ol><ul><li>조회한 Entity의 값을 변경할 때 시간이 자동 저장된다.</li></ul><p>이후 앞서 만든 Posts 클래스가 BaseTimeEntity를 상속받도록 변경한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  ...</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Posts</span> <span class="keyword">extends</span> <span class="title">BaseTimeEntity</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>마지막으로 JPA Auditing 어노테이션들을 모두 활성화할 수 있도록 Application 클래스에 활성화 어노테이션을 추가한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableJpaAuditing</span> <span class="comment">// JPA Auditing 활성화</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://yoo0926.github.io/categories/book/">book</category>
      
      <category domain="https://yoo0926.github.io/categories/book/%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8%EC%99%80-AWS%EB%A1%9C-%ED%98%BC%EC%9E%90-%EA%B5%AC%ED%98%84%ED%95%98%EB%8A%94-%EC%9B%B9%EC%84%9C%EB%B9%84%EC%8A%A4/">스프링부트와 AWS로 혼자 구현하는 웹서비스</category>
      
      
      <category domain="https://yoo0926.github.io/tags/spring/">spring</category>
      
      <category domain="https://yoo0926.github.io/tags/book/">book</category>
      
      
      <comments>https://yoo0926.github.io/2021/04/22/book/%EC%8A%A4%ED%94%84%EB%A7%81-%EB%B6%80%ED%8A%B8%EC%99%80-AWS%EB%A1%9C-%ED%98%BC%EC%9E%90-%EA%B5%AC%ED%98%84%ED%95%98%EB%8A%94-%EC%9B%B9%EC%84%9C%EB%B9%84%EC%8A%A4/3/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>2.테스트코드 작성하기</title>
      <link>https://yoo0926.github.io/2021/04/21/book/%EC%8A%A4%ED%94%84%EB%A7%81-%EB%B6%80%ED%8A%B8%EC%99%80-AWS%EB%A1%9C-%ED%98%BC%EC%9E%90-%EA%B5%AC%ED%98%84%ED%95%98%EB%8A%94-%EC%9B%B9%EC%84%9C%EB%B9%84%EC%8A%A4/2/</link>
      <guid>https://yoo0926.github.io/2021/04/21/book/%EC%8A%A4%ED%94%84%EB%A7%81-%EB%B6%80%ED%8A%B8%EC%99%80-AWS%EB%A1%9C-%ED%98%BC%EC%9E%90-%EA%B5%AC%ED%98%84%ED%95%98%EB%8A%94-%EC%9B%B9%EC%84%9C%EB%B9%84%EC%8A%A4/2/</guid>
      <pubDate>Wed, 21 Apr 2021 09:08:44 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;JUnit4 -&amp;gt; 5 변경점&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;lin</description>
        
      
      
      
      <content:encoded><![CDATA[<p>JUnit4 -&gt; 5 변경점</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">junit4 -&gt; 5</span><br><span class="line"></span><br><span class="line">  1. @Test</span><br><span class="line">  패키지 위치 변경</span><br><span class="line"></span><br><span class="line">org.junit.Test</span><br><span class="line"><span class="meta">-&gt;</span><span class="bash"> org.junit.jupiter.api.Test</span></span><br><span class="line"></span><br><span class="line">  2. @RunWith</span><br><span class="line">  Junit5에서 @ExtendWith 로 변경되서 어노테이션명과 패키지위치 변경</span><br><span class="line"></span><br><span class="line">org.junit.runner.RunWith</span><br><span class="line"><span class="meta">-&gt;</span><span class="bash"> org.junit.jupiter.api.extension.ExtendWith</span></span><br><span class="line"></span><br><span class="line">@RunWith</span><br><span class="line"><span class="meta">-&gt;</span><span class="bash"> @ExtendWith</span></span><br><span class="line"></span><br><span class="line">  3. SpringRunner</span><br><span class="line">  SpringExtension 으로 변경되서 클래스명과 패키지위치 변경</span><br><span class="line"></span><br><span class="line">SpringRunner</span><br><span class="line"><span class="meta">-&gt;</span><span class="bash"> SpringExtension</span></span><br><span class="line"></span><br><span class="line">org.springframework.test.context.junit4.SpringRunner</span><br><span class="line"><span class="meta">-&gt;</span><span class="bash"> org.springframework.test.context.junit.jupiter.SpringExtension</span></span><br><span class="line"></span><br><span class="line">  4. @After</span><br><span class="line">  테스트 메소드가 끝날때마다 수행되는 @After 도 Junit5에서 @AfterEach 로 변경되었기 때문에 어노테이션과 패키지위치 변경</span><br><span class="line"></span><br><span class="line">@After</span><br><span class="line"><span class="meta">-&gt;</span><span class="bash"> @AfterEach</span></span><br><span class="line"></span><br><span class="line">org.junit.After</span><br><span class="line"><span class="meta">-&gt;</span><span class="bash"> org.junit.jupiter.api.AfterEach</span></span><br><span class="line"></span><br><span class="line">  5. @Before</span><br><span class="line">  마찬가지로 @BeforeEach 로 변경되서 어노테이션과 패키지위치 변경</span><br><span class="line"></span><br><span class="line">@Before</span><br><span class="line"><span class="meta">-&gt;</span><span class="bash"> @BeforeEach</span></span><br><span class="line"></span><br><span class="line">org.junit.Before</span><br><span class="line"><span class="meta">-&gt;</span><span class="bash"> org.junit.jupiter.api.BeforeEach</span></span><br></pre></td></tr></table></figure><p>샘플 컨트롤러 코드</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.jojoldu.book.springboot.web;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="comment">//컨트롤러를 JSON을 반환하는 컨트롤러로 만들어준다.</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//HTTP Method인 Get의 요청을 받을 수 있는 API를 만들어 준다.</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>샘플 단위 테스트 코드</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.jojoldu.book.springboot.web;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.extension.ExtendWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit.jupiter.SpringExtension;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.web.servlet.MockMvc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1. @ExtendWith(SpringExtension.class)</span></span><br><span class="line"><span class="comment">- 테스트를 진행할 때 JUnit에 내장된 실행자 외에 다른 실행자를 실행시킨다.</span></span><br><span class="line"><span class="comment">- 여기서는 SpringExtension 이라는 스프링 실행자를 사용한다.</span></span><br><span class="line"><span class="comment">- 스프링 부트 테스트와 JUnit 사이에 연결자 역할</span></span><br><span class="line"><span class="comment">- JUnit4 -&gt; 5로 넘어오면서 사용하는 어노테이션과 클래스가 각각 @RunWith -&gt; @ExtendWith 로 SpringRunner -&gt; SpringExtension 으로 변경되었다.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2. @WebMvcTest</span></span><br><span class="line"><span class="comment">- 여러 스프링 테스트 어노테이션 중, Web(Spring MVC)에 집중할 수 있는 어노테이션</span></span><br><span class="line"><span class="comment">- 선언할 경우 @Controller, @ControllerAdvice 등을 사용할 수 있다.</span></span><br><span class="line"><span class="comment">- 단, @Service, @Component, @Repository 등은 사용할 수 없다.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@ExtendWith(SpringExtension.class)</span><span class="comment">//1</span></span><br><span class="line"><span class="meta">@WebMvcTest(controllers = HelloController.class)</span><span class="comment">//2</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloControllerTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    3. AutoWired</span></span><br><span class="line"><span class="comment">    - 스프링이 관리하는 빈(Bean)을 주입 받는다.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    4. private MockMvc mvc</span></span><br><span class="line"><span class="comment">    - 웹 API를 테스트할 때 사용한다.</span></span><br><span class="line"><span class="comment">    - 스프링 MVC 테스트의 시작점</span></span><br><span class="line"><span class="comment">    - 이 클래스를 통해 HTTP GET, POST 등에 대한 API 테스트를 할 수 있다.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Autowired</span><span class="comment">//3</span></span><br><span class="line">    <span class="keyword">private</span> MockMvc mvc;<span class="comment">//4</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> hello가_리턴된다() <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        String hello = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        5. mvc.perform(get(&quot;/hello&quot;))</span></span><br><span class="line"><span class="comment">        - MockMvc를 통해 /hello 주소로 HTTP GET 요청을 한다.</span></span><br><span class="line"><span class="comment">        - 체이닝이 지원되어 아래와 같이 여러 검증 기능을 이어서 선언할 수 있다.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        6. .andExpect(status().isOk())</span></span><br><span class="line"><span class="comment">        - mvc.perform의 결과를 검증한다.</span></span><br><span class="line"><span class="comment">        - HTTP Header의 Status를 검증한다.</span></span><br><span class="line"><span class="comment">        - 우리가 흔히 알고 있는 200, 404, 500 emddml 상태를 검증한다.</span></span><br><span class="line"><span class="comment">        - 여기선 OK 즉, 200인지 아닌지를 검증한다.</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        7. .andExpect(content().string(hello))</span></span><br><span class="line"><span class="comment">        - mvc.perform의 결과를 검증한다.</span></span><br><span class="line"><span class="comment">        - 응답 본문의 내용을 검증한다.</span></span><br><span class="line"><span class="comment">        - Controller에서 &quot;hello&quot;를 리턴하기 때문에 이 값이 맞는지 검증한다.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        mvc.perform(get(<span class="string">&quot;/hello&quot;</span>))<span class="comment">//5</span></span><br><span class="line">                .andExpect(status().isOk())<span class="comment">//6</span></span><br><span class="line">                .andExpect(content().string(hello));<span class="comment">//7</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="2-3-롬북-Lombok"><a href="#2-3-롬북-Lombok" class="headerlink" title="2.3 롬북(Lombok)"></a>2.3 롬북(Lombok)</h2><p>자바 개발 시 자주 사용하는 코드 Getteer, Setter, 기본생성자, toString 등을 어노테이션으로 자동 생성해준다.</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    <span class="comment">// lombok</span></span><br><span class="line">    implementation(<span class="string">&#x27;org.projectlombok:lombok&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://yoo0926.github.io/categories/book/">book</category>
      
      <category domain="https://yoo0926.github.io/categories/book/%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8%EC%99%80-AWS%EB%A1%9C-%ED%98%BC%EC%9E%90-%EA%B5%AC%ED%98%84%ED%95%98%EB%8A%94-%EC%9B%B9%EC%84%9C%EB%B9%84%EC%8A%A4/">스프링부트와 AWS로 혼자 구현하는 웹서비스</category>
      
      
      <category domain="https://yoo0926.github.io/tags/spring/">spring</category>
      
      <category domain="https://yoo0926.github.io/tags/book/">book</category>
      
      
      <comments>https://yoo0926.github.io/2021/04/21/book/%EC%8A%A4%ED%94%84%EB%A7%81-%EB%B6%80%ED%8A%B8%EC%99%80-AWS%EB%A1%9C-%ED%98%BC%EC%9E%90-%EA%B5%AC%ED%98%84%ED%95%98%EB%8A%94-%EC%9B%B9%EC%84%9C%EB%B9%84%EC%8A%A4/2/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>1.SpringBoot 시작하기</title>
      <link>https://yoo0926.github.io/2021/04/21/book/%EC%8A%A4%ED%94%84%EB%A7%81-%EB%B6%80%ED%8A%B8%EC%99%80-AWS%EB%A1%9C-%ED%98%BC%EC%9E%90-%EA%B5%AC%ED%98%84%ED%95%98%EB%8A%94-%EC%9B%B9%EC%84%9C%EB%B9%84%EC%8A%A4/1/</link>
      <guid>https://yoo0926.github.io/2021/04/21/book/%EC%8A%A4%ED%94%84%EB%A7%81-%EB%B6%80%ED%8A%B8%EC%99%80-AWS%EB%A1%9C-%ED%98%BC%EC%9E%90-%EA%B5%AC%ED%98%84%ED%95%98%EB%8A%94-%EC%9B%B9%EC%84%9C%EB%B9%84%EC%8A%A4/1/</guid>
      <pubDate>Wed, 21 Apr 2021 09:08:27 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;솔루션 회사를 몇년 다니다보니 내가 생각하는 웹서비스 환경의 경험이 적다는 생각이 들어서 &lt;code&gt;A to Z&lt;/code&gt;까지 천천히 따라가면서 조금이나마 경험을 늘릴 수 있는 계기가 되지 않을까 싶어서 서적을 하나 구매해보았다.&lt;/p&gt;
&lt;p&gt;</description>
        
      
      
      
      <content:encoded><![CDATA[<p>솔루션 회사를 몇년 다니다보니 내가 생각하는 웹서비스 환경의 경험이 적다는 생각이 들어서 <code>A to Z</code>까지 천천히 따라가면서 조금이나마 경험을 늘릴 수 있는 계기가 되지 않을까 싶어서 서적을 하나 구매해보았다.</p><p>이하 포스팅할 내용은 모두 <code>스프링 부트와 AWS로 혼자 구현하는 웹 서비스</code>라는 책을 읽고 작성한 내용으로 학습한 내용을 정리하기 위함이다.</p><h2 id=""><a href="#" class="headerlink" title=""></a><img src="/img/spring/spring-2-0.jpg" alt="스프링 부트와 AWS로 혼자 구현하는 웹 서비스"></h2><ul><li>개발환경은 책과 좀 다르다. 시간도 지났고 기존에 사용하던 환경이 있으므로<ul><li>openJDK 11</li><li>Gradle 6.7</li><li>IntelliJ 유료버전</li></ul></li></ul><h1 id="1-인텔리제이로-스프링-부트-시작하기"><a href="#1-인텔리제이로-스프링-부트-시작하기" class="headerlink" title="1. 인텔리제이로 스프링 부트 시작하기"></a>1. 인텔리제이로 스프링 부트 시작하기</h1><p>이미 인텔리제이는 사용하고 있지만 책에서 언급한 이클립스에 비해 인텔리제이가 가진 장점은 다음과 같다.</p><ul><li>강력한 추천 기능(Smart Completion)</li><li>훨씬 더 다양한 리팩토링과 디버깅 기능</li><li>이클립스의 깃(Git)에 비해 훨씬 높은 자유도</li><li>프로젝트 시작할 때 인덱싱을 하여 파일을 비롯한 자원들에 대한 빠른 검색 속도</li><li>HTML과 CSS, JS, XML에 대한 강력한 기능 지원</li><li>자바, 스프링 부트 버전업에 맞춘 빠른 업데이트</li></ul><p>인텔리제이는 무료버전과 유료버전이 모두 존재하지만 <strong>커뮤니티(무료)</strong> 버전만 사용하더라도 개발에 큰 지장은 없다. 자바 개발에 대한 모든 기능 및 <code>Maven</code>, <code>Gradle</code>과 같은 빌드 도구도 모두 지원한다.</p><blockquote><p>여담으로 둘다 써본 경험에서 불편했던 점은 딱 한가지였는데 임베디드 톰캣이 아닌 외부 톰캣과 연동하는 경우 커뮤니티 버전에선 공식적으로 지원하지 않아서 별도의 플러그인을 설치해서 사용했는데 그게 좀 귀찮았던 기억이 있다.</p><p>그리고 이클립스를 쓰다가 인텔리제이로 넘어오면 가장 당황하는 것이 워크스페이스가 없이 프로젝트와 모듈의 개념만 있다는 점이다. 이 말은 인텔리제이는 한번에 하나의 프로젝트만 열린다는 점이다.</p></blockquote><h2 id="Gradle로-프로젝트-생성"><a href="#Gradle로-프로젝트-생성" class="headerlink" title="Gradle로 프로젝트 생성"></a><code>Gradle</code>로 프로젝트 생성</h2><p><img src="/img/spring/spring-2-1.png" alt="인텔리제이로 프로젝트생성1"></p><p><img src="/img/spring/spring-2-2.png" alt="인텔리제이로 프로젝트생성2"></p><p><em><code>ArtifactId</code>는 프로젝트의 이름이 된다</em></p><p><em>그동안 <code>Maven</code>만 사용해봤는데 <code>Gradle</code>이 가진 장점과 단점은 무엇인지 추후에 찾아봐서 포스팅 해봐야겠다.</em></p><p>시간이 지나면서 버전이 바뀐 영향인지 프로젝트 생성부터 책과 약간 다르게 진행이 되긴 하는데 또 그래야 더 찾아보고 공부가 되지 않을까 하는 생각도 들었다.</p><p><img src="/img/spring/spring-2-3.png" alt="인텔리제이로 프로젝트생성3"></p><p><em>Gradle 프로젝트 생성 완료</em></p><h2 id="Gradle-프로젝트를-springBoot-프로젝트로-변경하기"><a href="#Gradle-프로젝트를-springBoot-프로젝트로-변경하기" class="headerlink" title="Gradle 프로젝트를 springBoot 프로젝트로 변경하기"></a><code>Gradle</code> 프로젝트를 <code>springBoot</code> 프로젝트로 변경하기</h2><ul><li>초기 <code>build.gradle</code> 파일</li></ul><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    id <span class="string">&#x27;java&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">group <span class="string">&#x27;com.springboot.service&#x27;</span></span><br><span class="line">version <span class="string">&#x27;1.0-SNAPSHOT&#x27;</span></span><br><span class="line"></span><br><span class="line">repositories &#123;</span><br><span class="line">    mavenCentral()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    testImplementation <span class="string">&#x27;org.junit.jupiter:junit-jupiter-api:5.6.0&#x27;</span></span><br><span class="line">    testRuntimeOnly <span class="string">&#x27;org.junit.jupiter:junit-jupiter-engine&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test &#123;</span><br><span class="line">    useJUnitPlatform()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>음… 여기서부터 책과 벌써 다르다. 아무래도 책의 출판시점에서 2년이나 지났으니 각종 라이브러리, 도구들의 버전업이 일어나면서 여러 내용들이 바뀐듯 하다.</p><p>구글링을 해보니 저자분이 [2020.12.16] 기준으로 최신 라이브러리로 버전업한 내용에 대해 정리해놓은 글이 있어서 해당 내용을 참고하였다.</p><p>참고링크 : <a href="https://jojoldu.tistory.com/539">스프링 부트와 AWS로 혼자 구현하는 웹 서비스 (2020.12.16)</a></p><p>변경된 도구들의 버전은 다음과 같다.</p><table><thead><tr><th>라이브러리,도구명</th><th>출판버전</th><th>웹버전</th></tr></thead><tbody><tr><td>Spring Boot</td><td>2.1.7</td><td>2.4.1</td></tr><tr><td>Gradle</td><td>4.8~4.10</td><td>6.7.1</td></tr><tr><td>JUnit</td><td>4</td><td>5</td></tr></tbody></table>]]></content:encoded>
      
      
      <category domain="https://yoo0926.github.io/categories/book/">book</category>
      
      <category domain="https://yoo0926.github.io/categories/book/%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8%EC%99%80-AWS%EB%A1%9C-%ED%98%BC%EC%9E%90-%EA%B5%AC%ED%98%84%ED%95%98%EB%8A%94-%EC%9B%B9%EC%84%9C%EB%B9%84%EC%8A%A4/">스프링부트와 AWS로 혼자 구현하는 웹서비스</category>
      
      
      <category domain="https://yoo0926.github.io/tags/spring/">spring</category>
      
      <category domain="https://yoo0926.github.io/tags/book/">book</category>
      
      
      <comments>https://yoo0926.github.io/2021/04/21/book/%EC%8A%A4%ED%94%84%EB%A7%81-%EB%B6%80%ED%8A%B8%EC%99%80-AWS%EB%A1%9C-%ED%98%BC%EC%9E%90-%EA%B5%AC%ED%98%84%ED%95%98%EB%8A%94-%EC%9B%B9%EC%84%9C%EB%B9%84%EC%8A%A4/1/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>함수형 프로그래밍 - 재귀</title>
      <link>https://yoo0926.github.io/2020/12/07/functional/%EC%9E%AC%EA%B7%80/</link>
      <guid>https://yoo0926.github.io/2020/12/07/functional/%EC%9E%AC%EA%B7%80/</guid>
      <pubDate>Sun, 06 Dec 2020 15:13:19 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;앞서 확인한 개요에서 언급했는데 함수형 프로그래밍에선 반복을 재귀를 통해서 구현한다고 했는데 재귀와 꼬리재귀에 대해서 간단히 알아보자.&lt;/p&gt;
&lt;h2 id=&quot;재귀&quot;&gt;&lt;a href=&quot;#재귀&quot; class=&quot;headerlink&quot; title=&quot;재귀&quot;&gt;&lt;</description>
        
      
      
      
      <content:encoded><![CDATA[<p>앞서 확인한 개요에서 언급했는데 함수형 프로그래밍에선 반복을 재귀를 통해서 구현한다고 했는데 재귀와 꼬리재귀에 대해서 간단히 알아보자.</p><h2 id="재귀"><a href="#재귀" class="headerlink" title="재귀"></a>재귀</h2><p>함수 본문에서 자기자신을 호출하는 방식을 <code>재귀호출(recursive call)</code>이라고 부른다. 재귀는 다른 명령어가 방지할 때까지 계속된다.</p><h2 id="예제"><a href="#예제" class="headerlink" title="예제"></a>예제</h2><script src="https://gist.github.com/yoo0926/c22f935380ac613ff3a33e5970af0ea3.js"></script><hr><h2 id="꼬리-재귀-최적화-in-python"><a href="#꼬리-재귀-최적화-in-python" class="headerlink" title="꼬리 재귀 최적화 in python"></a>꼬리 재귀 최적화 in python</h2><p>재귀호출의 경우 호출 스택의 깊이가 얕은 경우엔 큰 상관이 없으나 깊이가 깊어지면 오버플로우가 발생하는 문제가 있다.<br><em>여담으로 실행하는 <del>시스템에 따라서 조금씩 다를수 있지만</del> 파이썬에서 호출가능한 스택의 최대 깊이는 보통 1000 정도에서 <code>RecursionError</code>가 발생한다.</em></p><script src="https://gist.github.com/yoo0926/9eab6f85efac2999cd3702c3f08716cc.js"></script><p>이를 해결하기 위한 방법으로 제시되는 해결책 중 하나가 꼬리 재귀<code>Tail recursion</code>이다.</p><p>간단히 말하자면 함수에서 마지막으로 호출하는 함수가 자기 자신이고, 재귀 호출의 값을 반환받은후 추가적인 연산이 필요하지 않는 방식을 말한다.</p><hr><h2 id="꼬리-재귀-적용-예제"><a href="#꼬리-재귀-적용-예제" class="headerlink" title="꼬리 재귀 적용 예제"></a>꼬리 재귀 적용 예제</h2><p>위의 예제에서 사용한 팩토리얼 함수를 보자.</p><p>fact(n)을 호출했을 때 연산이 끝나지 않았는데 fact(n-1)을 호출하기 때문에 리턴 주소를 저장하기 위해서 시스템 콜스택을 사용하게 된다.</p><p>즉, 현재 함수(fact(n))에서 결과값을 반환하기 위해서는 현재 함수의 인자 값(n)을 스택에 가지고 있다가 그 다음 호출될 함수(fact(n-1))의 결과 값과 함께 연산을 해야 한다는 점이다.<br>이러한 방식은 꼬리 재귀를 만족하지 못한다고 본다.</p><p>예제를 꼬리 재귀로 바꾸려면 어떻게 해야할까? 재귀를 호출하는 부분에서 추가적인 연산이 필요없도록 만들면 되는데</p><p>이를 구현하기 위해선</p><blockquote><p>return에서는 <em>(언어 스펙에서 지정한 스택에 메모리를 쌓지 않는 연산자를 제외한)</em> 연산자를 사용하면 안된다.</p></blockquote><p>연산자의 사용없이 재귀 호출의 반환값을 그대로 return 해주면 된다.</p><script src="https://gist.github.com/yoo0926/10a170843e290ce85e22acf0d62e374a.js"></script><p>한가지 주의할 점은 개발자가 꼬리재귀 구조로 코드를 짜더라도 사용하는 언어의 스펙에 따라서 꼬리재귀 최적화 보장여부가 다르기 때문에 확인이 필요하다.<br>요즘 python을 공부하고 싶어서 위 예시를 python으로 들었지만 python은 꼬리재귀 최적화를 보장하지 않는데 python의 창시자 <code>귀도 반 로섬</code>의 의견은 다음과 같다.</p><blockquote><p>귀도 반 로섬의 TRE(Tail Recursion Elimination)에 대한 반론</p><ul><li>콜 스택을 추적하기에 부적합하다(디버깅이 어렵다)</li><li>단순 최적화기 때문에 개별 파이썬 컴파일러 구현체에서 선택하게 둘 것</li><li>재귀가 모든 것의 기반이라는 접근은 이상적인 수학적인 접근일 뿐이다</li><li>파이썬 스타일의 개발자들은 재귀 대신 멋진(?) 문법들을 쓸 수 있다</li><li>not PYTHONIC 하다</li></ul></blockquote><hr><p><em><strong>Reference</strong></em></p><p><a href="https://www.tutorialspoint.com/functional_programming/functional_programming_recursion.htm">tutorialspoint - Learn Functional Programming</a></p><p><a href="https://homoefficio.github.io/2015/07/27/%EC%9E%AC%EA%B7%80-%EB%B0%98%EB%B3%B5-Tail-Recursion/">재귀,반복, Tail Recursion</a></p><p><a href="http://neopythonic.blogspot.com/2009/04/tail-recursion-elimination.html">Tail Recursion Elimination</a></p>]]></content:encoded>
      
      
      <category domain="https://yoo0926.github.io/categories/functional/">functional</category>
      
      
      <category domain="https://yoo0926.github.io/tags/functional/">functional</category>
      
      
      <comments>https://yoo0926.github.io/2020/12/07/functional/%EC%9E%AC%EA%B7%80/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
